# Copyright (C) Deutsche Telekom AG
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import logging

import telemetrify.nsoapi.conf as conf
from telemetrify.common.mod import Tag, ITag, HTag, PTag, MTag, Keypath, Key
from telemetrify.common.utils import *
from telemetrify.nsoapi.conf import *
from telemetrify.nsoapi.proto import *


# confd_cs_node.flags
CS_NODE_IS_LIST: i64 = 1
CS_NODE_IS_WRITE: i64 = 1 << 1
CS_NODE_IS_CDB: i64 = 1 << 2
CS_NODE_IS_ACTION: i64 = 1 << 3
CS_NODE_IS_PARAM: i64 = 1 << 4
CS_NODE_IS_RESULT: i64 = 1 << 5
CS_NODE_IS_NOTIF: i64 = 1 << 6
CS_NODE_IS_CASE: i64 = 1 << 7
CS_NODE_IS_CONTAINER: i64 = 1 << 8
CS_NODE_HAS_WHEN: i64 = 1 << 9
CS_NODE_HAS_DISPLAY_WHEN: i64 = 1 << 10
CS_NODE_META_DATA: i64 = 1 << 11
CS_NODE_IS_WRITE_ALL: i64 = 1 << 12
CS_NODE_IS_LEAF_LIST: i64 = 1 << 13
CS_NODE_IS_LEAFREF: i64 = 1 << 14
CS_NODE_HAS_MOUNT_POINT: i64 = 1 << 15
CS_NODE_IS_STRING_AS_BINARY: i64 = 1 << 16

# confd value range flags
CONFD_RANGE_MIN_INCLUSIVE: i64 = 1
CONFD_RANGE_MIN_EXCLUSIVE: i64 = 1 << 1
CONFD_RANGE_MAX_INCLUSIVE: i64 = 1 << 2
CONFD_RANGE_MAX_EXCLUSIVE: i64 = 1 << 3

# NODE_NP_CONTAINER = 1
# NODE_P_CONTAINER = 2
# NODE_LIST = 3
# NODE_EMPTY_LEAF = 5
# NODE_NON_EMPTY_LEAF = 6
# NODE_LEAF_LIST = 7
# # NODE_ACTION = 16 # action/rpc
# # NODE_PARAM = 17
# # NODE_RESULT = 18
# # NODE_NOTIFICATION = 32

ROOT_MOUNT_ID = HTag(0, 0)

class TypeId:
    @property
    ns_hash: int
    @property
    name: str
    # @property
    # ns_descr: NamespaceDescription
    # @property
    # name: str

    def __init__(self, ns_hash: int, name: str):
        self.ns_hash = ns_hash
        self.name = name

    def __str__(self) -> str:
        return str(self.ns_hash) + ":" + self.name

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    def str_pretty(self, hash_to_name: dict[int, str]) -> str:
        cns = try_get(hash_to_name, self.ns_hash)
        if cns is not None:
            return cns + ":" + self.name
        return self.__str__()

extension TypeId(Hashable):
    def __eq__(self, other) -> bool:
        return self.name == other.name and self.ns_hash == other.ns_hash

    def __hash__(self) -> int:
        return safe_hash(self.ns_hash + hash(self.name))

EMPTY_TYPE_ID = TypeId(0, "")

pass

class SchemaPath(object):
    @property
    tags: list[Tag]
    @property
    mount_ids: list[?HTag]

    def __init__(self, tags: list[Tag], mount_ids: list[?HTag]):
        self.tags = tags
        self.mount_ids = mount_ids

    def __str__(self) -> str:
        return self.__repr__()

    def __repr__(self) -> str:
        return "SchemaPath(%s, %s)" % (list_repr(self.tags), list_optional_repr(self.mount_ids))

actor SharedSchema(schema: Schema):
    def __dummy() -> Schema:
        """Needed to prevent schema param from being removed by optimizer"""
        return schema

    # pure def shared_schema() -> Schema:
    #     """Gets a shared pointer to the (immutable) schema instance"""
    #     #return Schema({}, {}, {}, {}, {}, {})
    #     #return schema
    #     NotImplemented

class Schema:
    # @property
    # _roots: HTagDict[Node]
    @property
    _root: Node
    @property
    _nshash_to_namespace: dict[int, NamespaceDescription]
    @property
    _cns_to_namespace: dict[str, NamespaceDescription]
    @property
    _hash_to_name: dict[int, str]
    @property
    _name_to_hash: dict[str, int]
    @property
    _mount_id_maps: dict[HTag, NamespaceMaps]

    def __init__(self,
                    roots: dict[HTag, Node],
                    nshash_to_namespace: dict[int, NamespaceDescription],
                    cns_to_namespace: dict[str, NamespaceDescription],
                    hash_to_name: dict[int, str],
                    name_to_hash: dict[str, int],
                    mount_id_maps: dict[HTag, NamespaceMaps]):
        #self._roots = roots
        self._root = Node(HTag(0, 0), 1, 1, CS_NODE_IS_CONTAINER, 0, None, [], roots)
        self._nshash_to_namespace = nshash_to_namespace
        self._cns_to_namespace = cns_to_namespace
        self._hash_to_name = hash_to_name
        self._name_to_hash = name_to_hash
        self._mount_id_maps = mount_id_maps

    def cns_to_namespace(self, cns: str) -> ?NamespaceDescription:
        return try_get(self._cns_to_namespace, cns)

    def nshash_to_namespace(self, ns_hash: int) -> ?NamespaceDescription:
        return try_get(self._nshash_to_namespace, ns_hash)

    def hash_to_name(self, _hash: int) -> ?str:
        return try_get(self._hash_to_name, _hash)

    def name_to_hash(self, name: str) -> ?int:
        return try_get(self._name_to_hash, name)

    def mount_id_map(self, mount_id: HTag) -> ?NamespaceMaps:
        return try_get(self._mount_id_maps, mount_id)

class Cursor:
    @property
    _schema: Schema
    @property
    _path: list[Node]
    @property
    _mount_points: list[?(HTag, NamespaceMaps)]

    def __init__(self, schema: Schema):
        self._schema = schema
        self._path = [schema._root]
        self._mount_points = []
        root_nsmaps = try_get(schema._mount_id_maps, ROOT_MOUNT_ID)
        self._mount_points.append((ROOT_MOUNT_ID, root_nsmaps) if root_nsmaps is not None else None)

    def clone(self):
        other = Cursor(self._schema)
        other._path.extend(self._path[1:])
        other._mount_points.extend(self._mount_points)
        return other

    def get_schema_path(self) -> SchemaPath:
        tags: list[Tag] = []
        mount_ids: list[?HTag] = []
        for node in self._path[1:]:
            tags.append(node.tag)
        for entry in self._mount_points:
            mount_ids.append(entry.0 if entry is not None else None)
        return SchemaPath(tags, mount_ids)

    def push_schema_path(self, schema_path: SchemaPath) -> bool:
        tags = schema_path.tags
        tags_index = 0
        tags_len = len(tags)
        mount_ids = schema_path.mount_ids
        mount_ids_index = 0
        mount_ids_len = len(mount_ids)

        success = True

        for tag in tags:
            if not self.push(tag):
                success = False
                break
            if self.node().is_mount_point():
                if mount_ids_index >= mount_ids_len or not self.set_mount_id(mount_ids[mount_ids_index]):
                    success = False
                    break
                mount_ids_index += 1
            tags_index += 1

        if not success:
            for i in range(0, tags_index, 1):
                self.pop()

        return success

    def push(self, tag: Tag) -> bool:
        _node: ?Node = None
        htag = self.lookup_htag(tag, True)
        if htag is not None:
            _node = try_get(self.node().children, htag)
            if _node is not None:
                self._path.append(_node)
                if _node.is_mount_point():
                    self._mount_points.append(None)
                return True
        return False

    def _pop(self) -> None:
        path = self._path
        #node: Node = path.pop()
        node: Node = list_pop(path)
        if node.is_mount_point():
            #self._mount_points.pop()
            del self._mount_points[-1]

    def pop(self) -> bool:
        if len(self._path) >= 2:
            self._pop()
            return True
        return False

    def path(self):
        return self._path

    def pop_verify(self, tag: Tag) -> bool:
        if len(self._path) >= 2:
            actual_tag = self.node().tag
            try_tag = self.lookup_htag(tag, False)
            if try_tag is not None and (try_tag == actual_tag or try_tag.ns_hash == 0 and try_tag.name_hash == actual_tag.name_hash):
                self._pop()
                return True
        return False

    def set_mount_id(self, mount_id: ?HTag) -> bool:
        if mount_id is not None:
            ns_maps = self._schema.mount_id_map(mount_id)
            if ns_maps is not None:
                self._mount_points[-1] = (mount_id, ns_maps)
                return True
            return False
        self._mount_points[-1] = None
        return True

    def node(self) -> Node:
        return self._path[-1]

    def prefix_to_namespace(self, prefix: str) -> ?NamespaceDescription:
        mount_points = self._mount_points
        for i in range(len(mount_points)-1, -1, -1):
            entry: ?(HTag, NamespaceMaps) = mount_points[i]
            if entry is not None:
                nsmaps: NamespaceMaps = entry.1
                ns_descr = try_get(nsmaps.prefix_to_namespace, prefix)
                if ns_descr is not None:
                    return ns_descr
        return None

    def ns_to_namespace(self, ns: str) -> ?NamespaceDescription:
        mount_points = self._mount_points
        for i in range(len(mount_points)-1, -1, -1):
            entry: ?(HTag, NamespaceMaps) = mount_points[i]
            if entry is not None:
                nsmaps: NamespaceMaps = entry.1
                ns_descr = try_get(nsmaps.ns_to_namespace, ns)
                if ns_descr is not None:
                    return ns_descr
        return None

    def module_to_namespace(self, module: str) -> ?NamespaceDescription:
        mount_points = self._mount_points
        for i in range(len(mount_points)-1, -1, -1):
            entry: ?(HTag, NamespaceMaps) = mount_points[i]
            if entry is not None:
                nsmaps: NamespaceMaps = entry.1
                ns_descr: ?NamespaceDescription = try_get(nsmaps.module_to_namespace, module)
                if ns_descr is not None:
                    return ns_descr
        return None

    def cns_to_namespace(self, cns: str) -> ?NamespaceDescription:
        return self._schema.cns_to_namespace(cns)

    def prefix_to_ns(self, prefix: str) -> ?str:
        ns_descr = self.prefix_to_namespace(prefix)
        if ns_descr is not None:
            return ns_descr.ns
        return None

    def prefix_to_nshash(self, prefix: str) -> ?int:
        ns_descr = self.prefix_to_namespace(prefix)
        if ns_descr is not None:
            return ns_descr.ns_hash
        return None

    def ns_to_nshash(self, ns: str) -> ?int:
        ns_descr = self.ns_to_namespace(ns)
        if ns_descr is not None:
            return ns_descr.ns_hash
        return None

    def ns_to_prefix(self, ns: str) -> ?str:
        ns_descr = self.ns_to_namespace(ns)
        if ns_descr is not None:
            return ns_descr.prefix
        return None

    def module_to_ns(self, module: str) -> ?str:
        ns_descr = self.module_to_namespace(module)
        if ns_descr is not None:
            return ns_descr.ns
        return None

    def module_to_nshash(self, module: str) -> ?int:
        ns_descr = self.module_to_namespace(module)
        if ns_descr is not None:
            return ns_descr.ns_hash
        return None

    def module_to_prefix(self, module: str) -> ?str:
        ns_descr = self.module_to_namespace(module)
        if ns_descr is not None:
            return ns_descr.prefix
        return None

    def nshash_to_prefix(self, ns_hash: int) -> ?str:
        ns_descr = self._schema.nshash_to_namespace(ns_hash)
        if ns_descr is not None:
            return ns_descr.prefix
        return None

    def nshash_to_ns(self, ns_hash: int) -> ?str:
        ns_descr = self._schema.nshash_to_namespace(ns_hash)
        if ns_descr is not None:
            return ns_descr.ns
        return None

    def nshash_to_module(self, ns_hash: int) -> ?str:
        ns_descr = self._schema.nshash_to_namespace(ns_hash)
        if ns_descr is not None:
            return ns_descr.module
        return None

    def lookup_ptag(self, tag: Tag) -> ?PTag:
        if isinstance(tag, PTag):
            return tag
        elif isinstance(tag, HTag):
            name = self._schema.hash_to_name(tag.name_hash)
            if name is not None:
                if tag.ns_hash == 0:
                    return PTag(None, name)
                elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                    prefix = self.nshash_to_prefix(tag.ns_hash)
                    if prefix is not None:
                        return PTag(prefix, name)
        elif isinstance(tag, ITag):
            _ns = tag.ns
            if _ns is not None:
                prefix = self.ns_to_prefix(_ns)
                if prefix is not None:
                    return PTag(prefix, tag.name)
            elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                return PTag(None, tag.name)
        elif isinstance(tag, MTag):
            _module = tag.module
            if _module is not None:
                prefix = self.module_to_prefix(_module)
                if prefix is not None:
                    return PTag(prefix, tag.name)
            elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                return PTag(None, tag.name)
        return None

    def lookup_itag(self, tag: Tag) -> ?ITag:
        if isinstance(tag, ITag):
            return tag
        elif isinstance(tag, HTag):
            name = self._schema.hash_to_name(tag.name_hash)
            if name is not None:
                if tag.ns_hash == 0:
                    return ITag(None, name)
                elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                    ns = self.nshash_to_ns(tag.ns_hash)
                    if ns is not None:
                        return ITag(ns, name)
        elif isinstance(tag, PTag):
            _prefix = tag.prefix
            if _prefix is not None:
                ns = self.prefix_to_ns(_prefix)
                if ns is not None:
                    return ITag(ns, tag.name)
            elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                return ITag(None, tag.name)
        elif isinstance(tag, MTag):
            _module = tag.module
            if _module is not None:
                _ns = self.module_to_ns(_module)
                if _ns is not None:
                    return ITag(_ns, tag.name)
            elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                return ITag(None, tag.name)
        return None

    def lookup_htag(self, tag: Tag, inherit_ns: bool) -> ?HTag:
        if isinstance(tag, HTag):
            if inherit_ns and tag.ns_hash == 0:
                return HTag(self.node().tag.ns_hash, tag.name_hash)
            else:
                return tag
        elif isinstance(tag, PTag):
            name_hash = self._schema.name_to_hash(tag.name)
            if name_hash is not None:
                _prefix = tag.prefix
                if _prefix is not None:
                    ns_hash = self.prefix_to_nshash(_prefix)
                    if ns_hash is not None:
                        return HTag(ns_hash, name_hash)
                else:
                    return HTag(self.node().tag.ns_hash if inherit_ns else 0, name_hash)
        elif isinstance(tag, ITag):
            name_hash = self._schema.name_to_hash(tag.name)
            if name_hash is not None:
                _ns = tag.ns
                if _ns is not None:
                    ns_hash = self.ns_to_nshash(_ns)
                    if ns_hash is not None:
                        return HTag(ns_hash, name_hash)
                else:
                    return HTag(self.node().tag.ns_hash if inherit_ns else 0, name_hash)
        elif isinstance(tag, MTag):
            name_hash = self._schema.name_to_hash(tag.name)
            if name_hash is not None:
                _module = tag.module
                if _module is not None:
                    ns_hash = self.module_to_nshash(_module)
                    if ns_hash is not None:
                        return HTag(ns_hash, name_hash)
                else:
                    return HTag(self.node().tag.ns_hash if inherit_ns else 0, name_hash)
        return None

class NamespaceMaps:
    @property
    ns_to_namespace: dict[str, NamespaceDescription]
    @property
    prefix_to_namespace: dict[str, NamespaceDescription]
    @property
    module_to_namespace: dict[str, NamespaceDescription]

    def __init__(self,
                    ns_to_namespace: dict[str, NamespaceDescription],
                    prefix_to_namespace: dict[str, NamespaceDescription],
                    module_to_namespace: dict[str, NamespaceDescription]):
        self.ns_to_namespace = ns_to_namespace
        self.prefix_to_namespace = prefix_to_namespace
        self.module_to_namespace = module_to_namespace

class NamespaceDescription:
    @property
    cns: str
    @property
    ns: str
    @property
    prefix: str
    @property
    ns_hash: int
    @property
    revision: ?str
    @property
    module: str

    def __init__(self,
            cns: str,
            ns: str,
            prefix: str,
            ns_hash: int,
            revision: ?str,
            module: str):
        self.cns = cns
        self.ns = ns
        self.prefix = prefix
        self.ns_hash = ns_hash
        self.revision = revision
        self.module = module

    def __str__(self) -> str:
        return "NamespaceDescription(" \
            + self.cns + "," + self.ns + "," + self.prefix + "," + str(self.ns_hash) + "," \
            + optional_str(self.revision, "") + "," + self.module + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_tuple(elems: list[EObject]) -> ?NamespaceDescription:
        if len(elems) >= 6:
            _cns = elems[1]
            _prefix = elems[2]
            _ns_hash = elems[3]
            _revision = elems[4]
            _module = elems[5]
            # Module name seems to be considered optional by java-api but lets require it (for 'proper' yang-modules) for now!
            if isinstance(_cns, EAtom) \
                    and isinstance(_prefix, EAtom) \
                    and isinstance(_ns_hash, EInt) \
                    and isinstance(_module, EBinary):

                ns = _cns.val.split("#", 1)[-1]

                return NamespaceDescription(
                    _cns.val,
                    ns,
                    _prefix.val,
                    _ns_hash.val,
                    str(_revision) if isinstance(_revision, EBinary) else None,
                    str(_module))
        return None

class RawNode:
    @property
    node_id: int
    @property
    tag_hash: int
    @property
    ns_hash: int
    @property
    key_node_id: int
    @property
    min_occurs: int
    @property
    max_occurs: int
    @property
    conf_type: int
    @property
    type_ns_hash: int
    @property
    type_name: str
    @property
    default_value: ?value
    @property
    info_flags: int
    @property
    child_node_id: int
    @property
    next_node_id: int
    @property
    choice_ordinal: int
    @property
    metadata: dict[str, str]
    @property
    mount_id_hashes: ?(int, int) # ?tuple[int, int]

    def __init__(self,
            node_id: int,
            tag_hash: int,
            ns_hash: int,
            key_node_id: int,
            min_occurs: int,
            max_occurs: int,
            conf_type: int,
            type_ns_hash: int,
            type_name: str,
            default_value: ?value,
            info_flags: int,
            child_node_id: int,
            next_node_id: int,
            choice_ordinal: int,
            metadata: dict[str, str],
            mount_id_hashes: ?(int, int)):
        self.node_id = node_id
        self.tag_hash = tag_hash
        self.ns_hash = ns_hash
        self.key_node_id = key_node_id
        self.min_occurs = min_occurs
        self.max_occurs = max_occurs
        self.conf_type = conf_type
        self.type_ns_hash = type_ns_hash
        self.type_name = type_name
        self.default_value = default_value
        self.info_flags = info_flags
        self.child_node_id = child_node_id
        self.next_node_id = next_node_id
        self.choice_ordinal = choice_ordinal
        self.metadata = metadata
        self.mount_id_hashes = mount_id_hashes

    @staticmethod
    def from_ns_tuple(elems: list[EObject]) -> ?RawNode:
        if len(elems) >= 18:
            _node_id = elems[1]
            _tag_hash = elems[2]
            _ns_hash = elems[3]
            _key_node_id = elems[4]
            _min_occurs = elems[5]
            _max_occurs = elems[6] # Seems bugged, e.g. reported as (1) for lists without max-elements.
            _conf_type = elems[7]
            _type_ns_hash = elems[8]
            _type_name = elems[9]
            _default_value = elems[10]
            _info_flags = elems[11]
            _child_node_id = elems[12]
            _next_node_id = elems[13]
            _choice_ordinal = elems[14]
            _metadata = elems[16]
            _mount_id = elems[17]

            if isinstance(_node_id, EInt) \
                    and isinstance(_tag_hash, EInt) \
                    and isinstance(_ns_hash, EInt) \
                    and isinstance(_key_node_id, EInt) \
                    and isinstance(_min_occurs, EInt) \
                    and isinstance(_max_occurs, EInt) \
                    and isinstance(_conf_type, EInt) \
                    and isinstance(_type_ns_hash, EInt) \
                    and isinstance(_type_name, EAtom) \
                    and isinstance(_info_flags, EInt) \
                    and isinstance(_child_node_id, EInt) \
                    and isinstance(_next_node_id, EInt) \
                    and isinstance(_choice_ordinal, EInt) \
                    and isinstance(_metadata, EList):

                metadata: dict[str, str] = {}
                for e in _metadata.elems:
                    if isinstance(e, ETuple):
                        if len(e.elems) == 2:
                            _key = e.elems[0]
                            _val = e.elems[1]
                            metadata[str(_key)] = str(_val)

                mount_id: ?(int, int) = None
                if isinstance(_mount_id, ETuple):
                    _elems = _mount_id.elems
                    if len(_elems) == 2:
                        _mount_id_ns_hash = _elems[0]
                        _mount_id_name_hash = _elems[1]
                        if isinstance(_mount_id_ns_hash, EInt) and isinstance(_mount_id_name_hash, EInt):
                            mount_id = (_mount_id_ns_hash.val, _mount_id_name_hash.val)

                return RawNode(
                    _node_id.val,
                    _tag_hash.val,
                    _ns_hash.val,
                    _key_node_id.val,
                    _min_occurs.val,
                    _max_occurs.val,
                    _conf_type.val,
                    _type_ns_hash.val,
                    _type_name.val,
                    _default_value,
                    _info_flags.val,
                    _child_node_id.val,
                    _next_node_id.val,
                    _choice_ordinal.val,
                    metadata,
                    mount_id)

        return None

class RawKeys:
    @property
    node_id: int
    @property
    key_hashes: list[int]

    def __init__(self, node_id: int, key_hashes: list[int]):
        self.node_id = node_id
        self.key_hashes = key_hashes

    @staticmethod
    def from_ns_tuple(elems: list[EObject]) -> ?RawKeys:
        if len(elems) >= 3:
            _node_id = elems[1]
            _key_hashes = elems[2]

            if isinstance(_node_id, EInt) and isinstance(_key_hashes, EList):
                keys: list[int] = []
                for e in _key_hashes.elems:
                    if isinstance(e, EInt):
                        keys.append(e.val)
                return RawKeys(_node_id.val, keys)

class Node(object):
    # @property:
    # node_type: int
    @property
    tag: HTag
    @property
    min_occurs: int
    @property
    max_occurs: int
    @property
    flags: i64
    @property
    conf_type: int
    @property
    value_type: ?Type
    @property
    keys: list[Node]
    @property
    children: dict[HTag, Node]

    def __init__(self, tag: HTag, min_occurs: int, max_occurs: int, flags: i64, conf_type: int, value_type: ?Type, keys: list[Node], children: dict[HTag, Node]):
        self.tag = tag
        self.min_occurs = min_occurs
        self.max_occurs = max_occurs
        self.flags = flags
        self.conf_type = conf_type
        self.value_type = value_type
        self.keys = keys
        self.children = children

        # self.node_type = 0
        # if self.is_np_container():
        #     self.node_type = NODE_NP_CONTAINER
        # if self.is_p_container():
        #     self.node_type = NODE_P_CONTAINER
        # if self.is_list():
        #     self.node_type = NODE_LIST
        # if self.is_empty_leaf():
        #     self.node_type = NODE_EMPTY_LEAF
        # if self.is_non_empty_leaf():
        #     self.node_type = NODE_NON_EMPTY_LEAF
        # if self.is_leaf_list():
        #     self.node_type = NODE_LEAF_LIST

    def is_container(self) -> bool:
        return self.flags & CS_NODE_IS_CONTAINER != 0

    def is_np_container(self) -> bool:
        return self.is_container() and self.min_occurs == 1

    def is_p_container(self) -> bool:
        return self.is_container() and self.min_occurs == 0

    def is_list(self) -> bool:
        return self.flags & CS_NODE_IS_LIST != 0

    def is_leaf(self) -> bool:
        # return self.value_type is not None
        # return not self.children and self.flags & (
        return len(self.children) <= 0 and self.flags & (
                CS_NODE_IS_CONTAINER |
                CS_NODE_IS_LIST |
                CS_NODE_IS_ACTION |
                CS_NODE_IS_NOTIF |
                CS_NODE_IS_LEAF_LIST) == 0

    def is_action(self) -> bool:
        return self.flags & CS_NODE_IS_ACTION != 0

    def is_empty_leaf(self) -> bool:
        return self.is_leaf() and self.conf_type == C_XMLTAG

    def is_non_empty_leaf(self) -> bool:
        return self.is_leaf() and self.conf_type != C_XMLTAG

    def is_leaf_list(self) -> bool:
        return self.flags & CS_NODE_IS_LEAF_LIST != 0

    def is_oper(self) -> bool:
        return self.flags & CS_NODE_IS_WRITE == 0

    def is_mount_point(self) -> bool:
        return self.flags & CS_NODE_HAS_MOUNT_POINT != 0

    # def get_namespace(self) -> bool, schema: Schema) -> NamespaceDescription:
    #     ...

    # def get_name(self) -> bool, schema: Schema) -> str:
    #     ...

class Type(object):
    @property
    type_id: TypeId
    @property
    parent_type: ?Type
    @property
    conf_type: ?int
    # @property
    # derivation: str

    def __init__(self, type_id: TypeId, parent_type: ?Type, conf_type: ?int):
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = conf_type

    def __str__(self) -> str:
        return "Type(" + self.__str_common() + ")"

    def __repr__(self):
        return self.__str__()

    def __str_common(self) -> str:
        parent_type_id = "None"
        _parent_type = self.parent_type
        if _parent_type is not None:
            parent_type_id = str(_parent_type.type_id)
        return str(self.type_id) + ", " + parent_type_id \
            + ", " + optional_str(self.conf_type, "None")

    @staticmethod
    def builtin_types() -> dict[TypeId, Type]:
        types: dict[TypeId, Type] = {}
        def append(t: Type) -> None:
            types[t.type_id] = t

        append(Type(TypeId(0, "int8"), None, C_INT8))
        append(Type(TypeId(0, "int16"), None, C_INT16))
        append(Type(TypeId(0, "int32"), None, C_INT32))
        append(Type(TypeId(0, "int64"), None, C_INT64))
        append(Type(TypeId(0, "uint8"), None, C_INT8))
        append(Type(TypeId(0, "uint16"), None, C_UINT16))
        append(Type(TypeId(0, "uint32"), None, C_UINT32))
        append(Type(TypeId(0, "uint64"), None, C_UINT64))
        append(Type(TypeId(0, "string"), None, C_BUF))
        append(Type(TypeId(0, "boolean"), None, C_BOOL))
        append(Type(TypeId(0, "hex-list"), None, C_BINARY)) # Not enabled in ConfD/NCS
        append(Type(TypeId(0, "hexList"), None, C_BINARY)) # Not enabled in ConfD/NCS
        append(Type(TypeId(0, "octet-list"), None, C_BINARY)) # TODO: E.g. \d+\(.\d+)
        append(Type(TypeId(0, "octetList"), None, C_BINARY)) # TODO: E.g. \d+\(.\d+)
        append(Type(TypeId(0, "md5-digest-string"), None, C_BUF))
        append(Type(TypeId(0, "des3-cbc-encrypted-string"), None, C_BUF))
        append(Type(TypeId(0, "aes-cfb-128-encrypted-string"), None, C_BUF))
        append(Type(TypeId(0, "aes-256-cfb-128-encrypted-string"), None, C_BUF))
        append(Type(TypeId(0, "inetAddressIPv4"), None, C_IPV4))
        append(Type(TypeId(0, "inetAddressIPv6"), None, C_IPV6))
        append(Type(TypeId(0, "Counter32"), None, C_UINT32))
        append(Type(TypeId(0, "Counter64"), None, C_UINT64))
        append(Type(TypeId(0, "Gauge32"), None, C_UINT32))
        append(Type(TypeId(0, "inetPortNumber"), None, C_UINT16))
        append(Type(TypeId(0, "inetAddressDNS"), None, C_BUF))
        append(Type(TypeId(0, "oid"), None, C_OID)) # TODO: First identified must be 0,1,2)
        append(UnionType(TypeId(0, "inetAddressIP"), None, [types[TypeId(0, "inetAddressIPv4")], types[TypeId(0, "inetAddressIPv6")]]))
        append(UnionType(TypeId(0, "inetAddress"), None, [types[TypeId(0, "inetAddressIP")], types[TypeId(0, "inetAddressDNS")]]))
        append(Type(TypeId(0, "ipv4Prefix"), None, C_IPV4PREFIX))
        append(Type(TypeId(0, "ipv6Prefix"), None, C_IPV6PREFIX))
        append(UnionType(TypeId(0, "ipPrefix"), None, [types[TypeId(0, "ipv4Prefix")], types[TypeId(0, "ipv6Prefix")]]))
        append(Type(TypeId(0, "size"), None, C_UINT64)) # TODO: with 2^10^x prefixes G,M,K,B
        append(Type(TypeId(0, "MD5DigestString"), None, C_BUF))
        append(Type(TypeId(0, "SHA256DigestString"), None, C_BUF))
        append(Type(TypeId(0, "SHA512DigestString"), None, C_BUF))
        append(Type(TypeId(0, "cryptHash"), None, C_BUF))
        append(Type(TypeId(0, "DES3CBCIVEncryptedString"), None, C_BUF))
        append(Type(TypeId(0, "AESCFB128IVEncryptedString"), None, C_BUF))
        append(Type(TypeId(0, "AES256CFB128IVEncryptedString"), None, C_BUF))
        append(Type(TypeId(0, "byte"), None, C_INT8))
        append(Type(TypeId(0, "short"), None, C_INT16))
        append(Type(TypeId(0, "int"), None, C_INT32))
        append(Type(TypeId(0, "long"), None, C_INT64))
        append(Type(TypeId(0, "unsignedByte"), None, C_INT8))
        append(Type(TypeId(0, "unsignedShort"), None, C_INT16))
        append(Type(TypeId(0, "unsignedInt"), None, C_INT32))
        append(Type(TypeId(0, "unsignedLong"), None, C_INT64))
        append(Type(TypeId(0, "double"), None, C_DOUBLE))
        append(Type(TypeId(0, "objectRef"), None, C_INSTANCE_IDENTIFIER))
        append(Type(TypeId(0, "identityref"), None, C_IDENTITYREF))
        append(Type(TypeId(0, "dateTime"), None, C_DATETIME))
        append(Type(TypeId(0, "date"), None, C_DATE))
        append(Type(TypeId(0, "time"), None, C_TIME))
        append(Type(TypeId(0, "duration"), None, C_DURATION))
        append(Type(TypeId(0, "decimal"), None, C_DOUBLE))
        append(Type(TypeId(0, "integer"), None, C_INT64))
        append(Type(TypeId(0, "float"), None, C_DOUBLE))
        append(Type(TypeId(0, "hexBinary"), None, C_BINARY))
        append(Type(TypeId(0, "binary"), None, C_BINARY)) # TODO: base64
        append(Type(TypeId(0, "base64Binary"), None, C_BINARY)) # TODO: base64
        append(RestrictedNumberType(TypeId(0, "nonNegativeInteger"), None, C_UINT64, [TypeRange(0, None, CONFD_RANGE_MIN_INCLUSIVE | CONFD_RANGE_MAX_INCLUSIVE)]))
        append(RestrictedNumberType(TypeId(0, "nonPositiveInteger"), None, C_INT64, [TypeRange(None, 0, CONFD_RANGE_MIN_INCLUSIVE | CONFD_RANGE_MAX_INCLUSIVE)]))
        append(RestrictedNumberType(TypeId(0, "negativeInteger"), None, C_INT64, [TypeRange(None, -1, CONFD_RANGE_MIN_INCLUSIVE | CONFD_RANGE_MAX_INCLUSIVE)]))
        append(RestrictedNumberType(TypeId(0, "positiveInteger"), None, C_UINT64, [TypeRange(1, None, CONFD_RANGE_MIN_INCLUSIVE | CONFD_RANGE_MAX_INCLUSIVE)]))
        append(Type(TypeId(0, "normalizedString"), None, C_BUF)) # TODO: Replace whitespace with space e.g. ' '
        append(Type(TypeId(0, "token"), None, C_BUF)) # TODO: Replace any consecutive whitespace with single space e.g. ' '
        append(Type(TypeId(0, "NOTATION"), None, C_BUF)) # TODO: Replace any consecutive whitespace with single space e.g. ' '
        append(Type(TypeId(0, "language"), None, C_BUF)) # TODO: [a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*
        append(Type(TypeId(0, "NMTOKEN"), None, C_BUF)) # TODO: [A-Za-z0-9._:-]+
        append(Type(TypeId(0, "Name"), None, C_BUF)) # TODO: [A-Za-z_:][A-Za-z0-9._:-]*
        append(Type(TypeId(0, "NCName"), None, C_BUF)) # TODO: [^:]*
        append(Type(TypeId(0, "ID"), None, C_BUF)) # TODO: [^:]*
        append(Type(TypeId(0, "IDREF"), None, C_BUF)) # TODO: [^:]*
        append(Type(TypeId(0, "ENTITY"), None, C_BUF)) # TODO: [^:]*
        append(ListType(TypeId(0, "NMTOKEN-LIST"), None, types[TypeId(0, "NMTOKEN")]))
        append(ListRestrictionType(TypeId(0, "NMTOKENS"), types[TypeId(0, "NMTOKEN")], [TypeRange(1, None, 0)]))
        append(ListType(TypeId(0, "IDREF-LIST"), None, types[TypeId(0, "NCName")]))
        append(ListRestrictionType(TypeId(0, "IDREFS"), types[TypeId(0, "NCName")], [TypeRange(1, None, 0)]))
        append(ListRestrictionType(TypeId(0, "ENTITIES"), types[TypeId(0, "NCName")], [TypeRange(1, None, 0)]))
        append(Type(TypeId(0, "dottedQuad"), None, C_DQUAD))
        append(Type(TypeId(0, "hexString"), None, C_HEXSTR))
        append(Type(TypeId(0, "ipv4AddressAndPrefixLength"), None, C_IPV4_AND_PLEN))
        append(Type(TypeId(0, "ipv6AddressAndPrefixLength"), None, C_IPV6_AND_PLEN))
        append(UnionType(TypeId(0, "ipAddressAndPrefixLength"), None, [types[TypeId(0, "ipv4AddressAndPrefixLength")], types[TypeId(0, "ipv6AddressAndPrefixLength")]]))

        return types

    @staticmethod
    def unknown_type() -> Type:
        # TODO: Workaround compiler constraints to return a shared constant?
        return Type(EMPTY_TYPE_ID, None, C_UNKNOWN)

    @staticmethod
    def from_ns_tuple(elems: list[EObject], ns_descr: NamespaceDescription, pending_type_resolves: list[(TypeId, mut(Type) -> None)]) -> ?Type:
        if len(elems) >= 6:
            _derivation = elems[1]
            _name = elems[2]
            _parent_ns_hash = elems[3]
            _parent_name = elems[4]
            _opaque = elems[5]
            if isinstance(_derivation, EAtom) \
                    and isinstance(_name, EAtom) \
                    and isinstance(_parent_ns_hash, EInt) \
                    and isinstance(_parent_name, EAtom) \
                    and isinstance(_opaque, EObject):

                derivation = str(_derivation)
                type_id = TypeId(ns_descr.ns_hash, str(_name))

                parent_type_id = TypeId(_parent_ns_hash.val, str(_parent_name))

                result_type: ?Type = None

                if derivation == "none":
                    result_type = Type(type_id, None, None)
                elif derivation == "enum":
                    result_type = EnumType.from_ns_opaque(type_id, None, _opaque)
                elif derivation == "idref":
                    result_type = IdentityType.from_ns_opaque(type_id, None, _opaque)
                elif derivation == "bits":
                    result_type = BitsType.from_ns_opaque(type_id, None, _opaque)
                elif derivation == "decimal64":
                    result_type = Decimal64Type.from_ns_opaque(type_id, None, _opaque)
                elif derivation == "union":
                    result_type = UnionType.from_ns_opaque(type_id, None, _opaque, pending_type_resolves)
                elif derivation == "list":
                    result_type = ListType.from_ns_opaque(type_id, None, _opaque, pending_type_resolves)
                elif derivation == "number":
                    result_type = RestrictedNumberType.from_ns_opaque(type_id, None, _opaque)
                elif derivation == "string":
                    result_type = StringType.from_ns_opaque(type_id, None, _opaque)
                elif derivation == "list_restr":
                    result_type = ListRestrictionType.from_ns_opaque(type_id, None, _opaque)
                elif derivation == "display_hint":
                    result_type = DisplayHintType.from_ns_opaque(type_id, None, _opaque)
                elif derivation == "identity":
                    result_type = Type(type_id, None, None)
                else:
                    result_type = Type(type_id, None, None)

                if result_type is not None and parent_type_id != EMPTY_TYPE_ID:
                    def _resolve_cb(t: Type) -> None:
                        result_type.parent_type = t
                    pending_type_resolves.append((parent_type_id, _resolve_cb))

                return result_type

        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        retval = None
        parent = self.parent_type
        if parent is not None:
            retval = parent.netconf_to_value(s, cursor, prefix_to_ns)
        if retval is None:
            _conf_type = self.conf_type
            if _conf_type is not None:
                retval = Any.netconf_to_value(s, _conf_type, cursor, prefix_to_ns)
            if retval is None:
                shallow_type = cursor.node().conf_type
                # if shallow_type != _conf_type:
                # Workaround actonc error:
                # ld.lld: error: undefined symbol: $EqOptG_new
                if not eq_optional(shallow_type, _conf_type):
                    retval = Any.netconf_to_value(s, shallow_type, cursor, prefix_to_ns)
        return retval

    def value_to_netconf(self, v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str]):
        retval = None
        parent = self.parent_type
        if parent is not None:
            retval = parent.value_to_netconf(v, cursor)
        if retval is None:
            retval = Any.value_to_netconf(v, cursor)
        return retval

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        retval = None
        parent = self.parent_type
        if parent is not None:
            retval = parent.value_to_eobject(v, cursor, use_ikp)
        if retval is None:
            retval = Any.value_to_eobject(v, cursor, use_ikp)
        return retval

    def eobject_to_conf_type_and_value(self, obj: ?EObject, cursor: Cursor) -> (int, ?value):
        return Any.eobject_to_conf_type_and_base_value(obj)

    # def netconf_to_eobject(self, node: Node, s: str) -> ?EObject:
    #     return netvalue_to_eobject(netconf_to_value(node, s))

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        return False # TODO

class EnumType(Type):
    @property
    name_to_ordinal: dict[str, int]
    @property
    ordinal_to_name: dict[int, str]

    def __init__(self, type_id: TypeId, parent_type: ?Type, name_to_ordinal: dict[str, int]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = C_ENUM_VALUE
        self.name_to_ordinal = name_to_ordinal
        _ordinal_to_name = {}
        for name, ordinal in name_to_ordinal.items():
            _ordinal_to_name[ordinal] = name
        self.ordinal_to_name = _ordinal_to_name

    def __str__(self) -> str:
        return "EnumType(" + self.__str_common() + ", " + str(self.name_to_ordinal) + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        if isinstance(opaque, EList):
            name_to_ordinal: dict[str, int] = {}
            for _elem in list_reversed(opaque.elems):
                if isinstance(_elem, ETuple):
                    _pair = _elem.elems
                    if len(_pair) == 2:
                        _ename = _pair[0]
                        _ordinal = _pair[1]
                        if isinstance(_ename, EBinary) and isinstance(_ordinal, EInt):
                            name_to_ordinal[str(_ename)] = _ordinal.val
            return EnumType(type_id, parent_type, name_to_ordinal)
        return None

    def value_to_netconf(self, v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str]):
        if v is not None:
            if isinstance(v, str):
                return v
            elif isinstance(v, int):
                return try_get(self.ordinal_to_name, v)
        return None

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        if v is not None:
            if isinstance(v, str):
                ordinal = try_get(self.name_to_ordinal, v)
                if ordinal is not None:
                    return ETuple([EInt(C_ENUM_VALUE), EInt(ordinal)])
            elif isinstance(v, int):
                return ETuple([EInt(C_ENUM_VALUE), EInt(v)])
        return None

    def eobject_to_conf_type_and_value(self, obj: ?EObject, cursor: Cursor) -> (int, ?value):
        # if obj is not None and isinstance(obj, ETuple): # actonc: #### findAttr' fails for telemetrify.nsoapi.proto.EObject . elems
        #     _elems = obj.elems
        if obj is not None:
            _obj: EObject = obj
            if isinstance(_obj, ETuple):
                _elems = _obj.elems
                if len(_elems) == 2:
                    _conf_type = _elems[0]
                    _ordinal = _elems[1]
                    if isinstance(_conf_type, EInt) and _conf_type.val == C_ENUM_VALUE and isinstance(_ordinal, EInt):
                        ordinal = _ordinal.val
                        name = try_get(self.ordinal_to_name, ordinal)
                        return (C_ENUM_VALUE, name if name is not None else ordinal)
        return (C_UNKNOWN, None)

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        if v is not None:
            if isinstance(v, str):
                return v in self.name_to_ordinal
            elif isinstance(v, int):
                return v in self.ordinal_to_name
        return False

class UnionType(Type):
    @property
    types: list[Type]

    def __init__(self, type_id: TypeId, parent_type: ?Type, types: list[Type]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.types = types

    def __str__(self) -> str:
        return "UnionType(" + self.__str_common() + ", " + list_str(self.types) + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject, pending_type_resolves: list[(TypeId, mut(Type) -> None)]) -> ?Type:
        if isinstance(opaque, EList):
            utypes = []
            for _elem in list_reversed(opaque.elems):
                if isinstance(_elem, ETuple):
                    _elems = _elem.elems
                    if len(_elems) == 2:
                        _ns_hash = _elems[0]
                        _name = _elems[1]
                        if isinstance(_ns_hash, EInt) and isinstance(_name, EAtom):
                            utype_id = TypeId(_ns_hash.val, str(_name))
                            def _resolve_cb(t: Type):
                                utypes.append(t)
                            pending_type_resolves.append((utype_id, _resolve_cb))
            return UnionType(type_id, parent_type, utypes)
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        for t in self.types:
            res = t.netconf_to_value(s, cursor, prefix_to_ns)
            if res is not None:
                return res
        return None

    def value_to_netconf(self, v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str]):
        for t in self.types:
            res = t.value_to_netconf(v, cursor)
            if res is not None:
                return res
        return None

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        for t in self.types:
            res = t.value_to_eobject(v, cursor, use_ikp)
            if res is not None:
                return res
        return None

    def eobject_to_conf_type_and_value(self, obj: ?EObject, cursor: Cursor) -> (int, ?value):
        for t in self.types:
            _conf_type, _value = t.eobject_to_conf_type_and_value(obj, cursor)
            if _value is not None:
                return (_conf_type, _value)
        return (C_UNKNOWN, None)

class RestrictedNumberType(Type):
    @property
    ranges: list[TypeRange]

    def __init__(self, type_id: TypeId, parent_type: ?Type, conf_type: ?int, ranges: list[TypeRange]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = conf_type
        self.ranges = ranges

    def __str__(self) -> str:
        return "RestrictedNumberType(" + self.__str_common() + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        # TODO
        return RestrictedNumberType(type_id, parent_type, None, [])

class BitsType(Type):
    @property
    pos_to_name: dict[int, str]
    @property
    name_to_pos: dict[str, int]

    def __init__(self, type_id: TypeId, parent_type: ?Type, conf_type: ?int, pos_to_name: dict[int, str]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = conf_type
        self.pos_to_name = pos_to_name
        _name_to_pos: dict[str, int] = {}
        for pos, name in pos_to_name.items():
            _name_to_pos[name] = pos
        self.name_to_pos = _name_to_pos

    def __str__(self) -> str:
        return "BitsType(" + self.__str_common() + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        if isinstance(opaque, ETuple) and len(opaque.elems) == 2:
            elems = opaque.elems
            _width = elems[0]
            _bits = elems[1]
            if isinstance(_width, EInt) and isinstance(_bits, EList):
                width = _width.val
                _conf_type = C_BITBIG
                if width <= 32:
                    _conf_type = C_BIT32
                elif width <= 64:
                    _conf_type = C_BIT64
                _pos_to_name: dict[int, str] = {}
                for _bit_elem in _bits.elems:
                    if isinstance(_bit_elem, ETuple) and len(_bit_elem.elems) == 2:
                        _elems = _bit_elem.elems
                        _bit_name = _elems[0]
                        _bit_pos = _elems[1]
                        if isinstance(_bit_name, EBinary) and isinstance(_bit_pos, EInt):
                            bit_name = str(_bit_name)
                            bit_pos = _bit_pos.val
                            _pos_to_name[bit_pos] = bit_name
                return BitsType(type_id, parent_type, _conf_type, _pos_to_name)
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        p = s.split(" ", -1)
        # mask: int = 0
        # BUG: Runtime error on bitwise operations
        # for bit_name in p:
        #     bit_pos = try_get(self.name_to_pos, bit_name)
        #     if bit_pos is not None:
        #         mask |= 1 << bit_pos # BUG: Runtime error on bitwise operations
        #     else:
        #         return False
        # for bit_name in set(p):
        #     bit_pos = try_get(self.name_to_pos, bit_name)
        #     if bit_pos is not None:
        #         mask += 2**bit_pos
        #     else:
        #         return False
        # return mask
        v: set[str] = set(p)
        return v

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        if v is not None:
            # if isinstance(v, set[str]):
            if isinstance(v, set):
                mask: int = 0
                # BUG: Runtime error on bitwise operations
                # for bit_name in v:
                #     bit_pos = try_get(self.name_to_pos, bit_name)
                #     if bit_pos is not None:
                #         mask |= 1 << bit_pos # BUG: Runtime error on bitwise operations
                #     else:
                #         return None
                for bit_name in v:
                    if isinstance(bit_name, str):
                        bit_pos = try_get(self.name_to_pos, bit_name)
                        if bit_pos is not None:
                            mask += 2**bit_pos
                        elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                            return None
                    elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                        return None
                _conf_type = self.conf_type
                if _conf_type is not None:
                    if _conf_type == C_BIT32 or _conf_type == C_BIT64:
                        return ETuple([EInt(_conf_type), EInt(mask)])
                    elif _conf_type == C_BITBIG:
                        return ETuple([EInt(_conf_type), EBinary(uint_to_bytes_le(mask))])
                    elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                        return None
                elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                    return None
        return None

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        # if v is not None and isinstance(v, Iterable):
        #     for bit_name in v:
        #         if bit_name not in self.name_to_pos:
        #             return False
        #     return True
        if v is not None:
            if isinstance(v, set):
                for bit_name in v:
                    if bit_name not in self.name_to_pos:
                        return False
                return True
            elif isinstance(v, list):
                for bit_name in v:
                    if bit_name not in self.name_to_pos:
                        return False
                return True
        return False

class Decimal64Type(Type):
    @property
    fraction_digits: int
    @property
    ranges: list[TypeRange]

    def __init__(self, type_id: TypeId, parent_type: ?Type, fraction_digits: int, ranges: list[TypeRange]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = C_DECIMAL64
        self.fraction_digits = fraction_digits
        self.ranges = ranges

    def __str__(self) -> str:
        return "Decimal64Type(" + self.__str_common() + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        if isinstance(opaque, ETuple) and len(opaque.elems) == 2:
            elems = opaque.elems
            _fraction_digits = elems[0]
            _ranges = elems[1]
            if isinstance(_fraction_digits, EInt) and isinstance(_ranges, EList):
                return Decimal64Type(type_id, parent_type, _fraction_digits.val, []) # TODO: ranges
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        d: ?Decimal64 = Decimal64.try_parse(s.strip(" \t\r\n"))
        return d.try_lossless_realign(-self.fraction_digits) if d is not None else None

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        # TODO
        return False

class ListType(Type):
    @property
    elem_type: Type

    def __init__(self, type_id: TypeId, parent_type: ?Type, elem_type: Type):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = None
        self.elem_type = elem_type

    def __str__(self) -> str:
        return "ListType(" + self.__str_common() + ", " + str(self.elem_type) + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject, pending_type_resolves: list[(TypeId, mut(Type) -> None)]) -> ?Type:
        if isinstance(opaque, ETuple) and len(opaque.elems) == 2:
            elems = opaque.elems
            _ns_hash = elems[0]
            _name = elems[1]
            if isinstance(_ns_hash, EInt) and isinstance(_name, EAtom):
                result_type = ListType(type_id, parent_type, Type.unknown_type())

                elem_type_id = TypeId(_ns_hash.val, str(_name))
                def _resolve_cb(t: Type) -> None:
                    result_type.elem_type = t
                pending_type_resolves.append((elem_type_id, _resolve_cb))

                return result_type
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        # Not really viable to parse multiple elements of any type ('string'-type in particular)
        # hence here we only allow single value
        return self.elem_type.netconf_to_value(s, cursor, prefix_to_ns)

    def value_to_netconf(self, v: ?value, cursor: Cursor) -> ?value:
        if v is not None and isinstance(v, list):
            res: list[str] = []
            for elem_v in v:
                elem_str = self.elem_type.value_to_netconf(elem_v, cursor)
                if elem_str is not None and isinstance(elem_str, str):
                    res.append(elem_str)
                else:
                    return None
            return res
        return None

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        # if v is not None and isinstance(v, Iterable):
        #     elems = []
        #     for o in v:
        #         eo = self.elem_type.value_to_eobject(o, cursor, use_ikp)
        #         if eo is not None:
        #             elems.append(eo)
        #         else:
        #             return None
        #     return EList(elems, True)
        if v is not None:
            if isinstance(v, set):
                elems: list[EObject] = []
                _elem_type: Type = self.elem_type
                for o in v:
                    eo: ?EObject = _elem_type.value_to_eobject(o, cursor, use_ikp)
                    if eo is not None:
                        elems.append(eo)
                    else:
                        return None
                return EList(elems, True)
            elif isinstance(v, list):
                elems: list[EObject] = []
                _elem_type: Type = self.elem_type
                for o in v:
                    eo: ?EObject = _elem_type.value_to_eobject(o, cursor, use_ikp)
                    if eo is not None:
                        elems.append(eo)
                    else:
                        return None
                return EList(elems, True)
        return None

class ListRestrictionType(Type):
    @property
    ranges: list[TypeRange]

    def __init__(self, type_id: TypeId, parent_type: ?Type, ranges: list[TypeRange]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = None
        self.ranges = ranges

    def __str__(self) -> str:
        return "ListRestrictionType(" + self.__str_common() + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        # TODO
        return ListRestrictionType(type_id, parent_type, [])

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        # TODO
        return False

class DisplayHintType(Type):
    def __init__(self, type_id: TypeId, parent_type: ?Type):
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = None

    def __str__(self) -> str:
        return "DisplayHintType(" + self.__str_common() + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        # TODO
        return DisplayHintType(type_id, parent_type)

class StringType(Type):
    @property
    ranges: list[TypeRange]
    @property
    pattern: ?value # TODO: regex

    def __init__(self, type_id: TypeId, parent_type: ?Type, ranges: list[TypeRange], regex: ?value):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = None
        self.ranges = ranges
        self.pattern = None

    def __str__(self) -> str:
        return "StringType(" + self.__str_common() + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        # TODO
        return StringType(type_id, parent_type, [], None)

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        # TODO
        return False

class IdentityType(Type):
    @property
    identities: set[HTag]

    def __init__(self, type_id: TypeId, parent_type: ?Type, identities: set[HTag]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = C_IDENTITYREF
        self.identities = identities

    def __str__(self) -> str:
        return "IdentityType(" + self.__str_common() + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        if isinstance(opaque, EList):
            identities: set[HTag] = set([])
            for _elem in list_reversed(opaque.elems):
                if isinstance(_elem, ETuple):
                    _elems = _elem.elems
                    if len(_elems) == 3:
                        _qname = _elems[0]
                        _ns_hash = _elems[1]
                        _name_hash = _elems[2]
                        if isinstance(_qname, EAtom) and isinstance(_ns_hash, EInt) and isinstance(_name_hash, EInt):
                            # Won't really need _qname for now
                            identities.add(HTag(_ns_hash.val, _name_hash.val))
            return IdentityType(type_id, parent_type, identities)
        return None

    # def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
    #     v = Type.netconf_to_value(self, s, cursor, prefix_to_ns)
    #     if self.validate_value(cursor, v):
    #         return v
    #     return None

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        if v is not None and isinstance(v, Tag):
            htag = cursor.lookup_htag(v, False)
            if htag is not None:
                return htag in self.identities
        return False

class TypeRange:
    def __init__(self, lo: ?value, hi: ?value, flags: i64):
        self.lo = lo
        self.hi = hi
        self.flags = flags

actor SchemaBuilder(log_handler: ?logging.Handler):
    var logh = logging.Handler("schema-builder")
    if log_handler is not None:
        logh.set_handler(log_handler)
    var log = logging.Logger(logh)

    var raw_roots: set[int] = set([])
    var raw_nodes: dict[int, RawNode] = {}
    var raw_keys: dict[int, RawKeys] = {}
    var curr_ns: NamespaceDescription = NamespaceDescription("", "", "", 0, "", "")
    var curr_mount_id: HTag = ROOT_MOUNT_ID

    var pending_type_resolves: list[(TypeId, mut(Type) -> None)] = []

    var hash_to_name: dict[int, str] = {}
    var name_to_hash: dict[str, int] = {}
    var namespaces: dict[int, NamespaceDescription] = {}
    var mount_id_namespaces: dict[HTag, list[NamespaceDescription]] = {}
    var roots: dict[HTag, Node] = {}
    var types: dict[TypeId, Type] = Type.builtin_types()

    def on_ns_term(term: EObject) -> value:
        return _for_schema_lists(term, _on_ns_elem)

    def on_hash_term(term: EObject) -> value:
        return _for_schema_lists(term, _on_hash_elem)

    def on_mns_term(term: EObject) -> value:
        return _for_schema_lists(term, _on_mns_elem)

    def _for_schema_lists(term: EObject, on_elem: proc(EObject) -> None) -> value:
        if isinstance(term, EList):
            for e in term.elems:
                #log.trace(e)
                if isinstance(e, EAtom) and str(e) == 'eof':
                    return False
                on_elem(e)
            return True
        else:
            return MaapiProtoError("Unexpected schema term")
        return True

    def _on_ns_elem(elem: EObject) -> None:
        if isinstance(elem, ETuple):
            t = elem.elems
            if len(t) >= 1:
                _etype = t[0]
                if isinstance(_etype, EAtom):
                    etype = _etype.val
                    if etype == 'ns':
                        ns_descr = NamespaceDescription.from_ns_tuple(t)
                        if ns_descr is not None:
                            namespaces[ns_descr.ns_hash] = ns_descr
                            curr_ns = ns_descr
                            return
                    elif etype == 'type':
                        #log.trace(elem)
                        type_descr = Type.from_ns_tuple(t, curr_ns, pending_type_resolves)
                        if type_descr is not None:
                            if type_descr.type_id not in types:
                                types[type_descr.type_id] = type_descr
                            else:
                                log.warning("WARNING: Discarding duplicate type_id", {"type_id": type_descr.type_id})
                            return
                    elif etype == 'keys':
                        keys = RawKeys.from_ns_tuple(t)
                        if keys is not None:
                            raw_keys[keys.node_id] = keys
                            return
                    elif etype == 'node':
                        node = RawNode.from_ns_tuple(t)
                        if node is not None:
                            raw_nodes[node.node_id] = node
                            return
                    elif etype == 'case':
                        return
                    elif etype == 'choice':
                        return
                    elif etype == 'root' and len(t) == 2:
                        _node_id = t[1]
                        if isinstance(_node_id, EInt):
                            node_id = _node_id.val
                            raw_roots.add(node_id)
                            return
                    elif etype == 'parent':
                        _assemble_node_trees()
                        return
        log.warning("Unexpected schema ns elem", {"elem": elem})

    def _on_hash_elem(elem: EObject) -> None:
        #log.trace(elem)
        if isinstance(elem, ETuple):
            t = elem.elems
            if len(t) == 2:
                name = t[0]
                hash_nr = t[1]
                if isinstance(hash_nr, EInt):
                    if isinstance(name, EAtom):
                        hash_to_name[hash_nr.val] = name.val
                        name_to_hash[name.val] = hash_nr.val
                        return
        log.warning("Unexpected schema hash_db elem", {"elem": elem})

    def _on_mns_elem(elem: EObject) -> None:
        if isinstance(elem, ETuple):
            t = elem.elems
            if len(t) >= 1:
                _etype = t[0]
                if isinstance(_etype, EAtom):
                    etype = _etype.val
                    if etype == 'mount_id' and len(t) == 2:
                        _mount_id = t[1]
                        if isinstance(_mount_id, ETuple):
                            _elems = _mount_id.elems
                            if len(_elems) == 2:
                                _ns_hash = _elems[0]
                                _name_hash = _elems[1]
                                if isinstance(_ns_hash, EInt) and isinstance(_name_hash, EInt):
                                    # ns = hash_to_name.get(_ns_hash.val, "")
                                    # name = hash_to_name.get(_name_hash.val, "")
                                    # if ns and name:
                                    #     log.trace("-- mount_id", ns + ":" + name)
                                    curr_mount_id = HTag(_ns_hash.val, _name_hash.val)
                                    return
                        elif isinstance(_mount_id, EList) and len(_mount_id.elems) == 0:
                            curr_mount_id = ROOT_MOUNT_ID
                            return
                elif isinstance(_etype, ETuple) and len(_etype.elems) == 2 and len(t) >= 2:
                    a_elems = _etype.elems
                    _netype = a_elems[0]
                    _cns = a_elems[1]
                    _b_elems = t[1]
                    if isinstance(_netype, EAtom) and _netype.val == 'ns' and isinstance(_cns, EAtom) \
                        and isinstance(_b_elems, ETuple) and len(_b_elems.elems) >= 4:
                        b_elems = _b_elems.elems
                        _prefix = b_elems[0]
                        _ns = b_elems[1]
                        _module = b_elems[2]
                        _nshash = b_elems[3]
                        if isinstance(_prefix, EAtom) \
                            and isinstance(_ns, EAtom) \
                            and isinstance(_module, EAtom) \
                            and isinstance(_nshash, EInt):
                            ns_hash = _nshash.val
                            ns_descr = try_get(namespaces, ns_hash)
                            if ns_descr is not None:
                                nslist = try_get(mount_id_namespaces, curr_mount_id)
                                if nslist is not None:
                                    nslist.append(ns_descr)
                                else:
                                    mount_id_namespaces[curr_mount_id] = list([ns_descr])
                            else:
                                #log.warning("mount_id", curr_mount_id, "references unknown namespace:", ns_hash)
                                log.warning("mount_id references unknown namespace", {"mount_id": curr_mount_id, "ns_hash": ns_hash})
                            return
        log.warning("Unexpected schema hash_db elem", {"elem": elem})

    def _assemble_node_trees() -> None:
        for root_node_id in raw_roots:
            _roots = _build_node_tree(root_node_id)
            for tag, root in _roots.items():
                roots[tag] = root

        raw_roots = set([]) # raw_roots.clear()
        raw_nodes = {} # raw_nodes.clear()
        raw_keys = {} # raw_keys.clear()

    def _build_node_tree(node_id: int) -> dict[HTag, Node]:
        result = {}

        while node_id != 0:
            raw_node = try_get(raw_nodes, node_id)
            if raw_node is not None:
                children = _build_node_tree(raw_node.child_node_id)
                keys = []
                if raw_node.key_node_id != 0:
                    raw_key = try_get(raw_keys, raw_node.key_node_id)
                    if raw_key is not None:
                        for key_hash in raw_key.key_hashes:
                            key_tag = _make_tag(raw_node.ns_hash, key_hash)
                            key_node = try_get(children, key_tag)
                            if key_node is not None:
                                keys.append(key_node)
                            else:
                                log.warning("Invalid key hash for schema node:", {"key_hash": key_hash, "node_id": node_id})
                    else:
                        log.warning("Invalid key node id for schema node", {"node_id": node_id})
                tag = _make_tag(raw_node.ns_hash, raw_node.tag_hash)
                type_id: ?TypeId = None
                type_descr: ?Type = None
                if raw_node.type_name:
                    _type_id = TypeId(raw_node.type_ns_hash, raw_node.type_name)
                    type_descr = try_get(types, _type_id)
                    type_id = _type_id
                node = Node(
                    tag,
                    raw_node.min_occurs,
                    raw_node.max_occurs,
                    i64(raw_node.info_flags),
                    raw_node.conf_type,
                    type_descr,
                    keys,
                    children)
                result[tag] = node

                if type_id is not None and type_descr is None:
                    def _resolve_cb(t: Type):
                        node.value_type = t
                    pending_type_resolves.append((type_id, _resolve_cb))

                node_id = raw_node.next_node_id
            else:
                log.warning("Invalid schema node_id ref", {"node_id": node_id})

        return result

    def _make_tag(ns_hash: int, name_hash: int) -> HTag:
        tag = HTag(ns_hash, name_hash)
        return tag
        # TODO: Store tag for reuse

    def _htag_to_itag(htag: ?HTag) -> ?ITag:
        if htag is not None:
            name = try_get(hash_to_name, htag.name_hash)
            if name is not None:
                return ITag(try_get(hash_to_name, htag.ns_hash), name)
        return None

    def _resolve_pending_types():
        for type_id: TypeId, resolve_cb: mut(Type) -> None in pending_type_resolves:
            _type = try_get(types, type_id)
            if _type is not None:
                resolve_cb(_type)
            else:
                if log.output_level >= logging.WARNING:
                    log.warning("Failed to resolve reference to type", {"type_name": type_id.str_pretty(hash_to_name)})

    def build() -> Schema:
        log.trace("Build schema", None)

        _resolve_pending_types()

        if log.output_level >= logging.TRACE:
            _pretty_print_nodes(roots, "")
            _pretty_print_types(types, "")

        _roots: dict[HTag, Node] = {}
        _cns_to_namespace: dict[str, NamespaceDescription] = {}
        _mount_id_maps: dict[HTag, NamespaceMaps] = {}

        for htag, node in roots.items():
            _roots[htag] = node

        for ns_descr in namespaces.values():
            _cns_to_namespace[ns_descr.cns] = ns_descr

        for mount_id, ns_items in mount_id_namespaces.items():
            _ns_to_namespace: dict[str, NamespaceDescription] = {}
            _prefix_to_namespace: dict[str, NamespaceDescription] = {}
            _module_to_namespace: dict[str, NamespaceDescription] = {}
            for ns_descr in ns_items:
                _ns_to_namespace[ns_descr.ns] = ns_descr
                _prefix_to_namespace[ns_descr.prefix] = ns_descr
                _module_to_namespace[ns_descr.module] = ns_descr
            _mount_id_maps[mount_id] = NamespaceMaps(_ns_to_namespace, _prefix_to_namespace, _module_to_namespace)

        return Schema(_roots, namespaces, _cns_to_namespace, hash_to_name, name_to_hash, _mount_id_maps)

    def build_shared() -> SharedSchema:
        return SharedSchema(build())

    def _pretty_print_nodes(nodes: dict[HTag, Node], indent: str) -> None:
        for node in nodes.values():
            keys = ""
            if node.keys:
                key_names = []
                for key in node.keys:
                    key_names.append(hash_to_name[key.tag.name_hash])
                keys = "[" + ", ".join(key_names) + "]"
            flags = ""
            if node.flags:
                flag_names = []

                if node.flags & CS_NODE_IS_CASE != 0:
                    flag_names.append("case")
                if node.flags & CS_NODE_IS_LIST != 0:
                    flag_names.append("list")
                    flag_names.append(str(node.min_occurs) + ".." + str(node.max_occurs))
                if node.flags & CS_NODE_IS_CONTAINER != 0:
                    if node.min_occurs == 0:
                        flag_names.append("presence")
                    flag_names.append("container")
                if node.flags & CS_NODE_IS_WRITE == 0:
                    flag_names.append("oper")
                #if node.flags & CS_NODE_IS_CDB != 0:
                if node.flags & CS_NODE_IS_ACTION != 0:
                    flag_names.append("action")
                if node.flags & CS_NODE_IS_PARAM != 0:
                    flag_names.append("param")
                if node.flags & CS_NODE_IS_RESULT != 0:
                    flag_names.append("result")
                #if node.flags & CS_NODE_IS_NOTIF != 0:
                #if node.flags & CS_NODE_HAS_WHEN != 0:
                #if node.flags & CS_NODE_HAS_DISPLAY_WHEN != 0:
                #if node.flags & CS_NODE_META_DATA != 0:
                #if node.flags & CS_NODE_IS_WRITE_ALL != 0:
                if node.flags & CS_NODE_IS_LEAF_LIST != 0:
                    flag_names.append("leaf-list")
                if node.flags & CS_NODE_IS_LEAFREF != 0:
                    flag_names.append("leafref")
                if node.is_mount_point():
                    flag_names.append("mount-point")
                #if node.flags & CS_NODE_IS_STRING_AS_BINARY != 0:

                if flag_names:
                    flags = " (" + ", ".join(flag_names) + ")"
            type_str = ""
            type_descr = node.value_type
            if type_descr is not None:
                type_str = " : " + str(type_descr)
            elif node.is_leaf():
                type_str = " : CONF_" + str(node.conf_type)
            qname = hash_to_name[node.tag.ns_hash] + " " + hash_to_name[node.tag.name_hash]
            log.trace(indent + qname + keys + flags + type_str, None)
            _pretty_print_nodes(node.children, indent + "  ")

    def _pretty_print_types(types: dict[TypeId, Type], indent: str):
        for t in types.values():
            _pretty_print_type(t, indent)

    def _pretty_print_type(t: Type, indent: str):
        log.trace(indent + str(t), None)
        parent_type = t.parent_type
        if parent_type is not None:
            _pretty_print_type(parent_type, indent + "  ")

#
# Type conversions
#

class Integer:
    @staticmethod
    def netconf_to_value(s: str) -> ?int:
        return try_parse_int(s)

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if isinstance(v, int):
            return str(v)
        return None

    @staticmethod
    def value_to_eobject(v: ?value, conf_type: int) -> ?EObject:
        if isinstance(v, int):
            if conf_type == C_INT8:
                return ETuple([EInt(C_INT8), EInt(v)])
            elif conf_type == C_INT16:
                return ETuple([EInt(C_INT16), EInt(v)])
            if conf_type == C_INT32:
                return EInt(v)
            elif conf_type == C_INT64:
                return ETuple([EInt(C_INT64), EInt(v)])
            elif conf_type == C_UINT8:
                return ETuple([EInt(C_UINT8), EInt(v)])
            elif conf_type == C_UINT16:
                return ETuple([EInt(C_UINT16), EInt(v)])
            elif conf_type == C_UINT32:
                return ETuple([EInt(C_UINT32), EInt(v)])
            elif conf_type == C_UINT64:
                return ETuple([EInt(C_UINT64), EInt(v)])
            elif conf_type == C_BIT32:
                return ETuple([EInt(C_BIT32), EInt(v)])
            elif conf_type == C_BIT64:
                return ETuple([EInt(C_BIT64), EInt(v)])
        return None

class Bit:
    @staticmethod
    def netconf_to_value(s: str) -> ?int:
        return try_parse_int(s)

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if isinstance(v, int):
            return str(v)
        return None

    @staticmethod
    def value_to_eobject(v: ?value, conf_type: int) -> ?EObject:
        if isinstance(v, int):
            if conf_type == C_BIT32:
                return ETuple([EInt(C_BIT32), EInt(v)])
            elif conf_type == C_BIT64:
                return ETuple([EInt(C_BIT64), EInt(v)])
            elif conf_type == C_BITBIG:
                # Little-endian
                b: list[int] = []
                _v: int = v
                while True:
                    unsafe_list_append(b, _v % 0x100)
                    _v //= 0x100
                    if _v == 0:
                        break
                return ETuple([EInt(C_BITBIG), EBinary(bytes(b))])
        return None

class Float_:
    @staticmethod
    def netconf_to_value(s: str) -> ?float:
        return try_parse_float(s)

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if isinstance(v, float):
            return str(v)
        return None

    @staticmethod
    def value_to_eobject(v: ?value, conf_type: int) -> ?EObject:
        if isinstance(v, float):
            # if conf_type == C_FLOAT:
            #     raise Exception("Not Implemented")
            if conf_type == C_DOUBLE:
                raise Exception("Not Implemented")

class Boolean:
    @staticmethod
    def netconf_to_value(s: str) -> ?bool:
        if s == 'true':
            return True
        elif s == 'false':
            return False
        else:
            return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if isinstance(v, bool):
            return 'true' if v else 'false'
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, bool):
            return EAtom.from_bool(v)
        return None

class IPv4:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv4Address:
        return IPv4Address.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv4Address):
            return ETuple([EInt(v.data.0), EInt(v.data.1), EInt(v.data.2), EInt(v.data.3)])
        return None

class IPv6:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv6Address:
        return IPv6Address.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv6Address):
            return ETuple([
                EInt(v.data.0), EInt(v.data.1), EInt(v.data.2), EInt(v.data.3),
                EInt(v.data.4), EInt(v.data.5), EInt(v.data.6), EInt(v.data.7)])
        return None

class IPv4Prefix:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv4Network:
        return IPv4Network.try_parse(s.strip(" \t\r\n")) # TODO: Verify that host bits are all zero

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv4Network):
            return ETuple([EInt(C_IPV4PREFIX),
                ETuple([EInt(v.address.data.0), EInt(v.address.data.1), EInt(v.address.data.2), EInt(v.address.data.3)]),
                EInt(v.mask_len)])
        return None

class IPv6Prefix:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv6Network:
        return IPv6Network.try_parse(s.strip(" \t\r\n")) # TODO: Verify that host bits are all zero

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv6Network):
            return ETuple([EInt(C_IPV6PREFIX),
                ETuple([EInt(v.address.data.0), EInt(v.address.data.1), EInt(v.address.data.2), EInt(v.address.data.3)]),
                ETuple([EInt(v.address.data.4), EInt(v.address.data.5), EInt(v.address.data.6), EInt(v.address.data.7)]),
                EInt(v.mask_len)])
        return None

class IPv4AndPrefixLen:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv4Network:
        return IPv4Network.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv4Network):
            return ETuple([EInt(C_IPV4PREFIX),
                ETuple([EInt(v.address.data.0), EInt(v.address.data.1), EInt(v.address.data.2), EInt(v.address.data.3)]),
                EInt(v.mask_len)])
        return None

class IPv6AndPrefixLen:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv6Network:
        return IPv6Network.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv6Network):
            return ETuple([EInt(C_IPV6PREFIX),
                ETuple([EInt(v.address.data.0), EInt(v.address.data.1), EInt(v.address.data.2), EInt(v.address.data.3)]),
                ETuple([EInt(v.address.data.4), EInt(v.address.data.5), EInt(v.address.data.6), EInt(v.address.data.7)]),
                EInt(v.mask_len)])
        return None

class DateTime_:
    @staticmethod
    def netconf_to_value(s: str) -> ?DateTime:
        return DateTime.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, DateTime):
            d: DateTime = v
            tz_h: ?int = d.timezone_hour
            tz_m: ?int = d.timezone_minute

            return ETuple([
                EInt(C_DATETIME),
                ETuple([
                    EInt(d.year),
                    EInt(d.month),
                    EInt(d.day),
                    EInt(d.hour),
                    EInt(d.minute),
                    EInt(d.second),
                    EInt(d.microsecond),
                    EInt(tz_h) if tz_h is not None else EList([], True),
                    EInt(tz_m) if tz_m is not None else EInt(0)
                    ])
                ])
        return None

class Date_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Date:
        return Date.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, Date):
            d: Date = v
            tz_h: ?int = d.timezone_hour
            tz_m: ?int = d.timezone_minute

            return ETuple([
                EInt(C_DATE),
                ETuple([
                    EInt(d.year),
                    EInt(d.month),
                    EInt(d.day),
                    EInt(tz_h) if tz_h is not None else EList([], True),
                    EInt(tz_m) if tz_m is not None else EInt(0)
                    ])
                ])
        return None

class Time_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Time:
        return Time.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, Time):
            d: Time = v
            tz_h: ?int = d.timezone_hour
            tz_m: ?int = d.timezone_minute

            return ETuple([
                EInt(C_TIME),
                ETuple([
                    EInt(d.hour),
                    EInt(d.minute),
                    EInt(d.second),
                    EInt(d.microsecond),
                    EInt(tz_h) if tz_h is not None else EList([], True),
                    EInt(tz_m) if tz_m is not None else EInt(0)
                    ])
                ])
        return None

class Duration_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Duration:
        return Duration.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, Duration):
            d: Duration = v

            return ETuple([
                EInt(C_DURATION),
                ETuple([
                    EInt(d.year),
                    EInt(d.month),
                    EInt(d.day),
                    EInt(d.hour),
                    EInt(d.minute),
                    EInt(d.second),
                    EInt(d.microsecond),
                    ])
                ])
        return None

class Enumeration:
    @staticmethod
    def netconf_to_value(s: str) -> str:
        return s

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if v is not None and isinstance(v, str):
            return v
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        # This should have been handled in schema type-converter
        return None

class QName:
    @staticmethod
    def netconf_to_value(s: str, prefix_to_ns: ?(?str) -> ?str) -> ?Tag:
        return ConfTaggedTag.netconf_to_value(s, prefix_to_ns)

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        return ConfTaggedTag.value_to_netconf(v, cursor)

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor) -> ?EObject:
        if v is not None and isinstance(v, Tag):
            ptag = cursor.lookup_ptag(v)
            if ptag is not None:
                _p = ptag.prefix
                _prefix = _p if _p is not None else 'undefined'
                return ETuple([EInt(C_QNAME), ETuple([EAtom(_prefix), EAtom(ptag.name)])])
        return None

class ConfTaggedTag:
    @staticmethod
    def netconf_to_value(s: str, prefix_to_ns: ?(?str) -> ?str) -> ?Tag:
        return BasicTag.netconf_to_value(s, prefix_to_ns)

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        return BasicTag.value_to_netconf(v, cursor)

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor, use_ikp: bool, conf_type: int) -> ?EObject:
        inner = BasicTag.value_to_eobject(v, cursor, use_ikp)
        if inner is not None:
            return ETuple([EInt(conf_type), inner])
        return None

class BasicTag:
    @staticmethod
    def netconf_to_value(s: str, prefix_to_ns: ?(?str) -> ?str) -> ?Tag:
        prefix: ?str = None
        p = s.split(":", 1)
        name = p[-1]
        if len(p) == 2:
            prefix = p[0]
        if prefix_to_ns is not None:
            _prefix_to_ns: (?str) -> ?str = prefix_to_ns
            ns = _prefix_to_ns(prefix)
            if ns is not None:
                return ITag(ns, name)
            else:
                return PTag(prefix, name)
        else:
            return PTag(prefix, name)
        return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        if v is not None and isinstance(v, Tag):
            ptag = cursor.lookup_ptag(v)
            if ptag is not None:
                _prefix = ptag.prefix
                return _prefix + ":" + ptag.name if _prefix is not None else ptag.name
        return None

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        if v is not None and isinstance(v, Tag):
            if use_ikp:
                itag = cursor.lookup_itag(v)
                if itag is not None:
                    return itag.to_eobject()
            else:
                htag = cursor.lookup_htag(v, True)
                if htag is not None:
                    return htag.to_eobject()
        return None

class InstanceIdentifier:
    @staticmethod
    def netconf_to_value(s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?Keypath:
        # TODO: parse xpath -> keypath
        return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor) -> ?EObject:
        # TODO: Implement
        return None

class Oid_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Oid:
        retval = []
        for p in s.split(".", -1):
            n = Integer.netconf_to_value(p)
            if n is not None:
                retval.append(n)
            else:
                return None
        return Oid(retval) if len(retval) > 0 else None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if v is not None and isinstance(v, list): # if v is not None and isinstance(v, list[int]):
            # return ".".join(str(x) for x in v)
            sl = []
            for x in v:
                sl.append(str(x))
            return ".".join(sl)
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, list): # if v is not None and isinstance(v, list[int]):
            w = BufferWriter()
            for x in v:
                w.write_u32_be(x)
            return ETuple([EInt(C_OID), EBinary(w.to_bytes())])
        return None

class Binary:
    @staticmethod
    def confstr_to_value(s: str) -> ?bytes:
        if s.startswith("<<", None, None) and s.endswith(">>", None, None):
            # return s.encode() # actonc: #### findAttr' fails for __builtin__.value . decode
            _s: str = s[2:-2]
            return _s.encode()
        return s.encode()

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if v is not None and isinstance(v, bytes):
            _v: bytes = v
            return _v.decode()
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, bytes):
            return ETuple([EInt(C_BINARY), EBinary(v)])
        return None

class Decimal64_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Decimal64:
        # Normally we won't get here as the type class converter has done the conversion
        # in order to align the fraction_digits / exponent
        return Decimal64.try_parse(s.strip(" \t\r\n"))

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if v is not None and isinstance(v, Decimal64):
            return str(v)
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, Decimal64):
            d: Decimal64 = v
            return ETuple([EInt(C_DECIMAL64), ETuple([EInt(d.significand), EInt(-d.exponent)])])
        return None

class DottedQuad:
    @staticmethod
    def netconf_to_value(s: str) -> ?bytes:
        p = s.split(".", -1)
        vl = []
        if len(p) > 0:
            for h in p:
                v = try_parse_int(h)
                if v is not None and v <= 0xFF:
                    vl.append(v)
                else:
                    return None
            return bytes(vl)
        return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if v is not None and isinstance(v, bytes):
            sl = []
            for b in v:
                sl.append(str(b))
            return ".".join(sl)
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, bytes):
            return ETuple([EInt(C_DQUAD), EBinary(v)])
        return None

class HexString:
    @staticmethod
    def confstr_to_value(s: str) -> ?bytes:
        s = s.strip("<>\"")
        p = s.split(":", -1)
        vl = []
        if len(p) > 0:
            for h in p:
                v = try_parse_hex(h)
                if v is not None and v <= 0xFF:
                    vl.append(v)
                else:
                    return None
            return bytes(vl)
        return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        if v is not None and isinstance(v, bytes):
            sl = []
            for b in v:
                sl.append(to_byte_hexpair_str(b))
            return ":".join(sl)
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, bytes):
            return ETuple([EInt(C_HEXSTR), EBinary(v)])
        return None

class Any:
    @staticmethod
    def netconf_to_value(s: str, conf_type: int, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        if conf_type == C_NOEXISTS:
            return V_NOEXISTS
        elif conf_type == C_XMLTAG:
            return None # Deprecated / Not in use?
        elif conf_type == C_SYMBOL:
            return None # Not in use?
        elif conf_type == C_STR:
            return s
        elif conf_type == C_BUF:
            return s
        elif conf_type == C_INT8:
            return Integer.netconf_to_value(s)
        elif conf_type == C_INT16:
            return Integer.netconf_to_value(s)
        elif conf_type == C_INT32:
            return Integer.netconf_to_value(s)
        elif conf_type == C_INT64:
            return Integer.netconf_to_value(s)
        elif conf_type == C_UINT8:
            return Integer.netconf_to_value(s)
        elif conf_type == C_UINT16:
            return Integer.netconf_to_value(s)
        elif conf_type == C_UINT32:
            return Integer.netconf_to_value(s)
        elif conf_type == C_UINT64:
            return Integer.netconf_to_value(s)
        elif conf_type == C_DOUBLE:
            return Float_.netconf_to_value(s)
        elif conf_type == C_IPV4:
            return IPv4.netconf_to_value(s)
        elif conf_type == C_IPV6:
            return IPv6.netconf_to_value(s)
        elif conf_type == C_BOOL:
            return Boolean.netconf_to_value(s)
        elif conf_type == C_QNAME:
            return QName.netconf_to_value(s, prefix_to_ns) # ITag('undefined', s) # ??? As java-api ...
        elif conf_type == C_DATETIME:
            return DateTime_.netconf_to_value(s)
        elif conf_type == C_DATE:
            return Date_.netconf_to_value(s)
        elif conf_type == C_TIME:
            return Time_.netconf_to_value(s)
        elif conf_type == C_DURATION:
            return Duration_.netconf_to_value(s)
        elif conf_type == C_ENUM_VALUE:
            return Enumeration.netconf_to_value(s)
        elif conf_type == C_BIT32:
            return Bit.netconf_to_value(s)
        elif conf_type == C_BIT64:
            return Bit.netconf_to_value(s)
        elif conf_type == C_BITBIG:
            return Bit.netconf_to_value(s)
        elif conf_type == C_LIST:
            return None # Leaf-list values must be converted per value
        elif conf_type == C_IDENTITYREF:
            return ConfTaggedTag.netconf_to_value(s, prefix_to_ns)
        elif conf_type == C_INSTANCE_IDENTIFIER:
            return InstanceIdentifier.netconf_to_value(s, cursor, prefix_to_ns)
        elif conf_type == C_OID:
            return Oid_.netconf_to_value(s)
        elif conf_type == C_BINARY:
            return Binary.confstr_to_value(s)
        elif conf_type == C_IPV4PREFIX:
            return IPv4Prefix.netconf_to_value(s)
        elif conf_type == C_IPV6PREFIX:
            return IPv6Prefix.netconf_to_value(s)
        elif conf_type == C_DEFAULT:
            return None # Must be resolved in Type
        elif conf_type == C_DECIMAL64:
            return Decimal64_.netconf_to_value(s)
        elif conf_type == C_DQUAD:
            return DottedQuad.netconf_to_value(s)
        elif conf_type == C_HEXSTR:
            return HexString.confstr_to_value(s)
        elif conf_type == C_IPV4_AND_PLEN:
            return IPv4AndPrefixLen.netconf_to_value(s)
        elif conf_type == C_IPV6_AND_PLEN:
            return IPv6AndPrefixLen.netconf_to_value(s)
        return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?value: # ?(str OR list[str])
        conf_type = cursor.node().conf_type
        if conf_type == C_NOEXISTS:
            return None
        elif conf_type == C_XMLTAG:
            return None # Deprecated / Not in use?
        elif conf_type == C_SYMBOL:
            return None # Not in use?
        elif conf_type == C_STR:
            return str(v) if v is not None else None
        elif conf_type == C_BUF:
            return str(v) if v is not None else None
        elif conf_type == C_INT8:
            return Integer.value_to_netconf(v, cursor)
        elif conf_type == C_INT16:
            return Integer.value_to_netconf(v, cursor)
        elif conf_type == C_INT32:
            return Integer.value_to_netconf(v, cursor)
        elif conf_type == C_INT64:
            return Integer.value_to_netconf(v, cursor)
        elif conf_type == C_UINT8:
            return Integer.value_to_netconf(v, cursor)
        elif conf_type == C_UINT16:
            return Integer.value_to_netconf(v, cursor)
        elif conf_type == C_UINT32:
            return Integer.value_to_netconf(v, cursor)
        elif conf_type == C_UINT64:
            return Integer.value_to_netconf(v, cursor)
        elif conf_type == C_DOUBLE:
            return Float_.value_to_netconf(v, cursor)
        elif conf_type == C_IPV4:
            return IPv4.value_to_netconf(v, cursor)
        elif conf_type == C_IPV6:
            return IPv6.value_to_netconf(v, cursor)
        elif conf_type == C_BOOL:
            return Boolean.value_to_netconf(v, cursor)
        elif conf_type == C_QNAME:
            return QName.value_to_netconf(v, cursor)
        elif conf_type == C_DATETIME:
            return DateTime_.value_to_netconf(v, cursor)
        elif conf_type == C_DATE:
            return Date_.value_to_netconf(v, cursor)
        elif conf_type == C_TIME:
            return Time_.value_to_netconf(v, cursor)
        elif conf_type == C_DURATION:
            return Duration_.value_to_netconf(v, cursor)
        elif conf_type == C_ENUM_VALUE:
            return Enumeration.value_to_netconf(v, cursor)
        elif conf_type == C_BIT32:
            return Bit.value_to_netconf(v, cursor)
        elif conf_type == C_BIT64:
            return Bit.value_to_netconf(v, cursor)
        elif conf_type == C_BITBIG:
            return Bit.value_to_netconf(v, cursor)
        elif conf_type == C_LIST:
            return None # Leaf-list values must be converted per element
        elif conf_type == C_IDENTITYREF:
            return ConfTaggedTag.value_to_netconf(v, cursor)
        elif conf_type == C_INSTANCE_IDENTIFIER:
            return InstanceIdentifier.value_to_netconf(v, cursor)
        elif conf_type == C_OID:
            return Oid_.value_to_netconf(v, cursor)
        elif conf_type == C_BINARY:
            return Binary.value_to_netconf(v, cursor)
        elif conf_type == C_IPV4PREFIX:
            return IPv4Prefix.value_to_netconf(v, cursor)
        elif conf_type == C_IPV6PREFIX:
            return IPv6Prefix.value_to_netconf(v, cursor)
        elif conf_type == C_DEFAULT:
            return None
        elif conf_type == C_DECIMAL64:
            return Decimal64_.value_to_netconf(v, cursor)
        elif conf_type == C_DQUAD:
            return DottedQuad.value_to_netconf(v, cursor)
        elif conf_type == C_HEXSTR:
            return HexString.value_to_netconf(v, cursor)
        elif conf_type == C_IPV4_AND_PLEN:
            return IPv4AndPrefixLen.value_to_netconf(v, cursor)
        elif conf_type == C_IPV6_AND_PLEN:
            return IPv6AndPrefixLen.value_to_netconf(v, cursor)
        return None

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        conf_type = cursor.node().conf_type
        if conf_type == C_NOEXISTS:
            return E_NOEXISTS
        elif conf_type == C_XMLTAG:
            return None # Deprecated?
        elif conf_type == C_SYMBOL:
            return None # Deprecated?
        elif conf_type == C_STR:
            return EBinary.from_str(v + "\0") if v is not None and isinstance(v, str) else None
        elif conf_type == C_BUF:
            return EBinary.from_str(v) if v is not None and isinstance(v, str) else None
        elif conf_type == C_INT8:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_INT16:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_INT32:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_INT64:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_UINT8:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_UINT16:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_UINT32:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_UINT64:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_DOUBLE:
            return Float_.value_to_eobject(v, conf_type)
        elif conf_type == C_IPV4:
            return IPv4.value_to_eobject(v)
        elif conf_type == C_IPV6:
            return IPv6.value_to_eobject(v)
        elif conf_type == C_BOOL:
            return Boolean.value_to_eobject(v)
        elif conf_type == C_QNAME:
            return QName.value_to_eobject(v, cursor) # ??? As java-api ...
        elif conf_type == C_DATETIME:
            return DateTime_.value_to_eobject(v)
        elif conf_type == C_DATE:
            return Date_.value_to_eobject(v)
        elif conf_type == C_TIME:
            return Time_.value_to_eobject(v)
        elif conf_type == C_DURATION:
            return Duration_.value_to_eobject(v)
        elif conf_type == C_ENUM_VALUE:
            return Enumeration.value_to_eobject(v)
        elif conf_type == C_BIT32:
            return Bit.value_to_eobject(v, C_BIT32)
        elif conf_type == C_BIT64:
            return Bit.value_to_eobject(v, C_BIT64)
        elif conf_type == C_BITBIG:
            return Bit.value_to_eobject(v, C_BITBIG)
        elif conf_type == C_LIST:
            return None # Leaf-list values must be converted per value
        elif conf_type == C_IDENTITYREF:
            return ConfTaggedTag.value_to_eobject(v, cursor, False, C_IDENTITYREF) # Always use hkp format?
        elif conf_type == C_INSTANCE_IDENTIFIER:
            return InstanceIdentifier.value_to_eobject(v, cursor)
        elif conf_type == C_OID:
            return Oid_.value_to_eobject(v)
        elif conf_type == C_BINARY:
            return Binary.value_to_eobject(v)
        elif conf_type == C_IPV4PREFIX:
            return IPv4Prefix.value_to_eobject(v)
        elif conf_type == C_IPV6PREFIX:
            return IPv6Prefix.value_to_eobject(v)
        elif conf_type == C_DEFAULT:
            return EAtom('default')
        elif conf_type == C_DECIMAL64:
            return Decimal64_.value_to_eobject(v)
        elif conf_type == C_DQUAD:
            return DottedQuad.value_to_eobject(v)
        elif conf_type == C_HEXSTR:
            return HexString.value_to_eobject(v)
        elif conf_type == C_IPV4_AND_PLEN:
            return IPv4AndPrefixLen.value_to_eobject(v)
        elif conf_type == C_IPV6_AND_PLEN:
            return IPv6AndPrefixLen.value_to_eobject(v)
        return None

    @staticmethod
    def eobject_to_conf_type_and_value(obj: ?EObject, cursor: Cursor) -> (int, ?value):
        _value_type = cursor.node().value_type
        if _value_type is not None:
            return _value_type.eobject_to_conf_type_and_value(obj, cursor)
        return Any.eobject_to_conf_type_and_base_value(obj)

    @staticmethod
    def eobject_to_conf_type_and_base_value(v: ?EObject) -> (int, ?value):
        """Schema-less mapping of Conf objects Telemetrify values"""
        if isinstance(v, ETuple):
            _elems = v.elems
            _elems_len = len(_elems)
            if _elems_len == 4:
                _n0 = _elems[0]
                _n1 = _elems[1]
                _n2 = _elems[2]
                _n3 = _elems[3]
                if isinstance(_n0, EInt) and isinstance(_n1, EInt) and isinstance(_n2, EInt) and isinstance(_n3, EInt):
                    return (C_IPV4, IPv4Address((_n0.val, _n1.val, _n2.val, _n3.val)))
            elif _elems_len == 8:
                _n0 = _elems[0]
                _n1 = _elems[1]
                _n2 = _elems[2]
                _n3 = _elems[3]
                _n4 = _elems[4]
                _n5 = _elems[5]
                _n6 = _elems[6]
                _n7 = _elems[7]
                if isinstance(_n0, EInt) and isinstance(_n1, EInt) and isinstance(_n2, EInt) and isinstance(_n3, EInt) \
                    and isinstance(_n4, EInt) and isinstance(_n5, EInt) and isinstance(_n6, EInt) and isinstance(_n7, EInt):
                    return (C_IPV6, IPv6Address((_n0.val, _n1.val, _n2.val, _n3.val, _n4.val, _n5.val, _n6.val, _n7.val)))
            elif _elems_len == 2:
                _conf_type = _elems[0]
                if isinstance(_conf_type, EInt):
                    _val = _elems[1]
                    conf_type = _conf_type.val
                    if conf_type in [C_INT8, C_INT16, C_INT64, C_UINT8, C_UINT16, C_UINT32, C_UINT64] and _elems_len == 2:
                        if isinstance(_val, EInt):
                            return (conf_type, _val.val)
                    elif conf_type == C_QNAME:
                        # TODO: ns or prefix? Java-api seems to think it's a prefix but erlang-api calls it "ns". Assume prefix for now.
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 2:
                                _prefix = _velems[0]
                                _name = _velems[1]
                                if isinstance(_prefix, EAtom) and isinstance(_name, EAtom):
                                    prefix = str(_prefix)
                                    return (conf_type, PTag(prefix if prefix != 'undefined' else None, str(_name)))
                    elif conf_type == C_DATETIME:
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 9:
                                _year = _velems[0]
                                _month = _velems[1]
                                _day = _velems[2]
                                _hour = _velems[3]
                                _minute = _velems[4]
                                _second = _velems[5]
                                _microsecond = _velems[6]
                                _tz_h = _velems[7]
                                _tz_m = _velems[8]
                                if isinstance(_year, EInt) \
                                        and isinstance(_month, EInt) \
                                        and isinstance(_day, EInt) \
                                        and isinstance(_hour, EInt) \
                                        and isinstance(_minute, EInt) \
                                        and isinstance(_second, EInt) \
                                        and isinstance(_microsecond, EInt):

                                    tz_h: ?int = _tz_h.val if isinstance(_tz_h, EInt) else 0 if isinstance(_tz_h, EAtom) and str(_tz_h) == 'Z' else None
                                    tz_m: ?int = _tz_m.val if isinstance(_tz_m, EInt) and tz_h is not None else None

                                    return (conf_type, DateTime(
                                        _year.val,
                                        _month.val,
                                        _day.val,
                                        _hour.val,
                                        _minute.val,
                                        _second.val,
                                        _microsecond.val,
                                        tz_h,
                                        tz_m))

                    elif conf_type == C_DATE:
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 5:
                                _year = _velems[0]
                                _month = _velems[1]
                                _day = _velems[2]
                                _tz_h = _velems[3]
                                _tz_m = _velems[4]
                                if isinstance(_year, EInt) \
                                        and isinstance(_month, EInt) \
                                        and isinstance(_day, EInt):

                                    tz_h: ?int = _tz_h.val if isinstance(_tz_h, EInt) else 0 if isinstance(_tz_h, EAtom) and str(_tz_h) == 'Z' else None
                                    tz_m: ?int = _tz_m.val if isinstance(_tz_m, EInt) and tz_h is not None else None

                                    return (conf_type, Date(
                                        _year.val,
                                        _month.val,
                                        _day.val,
                                        tz_h,
                                        tz_m))

                    elif conf_type == C_TIME:
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 6:
                                _hour = _velems[0]
                                _minute = _velems[1]
                                _second = _velems[2]
                                _microsecond = _velems[3]
                                _tz_h = _velems[4]
                                _tz_m = _velems[5]
                                if isinstance(_hour, EInt) \
                                        and isinstance(_minute, EInt) \
                                        and isinstance(_second, EInt) \
                                        and isinstance(_microsecond, EInt):

                                    tz_h: ?int = _tz_h.val if isinstance(_tz_h, EInt) else 0 if isinstance(_tz_h, EAtom) and str(_tz_h) == 'Z' else None
                                    tz_m: ?int = _tz_m.val if isinstance(_tz_m, EInt) and tz_h is not None else None

                                    return (conf_type, Time(
                                        _hour.val,
                                        _minute.val,
                                        _second.val,
                                        _microsecond.val,
                                        tz_h,
                                        tz_m))

                    elif conf_type == C_DURATION:
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 7:
                                _year = _velems[0]
                                _month = _velems[1]
                                _day = _velems[2]
                                _hour = _velems[3]
                                _minute = _velems[4]
                                _second = _velems[5]
                                _microsecond = _velems[6]
                                if isinstance(_year, EInt) \
                                        and isinstance(_month, EInt) \
                                        and isinstance(_day, EInt) \
                                        and isinstance(_hour, EInt) \
                                        and isinstance(_minute, EInt) \
                                        and isinstance(_second, EInt) \
                                        and isinstance(_microsecond, EInt):

                                    return (conf_type, Duration(
                                        _year.val,
                                        _month.val,
                                        _day.val,
                                        _hour.val,
                                        _minute.val,
                                        _second.val,
                                        _microsecond.val))

                    elif conf_type == C_ENUM_VALUE:
                        if isinstance(_val, EInt):
                            return (conf_type, _val.val)
                        elif isinstance(_val, EAtom):
                            return (conf_type, str(_val))
                    elif conf_type in [C_BIT32, C_BIT64]:
                        if isinstance(_val, EInt):
                            return (conf_type, _val.val)
                    elif conf_type == C_INSTANCE_IDENTIFIER:
                        # TODO: Implement
                        # Only time we need schema?
                        return (conf_type, Keypath([]))
                    elif conf_type == C_OID:
                        if isinstance(_val, EBinary):
                            oid: list[int] = []
                            reader = BufferReader()
                            reader.append_data(_val.data)
                            while reader.has_unread_bytes():
                                n = reader.read_u32_be()
                                if isinstance(n, int):
                                    unsafe_list_append(oid, n)
                                else:
                                    return (C_UNKNOWN, None)
                            return (conf_type, oid)
                    elif conf_type == C_BINARY:
                        if isinstance(_val, EBinary):
                            return (conf_type, _val.data)
                    elif conf_type == C_IPV4PREFIX or conf_type == C_IPV4_AND_PLEN:
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 5:
                                _n0 = _velems[0]
                                _n1 = _velems[1]
                                _n2 = _velems[2]
                                _n3 = _velems[3]
                                _mask_len = _velems[4]
                                if isinstance(_n0, EInt) and isinstance(_n1, EInt) and isinstance(_n2, EInt) and isinstance(_n3, EInt) \
                                    and isinstance(_mask_len, EInt):
                                    return (conf_type, IPv4Network(IPv4Address((_n0.val, _n1.val, _n2.val, _n3.val)), _mask_len.val))
                    elif conf_type == C_IPV6PREFIX or conf_type == C_IPV6_AND_PLEN:
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 9:
                                _n0 = _velems[0]
                                _n1 = _velems[1]
                                _n2 = _velems[2]
                                _n3 = _velems[3]
                                _n4 = _velems[4]
                                _n5 = _velems[5]
                                _n6 = _velems[6]
                                _n7 = _velems[7]
                                _mask_len = _velems[8]
                                if isinstance(_n0, EInt) and isinstance(_n1, EInt) and isinstance(_n2, EInt) and isinstance(_n3, EInt) \
                                    and isinstance(_n4, EInt) and isinstance(_n5, EInt) and isinstance(_n6, EInt) and isinstance(_n7, EInt) \
                                    and isinstance(_mask_len, EInt):
                                    return (conf_type, IPv6Network(IPv6Address((_n0.val, _n1.val, _n2.val, _n3.val, _n4.val, _n5.val, _n6.val, _n7.val)), _mask_len.val))
                    elif conf_type == C_DECIMAL64:
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 2:
                                _significand = _velems[0]
                                _exponent = _velems[1]
                                if isinstance(_significand, EInt) and isinstance(_exponent, EInt):
                                    return (conf_type, Decimal64(_significand.val, _exponent.val))
                    elif conf_type == C_IDENTITYREF:
                        if isinstance(_val, ETuple):
                            _velems = _val.elems
                            if len(_velems) == 2:
                                _ns = _velems[0]
                                _tag = _velems[1]
                                if isinstance(_ns, EInt) and isinstance(_tag, EInt):
                                    return (conf_type, HTag(_ns.val, _tag.val))
                                elif isinstance(_ns, EAtom) and isinstance(_tag, EAtom):
                                    return (conf_type, ITag(str(_ns), str(_tag)))
                    elif conf_type == C_DQUAD:
                        if isinstance(_val, EBinary):
                            return (conf_type, _val.data)
                    elif conf_type == C_HEXSTR:
                        if isinstance(_val, EBinary):
                            return (conf_type, _val.data)
                    elif conf_type == C_BITBIG:
                        if isinstance(_val, EBinary):
                            # Little-endian
                            d = _val.data
                            b: int = 0
                            for i in range(len(d), -1, -1):
                                b *= 0x100
                                b += d[i]

                            return (conf_type, b)
        elif isinstance(v, EInt):
            return (C_INT32, v.val)
        elif isinstance(v, EBinary):
            _s = str(v)
            if len(_s) >= 1 and _s[-1] == '\x00':
                return (C_STR, _s[0:-1:1])
            return (C_BUF, _s)
        elif isinstance(v, EAtom):
            _s = v.val
            if _s == _EV_NOEXISTS:
                return (C_NOEXISTS, V_NOEXISTS)
            elif _s == _EV_LEAF:
                return (C_LEAF, V_LEAF)
            elif _s == _EV_START:
                return (C_START, V_START)
            elif _s == _EV_STOP:
                return (C_STOP, V_STOP)
            elif _s == _EV_DELETE:
                return (C_DELETE, V_DELETE)
            elif _s == _EV_DEFAULT:
                return (C_DEFAULT, V_DEFAULT)
            elif _s == _EV_TRUE:
                return (C_BOOL, True)
            elif _s == _EV_FALSE:
                return (C_BOOL, False)
        elif isinstance(v, EList):
            # TODO: How do we want to use this? Won't need C_LIST for leaf-lists with ConfXMLParams, but how about maapi.get_elem()?
            # _l: list[(int, ?value)] = []
            # for _e in v.elems:
            #     unsafe_list_append(_l, Any.eobject_to_conf_type_and_value(_e, cursor))
            _l: list[value] = []
            for _e in v.elems:
                _inner_conf_type, _elem_base_val = Any.eobject_to_conf_type_and_base_value(_e)
                if _elem_base_val is not None:
                    unsafe_list_append(_l, _elem_base_val)
                else:
                    return (C_UNKNOWN, None)
            return (C_LIST, _l)

        return (C_UNKNOWN, None)

#

pure def unsafe_get_shared_schema(shared_schema: SharedSchema) -> Schema:
    #return Schema({}, {}, {}, {}, {}, {})
    NotImplemented
