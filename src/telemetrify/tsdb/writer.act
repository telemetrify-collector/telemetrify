# Copyright (C) Deutsche Telekom AG
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import logging
import xml
import re
from telemetrify.common.mod import *
from telemetrify.common.utils import *
from telemetrify.nsoapi.proto import *
import telemetrify.nsoapi.schema as schema
import tsdb.m3

_STATE_IDLE = 0

def dumb_push(cursor, name):
    """Stupid cursor.push() working around some problem
    """
    # The cursor.push can take an ITag and try to look it up into an HTag.
    # This fails, seemingly because the schema we are working on
    # (urn:junos-rpc) isn't in the NamespaceMaps, not sure why. We hack
    # around it by just iterating over HTags instead, get the corresponding
    # ITag, check the name and boom!
    for k,v in cursor.node().children.items():
        itag = cursor.lookup_itag(k)
        if itag is not None:
            if itag.name == name:
                cursor.push(k)
                return True
    return False

def flatten_tags(tag_stack: list[list[(str, str)]]) -> dict[str, str]:
    ret = {}

    for tags in tag_stack:
        for tag in tags:
            pass
            ret[tag.0] = tag.1

    return ret

def get_metrics_from_tree(node: Node, cursor: schema.Cursor, timestamp: int, path: list[str], tags: list[list[(str, str)]], log: logging.Logger) -> list[tsdb.m3.Metric]:
    s_node = cursor.node()

    if node.op() in [OP_NOCREATE, OP_DELETE]:
        return []

    if log.output_level >= logging.TRACE:
        log.trace("Metric conversion at tags:", {"tag": optional_str(node.tag(), "None"), "itag": optional_str(cursor.lookup_itag(s_node.tag), "None")})
        if len(s_node.keys) > 0:
            log.trace("Metric conversion schema keys " + optional_str(cursor.lookup_itag(s_node.tag), "None") + " - " + list_str(s_node.keys) + " " + optional_str(cursor.lookup_itag(s_node.keys[0].tag), "None"), None)
    leafval = node.value()
    if leafval is not None:
        log.trace("Metric conversion data node is LEAF", None)
        floatval = None
        _tag = node.tag()

        if _tag is not None:
            _itag = cursor.lookup_itag(_tag)
            if _itag is not None:
                if log.output_level >= logging.TRACE:
                    log.trace("Metric conversion data node LEAF", {"name": _itag.name, "str_value": str(leafval).strip("\n")})
                _type = s_node.value_type
                if _type is not None:
                    log.trace("Metric conversion", {"name": _itag.name, "schema_type": _type})
                    if isinstance(leafval, str):
                        nativeval = _type.netconf_to_value(leafval.strip("\n"), cursor, node.namespaces())
                        if nativeval is not None:
                            if log.output_level >= logging.TRACE:
                                log.trace("Metric conversion data node LEAF type native", {"value": str(nativeval)})
                            if isinstance(nativeval, int):
                                log.trace("Metric conversion data node LEAF type int", None)
                                return [tsdb.m3.Metric("_".join(path).replace("-", "_", None), flatten_tags(tags), float(nativeval), timestamp)]
                            elif isinstance(nativeval, float):
                                log.trace("Metric conversion data node LEAF type float", None)
                                return [tsdb.m3.Metric("_".join(path).replace("-", "_", None), flatten_tags(tags), nativeval, timestamp)]
                    else:
                        log.trace("leafval is not a str, skipping...", None)
                else:
                    log.trace("Metric conversion schema type is None", {"name": _itag.name})

                    trimmed_strval = str(leafval).strip("\n")
                    floatval = try_parse_float(trimmed_strval)
                    if floatval is not None:
                        return [tsdb.m3.Metric("_".join(path).replace("-", "_", None), flatten_tags(tags), floatval, timestamp)]
                    else:
                        log.trace("Metric conversion value cannot convert to float.", {"name": _itag.name})
        return []
    else:
        log.trace("Metric conversion data node is TREE", None)
        ret = []
        key_names = []
        for key in s_node.keys:
            itag = cursor.lookup_itag(key.tag)
            if isinstance(itag, ITag):
                log.trace("Metric conversion key itag:", {"itag": itag})
                key_names.append(itag.name)
        log.trace("Metric conversion key names", {"key_names": key_names})
        keyval_pairs = []
        non_key_children = []
        for child in node.children():
            tag = child.tag()
            if isinstance(tag, Tag):
                itag = cursor.lookup_itag(tag)
                if itag is not None:
                    if itag.name in key_names:
                        childval = child.value()
                        if childval is not None:
                            keyval_pairs.append(("_".join(path).replace("-", "_", None) + "_" + itag.name.replace("-", "_", None), str(childval).strip("\n")))
                    else:
                        non_key_children.append(child)

        tags.append(keyval_pairs)
        for child in non_key_children:
            tag = child.tag()
            if isinstance(tag, Tag):
                itag = cursor.lookup_itag(tag)
                if itag is not None:
                    if dumb_push(cursor, itag.name):
                        path.append(itag.name)
                        ret += get_metrics_from_tree(child, cursor, timestamp, path, tags, log)
                        path.pop(-1)
                        cursor.pop()
                    else:
                        log.trace("Metric conversion tag not found in schema:", {"name": itag.name})
        tags.pop(-1)

        return ret

actor TSDBWriter(m3c: tsdb.m3.Client, shared_schema: schema.SharedSchema, log_handler: ?logging.Handler):
    var logh = logging.Handler("tsdb-writer")
    if log_handler is not None:
        logh.set_handler(log_handler)

    var log = logging.Logger(logh)

    var write_tasks = Queue()

    # Current write task
    var prefix_epath: list[EObject] = []
    var state: int = _STATE_IDLE
    var work_stack: list[(value, int)] = [] # list[(v: value, _parent_state: int)]
    var epath: list[EObject] = [] # EKeypath
    var eparams: list[EObject] = []
    var pending_mount_id: ?HTag = None

    _schema = schema.unsafe_get_shared_schema(shared_schema)

    #def write(node: Node, thandle: int, use_ikp: bool, result_cb: action(?Exception) -> None):
    def write(node: Node, schema_path: ?schema.SchemaPath, base_tags: list[(str, str)], timestamp: int, result_cb: action(TSDBWriter, ?Exception) -> None):
        cursor: schema.Cursor = schema.Cursor(_schema)
        if schema_path is not None:
            if not cursor.push_schema_path(schema_path):
                log.trace("Invalid schema path:", {"schema_path": schema_path})
                return

        path = []

        # Are we dealing with an RPC payload?
        rpc_parent = cursor.path()[-1]
        if rpc_parent.is_action():
            path.append("rpc")
            itag = cursor.lookup_itag(rpc_parent.tag)
            if itag is not None:
                path.append(itag.name)

        metrics = get_metrics_from_tree(node, cursor, timestamp, path, [base_tags], log)
        log.trace("Metrics to write:", {"metrics": metrics})
        #if len(metrics) > 0:
        #    log.trace("First metric to write:", {"metric": metrics[0]})
        #else:
        #    log.trace("No metrics to write", None)

        def _on_response(c, success):
            pass
#            if success:
#                log.trace("Metric send successful", None)
#            else:
#                log.trace("Metric send failed", None)

        def _on_last_response(c, success, cb: action(TSDBWriter, ?Exception) -> None):
            pass
#            if success:
#                log.trace("Metric final send successful", None)
#            else:
#                log.trace("Metric final send failed", None)

            cb(self, None)

        log.trace("About to iterate over metrics", None)
        _remaining_metrics = len(metrics)

        if _remaining_metrics == 0:
           result_cb(self, None)

        for metric in metrics:
            _remaining_metrics -= 1
            #log.trace("Metric iteration", None)
            #log.trace("Metric to write", {"metric": metric})
            # XXX This is really a race condition, to fix later
            if _remaining_metrics > 0:
                m3c.send_metric(metric, _on_response)
            else:
                m3c.send_metric(metric, lambda c, s: _on_last_response(c, s, result_cb))

        #result_cb(self, None)

    def _reset():
        prefix_epath = []
        result_cb = None
        state = _STATE_IDLE
        work_stack = []
        #cursor = schema.Cursor(_schema)
        epath = []
        eparams = []
        pending_mount_id = None

    def _poll():
        log.trace("writer: begin poll", None)
        while True:
            if state == _STATE_IDLE:
                log.trace("writer:   STATE_IDLE", None)
                if write_tasks:
                    log.trace("writer:     Setup write task", None)
                    #_setup_next_task()
                else:
                    log.trace("writer:     No tasks", None)
                    break

