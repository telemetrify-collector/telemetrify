# Copyright (C) Deutsche Telekom AG
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import time

import telemetrify.nso.subscriber
import telemetrify.nsoapi.cdb
import telemetrify.nsoapi.schema as schema

from telemetrify.common.mod import *
from telemetrify.common.utils import *
from telemetrify.nso.subscriber import *
from telemetrify.nsoapi.cdb import *

actor L3vpnSvcTracker(env: Env, shared_schema: schema.SharedSchema):
    var cache: ?telemetrify.nso.subscriber.CdbCache = None
    var site_access_path_params: dict[Keypath, L3vpnSvcParams] = {}
    var wan_interface_ipv4_address_params: dict[IPv4Address, L3vpnSvcParams] = {}
    var lan_interface_ipv4_address_params: dict[IPv4Address, L3vpnSvcParams] = {}
    var hostname_params: dict[str, L3vpnSvcParams] = {}

    def lookup_by_wan_interface_ipv4_addresses(ipv4_addresses: set[IPv4Address], result_cb: action(dict[IPv4Address, L3vpnSvcParams]) -> None):
        result: dict[IPv4Address, L3vpnSvcParams] = {}

        print("ietf.l3vpn_svc.lookup_by_wan_interface_ipv4_addresses: lookup ", set_str(ipv4_addresses))

        for ipv4_address in ipv4_addresses:
            params = try_get(wan_interface_ipv4_address_params, ipv4_address)
            if params is not None:
                result[ipv4_address] = params

        print("ietf.l3vpn_svc.lookup_by_wan_interface_ipv4_addresses: found ", mapping_str(result))

        result_cb(result)

    def lookup_by_hostnames_and_lan_interface_addresses(hostnames: set[str], ipv4_addresses: set[IPv4Address], result_cb: action(dict[str, L3vpnSvcParams], dict[IPv4Address, L3vpnSvcParams]) -> None):
        hostname_result: dict[str, L3vpnSvcParams] = {}
        ipv4_address_result: dict[IPv4Address, L3vpnSvcParams] = {}

        print("ietf.l3vpn_svc.lookup_by_hostnames_and_lan_interface_addresses: lookup ", set_str(hostnames), set_str(ipv4_addresses))

        for hostname in hostnames:
            params = try_get(hostname_params, hostname)
            if params is not None:
                hostname_result[hostname] = params

        for ipv4_address in ipv4_addresses:
            params = try_get(lan_interface_ipv4_address_params, ipv4_address)
            if params is not None:
                ipv4_address_result[ipv4_address] = params

        print("ietf.l3vpn_svc.lookup_by_hostnames_and_lan_interface_addresses: found ", mapping_str(hostname_result), mapping_str(ipv4_address_result))

        result_cb(hostname_result, ipv4_address_result)

    def close():
        pass # TODO

    def _on_cdb_connect_error(e):
        print("ietf.l3vpn_svc - CDB connect failed:", e)
        # TODO
        # await async env.exit(1)

    def _on_cdb_sub_connect(sc, s):
        print("ietf.l3vpn_svc - CDB (sub) connected!!!!")
        cdb_connection = telemetrify.nsoapi.cdb.CdbConnection(env, 4569, "telemetrify",
            action lambda cc: _on_cdb_cmd_connect(sc, cc, s), _on_cdb_connect_error, None)

    def _on_cdb_cmd_connect(sc, cc, s):
        print("ietf.l3vpn_svc - CDB (cmd) connected!!!!")
        cache = telemetrify.nso.subscriber.CdbCache(sc, cc, s,
            [
                HostnameRefiner,
                VpnIdRefiner,
                DeviceReferenceRefiner,
                WanInterfaceIPv4AddressRefiner,
                LanInterfaceIPv4AddressRefiner,
                IpPerformanceBidirectionalRefiner,
                CustomerNameRefiner,
                L3vpnSvcParamsRefiner,
            ],
            [([
                # HostnameRefiner.id(), # For DEBUG printouts only
                # VpnIdRefiner.id(), # For DEBUG printouts only
                # DeviceReferenceRefiner.id(), # For DEBUG printouts only
                # WanInterfaceIPv4AddressRefiner.id(), # For DEBUG printouts only
                # LanInterfaceIPv4AddressRefiner.id(), # For DEBUG printouts only
                # IpPerformanceBidirectionalRefiner.id(), # For DEBUG printouts only
                # CustomerNameRefiner.id(), # For DEBUG printouts only
                L3vpnSvcParamsRefiner.id()
            ],
            lambda r: _on_config_update(r, s))], _on_config_cache_error)

    def _on_config_update(refiner_updates: dict[int, list[(Keypath, ?value)]], shared_schema: schema.SharedSchema):
        for refiner_id, updates in refiner_updates.items():
            print("ietf.l3vpn_svc - refiner_id: " + str(refiner_id))
            for k, v in updates:
                print("  " + str(k) + ": " + (str(v) if v is not None else "DELETED"))

            l3vpn_svc_params: list[(Keypath, ?value)] = refiner_updates[L3vpnSvcParamsRefiner.id()]

            for site_access_path_key, state in l3vpn_svc_params:
                if state is not None and isinstance(state, L3vpnSvcParams):
                    params: L3vpnSvcParams = state
                    hostname_params[params.hostname] = params
                    wan_interface_ipv4_address = params.wan_interface_ipv4_address
                    if wan_interface_ipv4_address is not None:
                        wan_interface_ipv4_address_params[wan_interface_ipv4_address] = params
                    lan_interface_ipv4_address = params.lan_interface_ipv4_address
                    if lan_interface_ipv4_address is not None:
                        lan_interface_ipv4_address_params[lan_interface_ipv4_address] = params
                else:
                    old_params = try_pop(site_access_path_params, site_access_path_key)
                    if old_params is not None:
                        try_pop(hostname_params, old_params.hostname)
                        wan_interface_ipv4_address = old_params.wan_interface_ipv4_address
                        if wan_interface_ipv4_address is not None:
                            try_pop(wan_interface_ipv4_address_params, wan_interface_ipv4_address)
                        lan_interface_ipv4_address = old_params.lan_interface_ipv4_address
                        if lan_interface_ipv4_address is not None:
                            try_pop(lan_interface_ipv4_address_params, lan_interface_ipv4_address)

    def _on_config_cache_error(e):
        print("ietf.l3vpn_svc - CdbCache failed:", optional_str(e.error_message, ""))
        # TODO

    cdb_connection = telemetrify.nsoapi.cdb.CdbConnection(env, 4569, "telemetrify",
        action lambda c: _on_cdb_sub_connect(c, shared_schema), _on_cdb_connect_error, None)

class HostnameRefiner(PassthroughRefiner):
    def __init__(self):
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([
            PTag('l3vpn-svc', 'l3vpn-svc'),
            PTag('l3vpn-svc', 'sites'),
            PTag('l3vpn-svc', 'site'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'site-network-accesses'),
            PTag('l3vpn-svc', 'site-network-access'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'vars'),
            PTag('l3vpn-svc', 'hostname')
            ]), SUB_TYPE_OPERATIONAL), False)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 4002

class VpnIdRefiner(PassthroughRefiner):
    def __init__(self):
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([
            PTag('l3vpn-svc', 'l3vpn-svc'),
            PTag('l3vpn-svc', 'sites'),
            PTag('l3vpn-svc', 'site'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'site-network-accesses'),
            PTag('l3vpn-svc', 'site-network-access'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'vpn-attachment'),
            PTag('l3vpn-svc', 'vpn-id')
            ]), SUB_TYPE_RUNNING), False)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 4003

class DeviceReferenceRefiner(PassthroughRefiner):
    def __init__(self):
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([
            PTag('l3vpn-svc', 'l3vpn-svc'),
            PTag('l3vpn-svc', 'sites'),
            PTag('l3vpn-svc', 'site'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'site-network-accesses'),
            PTag('l3vpn-svc', 'site-network-access'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'device-reference'),
            ]), SUB_TYPE_RUNNING), False)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 4004

class WanInterfaceIPv4AddressRefiner(PassthroughRefiner):
    def __init__(self):
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([
            PTag('l3vpn-svc', 'l3vpn-svc'),
            PTag('l3vpn-svc', 'sites'),
            PTag('l3vpn-svc', 'site'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'site-network-accesses'),
            PTag('l3vpn-svc', 'site-network-access'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'vars'),
            PTag('l3vpn-svc', 'wan-interface'),
            PTag('l3vpn-svc', 'ipv4-address')
            ]), SUB_TYPE_OPERATIONAL), False)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 4005

class LanInterfaceIPv4AddressRefiner(PassthroughRefiner):
    def __init__(self):
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([
            PTag('l3vpn-svc', 'l3vpn-svc'),
            PTag('l3vpn-svc', 'sites'),
            PTag('l3vpn-svc', 'site'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'site-network-accesses'),
            PTag('l3vpn-svc', 'site-network-access'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'vars'),
            PTag('l3vpn-svc', 'lan-interface'),
            PTag('l3vpn-svc', 'ipv4-address')
            ]), SUB_TYPE_OPERATIONAL), False)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 4006


class IpPerformanceBidirectionalRefiner(PassthroughRefiner):
    def __init__(self):
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([
            PTag('dt-l3vpn-svc', 'ip-performance'),
            PTag('dt-l3vpn-svc', 'vpn-service'),
            Key.wildcard(),
            PTag('dt-l3vpn-svc', 'monitor-endpoint'),
            Key.wildcard(),
            PTag('dt-l3vpn-svc', 'bidirectional')
            ]), SUB_TYPE_RUNNING), False)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 4008

class CustomerNameRefiner(PassthroughRefiner):
    def __init__(self):
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([
            PTag('l3vpn-svc', 'l3vpn-svc'),
            PTag('l3vpn-svc', 'vpn-services'),
            PTag('l3vpn-svc', 'vpn-service'),
            Key.wildcard(),
            PTag('l3vpn-svc', 'customer-name'),
            ]), SUB_TYPE_RUNNING), False)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 4009

class L3vpnSvcParams(object):
    @property
    hostname: str
    @property
    vpn_id: str
    @property
    site_id: str
    @property
    device_reference: str
    @property
    wan_interface_ipv4_address: ?IPv4Address
    @property
    lan_interface_ipv4_address: ?IPv4Address
    @property
    is_bidirectional: ?bool
    @property
    customer_name: ?str

    def __init__(
            self,
            hostname: str,
            vpn_id: str,
            site_id: str,
            device_reference: str,
            wan_interface_ipv4_address: ?IPv4Address,
            lan_interface_ipv4_address: ?IPv4Address,
            is_bidirectional: ?bool,
            customer_name: ?str):
        self.hostname = hostname
        self.vpn_id = vpn_id
        self.site_id = site_id
        self.device_reference = device_reference
        self.wan_interface_ipv4_address = wan_interface_ipv4_address
        self.lan_interface_ipv4_address = lan_interface_ipv4_address
        self.is_bidirectional = is_bidirectional
        self.customer_name = customer_name

    def __str__(self) -> str:
        return "L3vpnSvcParams(" \
            + self.hostname \
            + ", " + self.vpn_id \
            + ", " + self.site_id \
            + ", " + self.device_reference \
            + ", " + optional_str(self.wan_interface_ipv4_address, "None") \
            + ", " + optional_str(self.lan_interface_ipv4_address, "None") \
            + ", " + optional_str(self.is_bidirectional, "None") \
            + ", " + optional_str(self.customer_name, "None") \
            + ")"

class L3vpnSvcParamsRefiner(Refiner):
    @property
    params_by_site_access_path_key: dict[Keypath, L3vpnSvcParams]
    @property
    site_access_path_key_by_monitor_endpoint_path_key: BiDict[Keypath, Keypath]
    @property
    site_access_path_key_by_vpn_service_path_key: BiDict[Keypath, Keypath]

    def __init__(self):
        self.priority = 0
        self.subscription_dependencies = [
            ]
        self.refiner_dependencies = [
                HostnameRefiner.id(),
                VpnIdRefiner.id(),
                DeviceReferenceRefiner.id(),
                WanInterfaceIPv4AddressRefiner.id(),
                LanInterfaceIPv4AddressRefiner.id(),
                IpPerformanceBidirectionalRefiner.id(),
                CustomerNameRefiner.id()
            ]
        self.params_by_site_access_path_key = {}
        self.site_access_path_key_by_monitor_endpoint_path_key = BiDict()
        self.site_access_path_key_by_vpn_service_path_key = BiDict()

    @staticmethod
    def id() -> int:
        return 4010

    def update(self, root: TNode, input_subs: dict[SubscriptionIdentity, list[Keypath]], input_refiners: dict[int, (Refiner, list[Keypath])]) -> list[Keypath]:
        #print("ietf.l3vpn_svc - root:\n" + str(root))

        _hostname_refiner, hostname_keys = input_refiners[HostnameRefiner.id()]
        _vpn_id_refiner, vpn_id_keys = input_refiners[VpnIdRefiner.id()]
        _device_ref_refiner, device_ref_keys = input_refiners[DeviceReferenceRefiner.id()]
        _wan_address_refiner, wan_address_keys = input_refiners[WanInterfaceIPv4AddressRefiner.id()]
        _lan_address_refiner, lan_address_keys = input_refiners[LanInterfaceIPv4AddressRefiner.id()]
        bidirectional_refiner, bidirectional_keys = input_refiners[IpPerformanceBidirectionalRefiner.id()]
        customer_name_refiner, customer_name_keys = input_refiners[CustomerNameRefiner.id()]

        site_access_path_keys: set[Keypath] = set(hostname_keys + vpn_id_keys + device_ref_keys + wan_address_keys + lan_address_keys)

        for monitor_endpoint_path_key in bidirectional_keys:
            #site_access_path_key = self.site_access_path_key_by_monitor_endpoint_path_key.try_get_val(monitor_endpoint_path_key) # actonc codegen error
            site_access_path_key = BiDict.try_get_val(self.site_access_path_key_by_monitor_endpoint_path_key, monitor_endpoint_path_key)
            if site_access_path_key is not None:
                site_access_path_keys.add(site_access_path_key)
            _state = bidirectional_refiner.state(monitor_endpoint_path_key)
            if _state is None:
                #self.site_access_path_key_by_monitor_endpoint_path_key.try_pop_val(monitor_endpoint_path_key)
                BiDict.try_pop_val(self.site_access_path_key_by_monitor_endpoint_path_key, monitor_endpoint_path_key)

        for vpn_service_path_key in customer_name_keys:
            #site_access_path_key = self.site_access_path_key_by_vpn_service_path_key.try_get_val(vpn_service_path_key) # actonc codegen error
            site_access_path_key = BiDict.try_get_val(self.site_access_path_key_by_vpn_service_path_key, vpn_service_path_key)
            if site_access_path_key is not None:
                site_access_path_keys.add(site_access_path_key)
            _state = customer_name_refiner.state(vpn_service_path_key)
            if _state is None:
                #self.site_access_path_key_by_vpn_service_path_key.try_pop_val(vpn_service_path_key) # actonc codegen error
                BiDict.try_pop_val(self.site_access_path_key_by_vpn_service_path_key, vpn_service_path_key)

        prefix = 'l3vpn-svc'
        dt_prefix = 'dt-l3vpn-svc'

        for site_access_path_key in site_access_path_keys:
            params: ?L3vpnSvcParams = None

            site_key: ?Key = site_access_path_key.try_get_key(0)
            site_network_access_key: ?Key = site_access_path_key.try_get_key(1)
            if site_key is not None and site_network_access_key is not None:
                _site_elem = root[PTag(prefix, 'l3vpn-svc')][PTag(prefix, 'sites')][PTag(prefix, 'site')][site_key]
                _site_network_access_elem = _site_elem[PTag(prefix, 'site-network-accesses')][PTag(prefix, 'site-network-access')][site_network_access_key]
                if _site_network_access_elem.exists():
                    site_id = site_key[0]
                    if isinstance(site_id, str):
                        _vars = _site_network_access_elem[PTag(prefix, 'vars')]
                        hostname: ?str = _vars[PTag(prefix, 'hostname')].try_str()
                        vpn_id: ?str = _site_network_access_elem[PTag(prefix, 'vpn-attachment')][PTag(prefix, 'vpn-id')].try_str()
                        device_reference: ?str = _site_network_access_elem[PTag(prefix, 'device-reference')].try_str()
                        if hostname is not None and vpn_id is not None and device_reference is not None:
                            wan_interface_ipv4_address: ?IPv4Address = _vars[PTag(prefix, 'wan-interface')][PTag(prefix, 'ipv4-address')].try_ipv4address()
                            lan_interface_ipv4_address: ?IPv4Address = _vars[PTag(prefix, 'lan-interface')][PTag(prefix, 'ipv4-address')].try_ipv4address()

                            # is_bidirectional
                            _vpn_service = root[PTag(dt_prefix, 'ip-performance')][PTag(dt_prefix, 'vpn-service')][Key([vpn_id])]
                            is_bidirectional: ?bool = \
                                _vpn_service[PTag(dt_prefix, 'monitor-endpoint')][Key([hostname])][PTag(dt_prefix, 'bidirectional')].try_bool()

                            # customer_name
                            _vpn_service = root[PTag(prefix, 'l3vpn-svc')][PTag(prefix, 'vpn-services')][PTag(prefix, 'vpn-service')][Key([vpn_id])]
                            customer_name: ?str = \
                                _vpn_service[PTag(prefix, 'customer-name')].try_str()

                            params = L3vpnSvcParams(
                                hostname,
                                vpn_id,
                                site_id,
                                device_reference,
                                wan_interface_ipv4_address,
                                lan_interface_ipv4_address,
                                is_bidirectional,
                                customer_name)

            old_params = try_pop(self.params_by_site_access_path_key, site_access_path_key)
            if old_params is not None:
                # self.site_access_path_key_by_monitor_endpoint_path_key.try_pop_key(site_access_path_key) # actonc codegen error
                BiDict.try_pop_key(self.site_access_path_key_by_monitor_endpoint_path_key, site_access_path_key)
                # self.site_access_path_key_by_vpn_service_path_key.try_pop_key(site_access_path_key) # actonc codegen error
                BiDict.try_pop_key(self.site_access_path_key_by_vpn_service_path_key, site_access_path_key)

            if params is not None:
                self.params_by_site_access_path_key[site_access_path_key] = params

                monitor_endpoint_path_key = Keypath([Key([params.vpn_id]), Key([params.hostname])])
                #self.site_access_path_key_by_monitor_endpoint_path_key.set(monitor_endpoint_path_key, site_access_path_key) # actonc codegen error
                BiDict.set(self.site_access_path_key_by_monitor_endpoint_path_key, monitor_endpoint_path_key, site_access_path_key)

                vpn_service_path_key = Keypath([Key([params.vpn_id])])
                #self.site_access_path_key_by_vpn_service_path_key.set(vpn_service_path_key, site_access_path_key) # actonc codegen error
                BiDict.set(self.site_access_path_key_by_vpn_service_path_key, vpn_service_path_key, site_access_path_key)

        return list(iter(site_access_path_keys))

    def state(self, keys: Keypath) -> ?value:
        return try_get(self.params_by_site_access_path_key, keys)
