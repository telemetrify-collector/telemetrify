# Copyright (C) Deutsche Telekom AG
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

from telemetrify.common.mod import *
from telemetrify.common.utils import *
from telemetrify.nso.subscriber import Refiner, PassthroughRefiner, MirrorRefiner, SubscriptionSpec, SubscriptionIdentity, SUB_TYPE_RUNNING

class DeviceSettings(object):
    @property
    username: ?str
    @property
    password: ?str

    def __init__(self, username: ?str, password: ?str):
        self.username = username
        self.password = password

    def __str__(self) -> str:
        return "DeviceSettings(username=" + optional_str(self.username, "") + ", password=" + optional_str(self.password, "") + ")"

    def __repr__(self):
        return self.__str__()

class DeviceSettingsRefiner(Refiner):
    @property
    _device_authgroup: dict[Keypath, Keypath]
    @property
    _authgroup_configs: dict[Keypath, DeviceSettings]
    @property
    _authgroup_devices: dict[Keypath, set[Keypath]]

    def __init__(self):
        Refiner.__init__(
            self,
            [
                SubscriptionSpec(SubscriptionIdentity(Keypath([PTag('ncs', 'devices'), PTag('ncs', 'authgroups'), PTag('ncs', 'group'), Key.wildcard()]), SUB_TYPE_RUNNING), True),
                SubscriptionSpec(SubscriptionIdentity(Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('ncs', 'authgroup')]), SUB_TYPE_RUNNING), True),
                #SubscriptionSpec(SubscriptionIdentity(Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('ncs', 'address')]), SUB_TYPE_RUNNING), True),
                #SubscriptionSpec(SubscriptionIdentity(Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('ncs', 'port')]), SUB_TYPE_RUNNING), True),
                #SubscriptionSpec(SubscriptionIdentity(Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('ncs', 'netconf'), PTag('ncs', 'ned-id')]), SUB_TYPE_RUNNING), True)
            ],
            [])

        self._device_authgroup = {}
        self._authgroup_configs = {}
        self._authgroup_devices = {}

    @staticmethod
    def id() -> int:
        return 1001

    def update(self, root: TNode, input_subs: dict[SubscriptionIdentity, list[Keypath]], input_refiners: dict[int, (Refiner, list[Keypath])]) -> list[Keypath]:
        # for subpath, keypaths in input_subs.items():
        #     print(str(subpath) + ":")
        #     for keypath in keypaths:
        #         print("  " + str(keypath))
        updated: set[Keypath] = set([])

        updated_authgroups = input_subs[self.subscription_dependencies[0].identity]
        if updated_authgroups is not None:
            for authgroup_keys in updated_authgroups:
                authgroup_key: ?Key = authgroup_keys.try_get_key(0)
                if authgroup_key is not None:
                    default_map = root[PTag("ncs", "devices")][PTag("ncs", "authgroups")][PTag('ncs', 'group')][authgroup_key][PTag('ncs', 'default-map')]
                    if default_map.exists():
                        username = default_map[PTag('ncs', 'remote-name')].try_str()
                        password = default_map[PTag('ncs', 'remote-password')].try_str()
                        authconfig = DeviceSettings(username, password)
                        self._authgroup_configs[authgroup_keys] = authconfig
                    else:
                        try_pop(self._authgroup_configs, authgroup_keys)
                    set_update(updated, self._authgroup_devices.get(authgroup_keys, set([])))

        updated_device_authgroup = input_subs[self.subscription_dependencies[1].identity]
        if updated_device_authgroup is not None:
            for device_keys in updated_device_authgroup:
                device_key: ?Key = device_keys.try_get_key(0)
                if device_key is not None:
                    authgroup_name: ?str = root[PTag("ncs", "devices")][PTag("ncs", "device")][device_key][PTag('ncs', 'authgroup')].try_str()
                    if authgroup_name is not None:
                        authgroup_keys = Keypath([Key([authgroup_name])])
                        self._device_authgroup[device_keys] = authgroup_keys
                        dict_set_add(self._authgroup_devices, authgroup_keys, device_keys)
                    else:
                        authgroup_keys = try_pop(self._device_authgroup, device_keys)
                        if authgroup_keys is not None:
                            dict_set_discard(self._authgroup_devices, authgroup_keys, device_keys)
                    updated.add(device_keys)

        #print("UPDATED: " + list_str(list(iter(updated))))

        return list(iter(updated))

    def state(self, keys: Keypath) -> ?value:
        authgroup_keys = try_get(self._device_authgroup, keys)
        if authgroup_keys is not None:
            return try_get(self._authgroup_configs, authgroup_keys)
        return None

class DeviceNedIdBaseRefiner(MirrorRefiner):
    @property
    _workaround_actonc_issue_1598: bool

    def __init__(self):
        self._workaround_actonc_issue_1598 = True # https://github.com/actonlang/acton/issues/1598
        MirrorRefiner.__init__(self,
            [
                SubscriptionSpec(SubscriptionIdentity(Keypath([
                    PTag('ncs', 'devices'),
                    PTag('ncs', 'device'),
                    Key.wildcard(),
                    PTag('ncs', 'device-type'),
                    PTag('ncs', 'netconf'),
                    PTag('ncs', 'ned-id'),
                    ]),
                    SUB_TYPE_RUNNING), True),
                SubscriptionSpec(SubscriptionIdentity(Keypath([
                    PTag('ncs', 'devices'),
                    PTag('ncs', 'device'),
                    Key.wildcard(),
                    PTag('ncs', 'device-type'),
                    PTag('ncs', 'generic'),
                    PTag('ncs', 'ned-id'),
                    ]),
                    SUB_TYPE_RUNNING), True),
                SubscriptionSpec(SubscriptionIdentity(Keypath([
                    PTag('ncs', 'devices'),
                    PTag('ncs', 'device'),
                    Key.wildcard(),
                    PTag('ncs', 'device-type'),
                    PTag('ncs', 'cli'),
                    PTag('ncs', 'ned-id'),
                    ]),
                    SUB_TYPE_RUNNING), True),
                SubscriptionSpec(SubscriptionIdentity(Keypath([
                    PTag('ncs', 'devices'),
                    PTag('ncs', 'device'),
                    Key.wildcard(),
                    PTag('ncs', 'device-type'),
                    PTag('ncs', 'snmp'),
                    PTag('ncs', 'ned-id'),
                    ]),
                    SUB_TYPE_RUNNING), True),

                SubscriptionSpec(SubscriptionIdentity(Keypath([
                    PTag('ncs', 'devices'),
                    PTag('ncs', 'device'),
                    Key.wildcard(),
                    PTag('ncs', 'live-status-protocol'),
                    Key.wildcard(),
                    PTag('ncs', 'device-type'),
                    PTag('ncs', 'netconf'),
                    PTag('ncs', 'ned-id'),
                    ]),
                    SUB_TYPE_RUNNING), True),
                SubscriptionSpec(SubscriptionIdentity(Keypath([
                    PTag('ncs', 'devices'),
                    PTag('ncs', 'device'),
                    Key.wildcard(),
                    PTag('ncs', 'live-status-protocol'),
                    Key.wildcard(),
                    PTag('ncs', 'device-type'),
                    PTag('ncs', 'generic'),
                    PTag('ncs', 'ned-id'),
                    ]),
                    SUB_TYPE_RUNNING), True),
                SubscriptionSpec(SubscriptionIdentity(Keypath([
                    PTag('ncs', 'devices'),
                    PTag('ncs', 'device'),
                    Key.wildcard(),
                    PTag('ncs', 'live-status-protocol'),
                    Key.wildcard(),
                    PTag('ncs', 'device-type'),
                    PTag('ncs', 'cli'),
                    PTag('ncs', 'ned-id'),
                    ]),
                    SUB_TYPE_RUNNING), True),
                SubscriptionSpec(SubscriptionIdentity(Keypath([
                    PTag('ncs', 'devices'),
                    PTag('ncs', 'device'),
                    Key.wildcard(),
                    PTag('ncs', 'live-status-protocol'),
                    Key.wildcard(),
                    PTag('ncs', 'device-type'),
                    PTag('ncs', 'snmp'),
                    PTag('ncs', 'ned-id'),
                    ]),
                    SUB_TYPE_RUNNING), True)
            ],
            Keypath([
                PTag('ncs', 'devices'),
                PTag('ncs', 'device'),
                Key.wildcard()
                ])
            )

    @staticmethod
    def id() -> int:
        return 1012

class DeviceSourceNetconfRefiner(PassthroughRefiner):
    def __init__(self):
        #super().__init__([Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('tlm', 'telemetrify'), PTag('tlm', 'sources'), PTag('tlm', 'netconf')])]))
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('tlm', 'telemetrify'), PTag('tlm', 'sources'), PTag('tlm', 'netconf')]), SUB_TYPE_RUNNING), True)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 1002

class DeviceSourceVmanageRefiner(PassthroughRefiner):
    def __init__(self):
        #super().__init__([Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('tlm', 'telemetrify'), PTag('tlm', 'sources'), PTag('tlm', 'netconf')])]))
        self.priority = 0
        self.subscription_dependencies = [SubscriptionSpec(SubscriptionIdentity(Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('tlm', 'telemetrify'), PTag('tlm', 'sources'), PTag('tlm', 'vmanage-http')]), SUB_TYPE_RUNNING), True)]
        self.refiner_dependencies = []
        self.subtrees = {}

    @staticmethod
    def id() -> int:
        return 1019


SOURCE_KEY_NETCONF = Keypath([Key(['netconf'])])
SOURCE_KEY_VMANAGE_HTTP = Keypath([Key(['vmanage-http'])])

SUBSCRIPTION_TYPE_KEY_ACTION_POLLER = PTag('tlm', 'netconf-rpc-poll')
SUBSCRIPTION_TYPE_KEY_GET_POLLER = PTag('tlm', 'netconf-get-poll')
SUBSCRIPTION_TYPE_KEY_VMANAGE_POLLER = PTag('tlm', 'vmanage-poll')

_SUBSCRIPTION_TYPE_SOURCE_LOOKUP = {
    SUBSCRIPTION_TYPE_KEY_ACTION_POLLER: SOURCE_KEY_NETCONF,
    SUBSCRIPTION_TYPE_KEY_GET_POLLER: SOURCE_KEY_NETCONF,
    SUBSCRIPTION_TYPE_KEY_VMANAGE_POLLER: SOURCE_KEY_VMANAGE_HTTP
}

class DeviceSourceRefiner(Refiner):
    @property
    device_source_configs: dict[Keypath, dict[Keypath, TNode]]
    @property
    device_source_subs: dict[Keypath, set[Keypath]]
    @property
    device_sub_sources: dict[Keypath, Keypath]

    def __init__(self):
        Refiner.__init__(
            self,
            [],
            [
                DeviceSubscriptionSourceRefiner.id(),
                DeviceSourceNetconfRefiner.id(),
                DeviceSourceVmanageRefiner.id(),
            ])

        self.device_source_configs = {}
        self.device_source_subs = {}
        self.device_sub_sources = {}

    @staticmethod
    def id() -> int:
        return 1003

    def update(self, root: TNode, input_subs: dict[SubscriptionIdentity, list[Keypath]], input_refiners: dict[int, (Refiner, list[Keypath])]) -> list[Keypath]:
        updated: set[Keypath] = set([])

        dev_sub_source_refiner, dev_sub_keys = input_refiners[DeviceSubscriptionSourceRefiner.id()]

        for dev_sub_key in dev_sub_keys:
            dev_key = dev_sub_key.try_slice(0, 1)
            sub_key = dev_sub_key.try_slice(1, 2)
            if dev_key is not None and sub_key is not None:
                source_key: ?Keypath = None

                state = dev_sub_source_refiner.state(dev_sub_key)
                if state is not None and isinstance(state, TNode):
                    sub_source_node: TNode = state
                    for sub_type_id in sub_source_node.iter_ids():
                        try:
                            source_key = _SUBSCRIPTION_TYPE_SOURCE_LOOKUP[sub_type_id]
                        except KeyError:
                            raise ValueError("Missing _SUBSCRIPTION_TYPE_SOURCE_LOOKUP entry for: " + str(sub_type_id))
                        else:
                            break

                if source_key is not None:
                    dev_source_key = dev_key + source_key
                    if dev_source_key not in self.device_source_subs:
                        updated.add(dev_source_key)
                    dict_set_add(self.device_source_subs, dev_source_key, sub_key)
                    self.device_sub_sources[dev_sub_key] = source_key
                else:
                    source_key = try_pop(self.device_sub_sources, dev_sub_key)
                    if source_key is not None:
                        dev_source_key = dev_key + source_key
                        dict_set_discard(self.device_source_subs, dev_source_key, sub_key)
                        if dev_source_key not in self.device_source_subs:
                            updated.add(dev_source_key)

        source_deps = [
            (SOURCE_KEY_NETCONF, input_refiners[DeviceSourceNetconfRefiner.id()]),
            (SOURCE_KEY_VMANAGE_HTTP, input_refiners[DeviceSourceVmanageRefiner.id()]),
        ]

        for source_key, (source_refiner, device_keys) in source_deps:
            for device_key in device_keys:
                state = source_refiner.state(device_key)
                if state is not None and isinstance(state, TNode):
                    updated.add(device_key + source_key)
                    sources = get_or_create(self.device_source_configs, device_key, lambda: {})
                    sources[source_key] = state
                else:
                    sources = try_get(self.device_source_configs, device_key)
                    if sources is not None:
                        source = try_pop(sources, source_key)
                        if source is not None:
                            updated.add(device_key + source_key)
                            if not sources:
                                del self.device_source_configs[device_key]

        return list(iter(updated))

    def state(self, keys: Keypath) -> ?value:
        if keys in self.device_source_subs:
            device_key = keys.try_slice(0, 1)
            source_key = keys.try_slice(1, 2)
            if device_key is not None and source_key is not None:
                sources = try_get(self.device_source_configs, device_key)
                if sources is not None:
                    return try_get(sources, source_key)
        return None

class DeviceStreamerConfig(object):
    @property
    device_settings: ?DeviceSettings

    def __init__(self, auth: ?DeviceSettings):
        self.auth = auth

    def __str__(self) -> str:
        return "DeviceStreamerConfig(" + optional_str(self.device_settings, "None") + ")"

    def __repr__(self):
        return self.__str__()

class DeviceStreamerRefiner(Refiner):
    @property
    device_configs: dict[Keypath, DeviceStreamerConfig]

    def __init__(self):
        Refiner.__init__(
            self,
            [
                #SubscriptionSpec(SubscriptionIdentity(Keypath([PTag('ncs', 'devices'), PTag('ncs', 'device'), Key.wildcard(), PTag('tlm', 'telemetrify')]), SUB_TYPE_RUNNING), True)
            ],
            [
                DeviceSubscriptionSourceRefiner.id(),
                DeviceSettingsRefiner.id()
            ])

        self.device_configs = {}

    @staticmethod
    def id() -> int:
        return 1004

    def update(self, root: TNode, input_subs: dict[SubscriptionIdentity, list[Keypath]], input_refiners: dict[int, (Refiner, list[Keypath])]) -> list[Keypath]:
        updated: set[Keypath] = set([])

        sub_refiner, sub_keys = input_refiners[DeviceSubscriptionSourceRefiner.id()]
        device_settings_refiner, device_settings_keys = input_refiners[DeviceSettingsRefiner.id()]

        update_device_settings_keys = set(device_settings_keys)

        for sub_key in sub_keys:
            device_key = sub_key.try_slice(0, 1)
            if device_key is not None:
                subscriptions_node = root[PTag('ncs', 'devices')][PTag('ncs', 'device')][device_key[0]][PTag('tlm', 'telemetrify')][PTag('tlm', 'subscription')]
                if subscriptions_node:
                    if device_key not in self.device_configs:
                        self.device_configs[device_key] = DeviceStreamerConfig(None)
                        update_device_settings_keys.add(device_key)
                        updated.add(device_key)
                else:
                    try_pop(self.device_configs, device_key)
                    updated.add(device_key)

        for device_key in update_device_settings_keys:
            device_config = try_get(self.device_configs, device_key)
            if device_config is not None:
                _device_settings = device_settings_refiner.state(device_key)
                device_config.device_settings = _device_settings if _device_settings is not None and isinstance(_device_settings, DeviceSettings) else None
                updated.add(device_key)

        return list(iter(updated))

    def state(self, keys: Keypath) -> ?value:
        return try_get(self.device_configs, keys)

class SchemaSettings(object):
    @property
    config_ned_id: ?HTag
    @property
    live_status_ned_id: ?HTag

    def __init__(self, config_ned_id: ?HTag, live_status_ned_id: ?HTag):
        self.config_ned_id = config_ned_id
        self.live_status_ned_id = live_status_ned_id

    def __str__(self) -> str:
        return self.__repr__()

    def __repr__(self):
        return "SchemaSettings(" + optional_str(self.config_ned_id, "None") + ", " + optional_str(self.live_status_ned_id, "None") + ")"

    @staticmethod
    def from_device_config_and_schema_config(device_config: TNode, schema_config: TNode) -> SchemaSettings:
        ned_id = SchemaSettings._get_schema_config_ned_id(schema_config)
        if ned_id is not None:
            return SchemaSettings(ned_id, ned_id)

        base_ned_id = SchemaSettings._get_device_type_ned_id(device_config)
        live_ned_id = base_ned_id

        # TODO: How to (and do we want to) handle multiple live-status-protocol ned-ids?
        # For now we require schema-setting override in case of many...
        for live_status_protocol_elem in device_config[PTag('ncs', 'live-status-protocol')]:
            _ned_id = SchemaSettings._get_device_type_ned_id(live_status_protocol_elem)
            if _ned_id is not None:
                live_ned_id = _ned_id
                break

        return SchemaSettings(base_ned_id, live_ned_id)

    @staticmethod
    def _get_device_type_ned_id(base_node: TNode) -> ?HTag:
        device_type_node = base_node[PTag('ncs', 'device-type')]
        ned_id: ?HTag = None
        ned_id = device_type_node[PTag('ncs', 'netconf')][PTag('ncs', 'ned-id')].try_htag()
        if ned_id is not None:
            return ned_id
        ned_id = device_type_node[PTag('ncs', 'generic')][PTag('ncs', 'ned-id')].try_htag()
        if ned_id is not None:
            return ned_id
        ned_id = device_type_node[PTag('ncs', 'cli')][PTag('ncs', 'ned-id')].try_htag()
        if ned_id is not None:
            return ned_id
        ned_id = device_type_node[PTag('ncs', 'snmp')][PTag('ncs', 'ned-id')].try_htag()
        if ned_id is not None:
            return ned_id
        return None

    @staticmethod
    def _get_schema_config_ned_id(base_node: TNode) -> ?HTag:
        return base_node[PTag('tlm', 'ned-id')].try_htag()

class SubscriptionSourceConfig(object):
    @property
    config: TNode
    @property
    schema_settings: SchemaSettings

    def __init__(self, config: TNode, schema_settings: SchemaSettings):
        self.config = config
        self.schema_settings = schema_settings

    def __str__(self) -> str:
        return "SubscriptionSourceConfig(config=" + optional_str(self.config, "") + ", schema_settings=" + optional_str(self.schema_settings, "") + ")"

    def __repr__(self):
        return self.__str__()

class DeviceSubscriptionSourceRefiner(Refiner):
    @property
    subscription_source_configs: dict[Keypath, SubscriptionSourceConfig]
    @property
    device_to_dev_sub_keys: dict[Keypath, set[Keypath]]

    def __init__(self):
        Refiner.__init__(
            self,
            [],
            [
                DeviceSubscriptionSourceBaseRefiner.id(),
                DeviceNedIdBaseRefiner.id()
            ])

        self.subscription_source_configs = {}
        self.device_to_dev_sub_keys = {}

    @staticmethod
    def id() -> int:
        return 1014

    def update(self, root: TNode, input_subs: dict[SubscriptionIdentity, list[Keypath]], input_refiners: dict[int, (Refiner, list[Keypath])]) -> list[Keypath]:
        _sub_refiner, dev_sub_keys = input_refiners[DeviceSubscriptionSourceBaseRefiner.id()]
        _ned_id_refiner, ned_id_keys = input_refiners[DeviceNedIdBaseRefiner.id()]

        updated: set[Keypath] = set(dev_sub_keys)

        for device_key in ned_id_keys:
            _dev_sub_keys = try_get(self.device_to_dev_sub_keys, device_key)
            if _dev_sub_keys is not None:
                set_update(updated, _dev_sub_keys)

        for dev_sub_key in updated:
            device_key = dev_sub_key.try_slice(0, 1)
            sub_key = dev_sub_key.try_slice(1, 2)
            if device_key is not None and sub_key is not None:
                device_config = root[PTag('ncs', 'devices')][PTag('ncs', 'device')][device_key[0]]
                subscription_source_node = device_config[PTag('tlm', 'telemetrify')][PTag('tlm', 'subscription')][sub_key[0]][PTag('tlm', 'source')]
                if subscription_source_node:
                    schema_settings = SchemaSettings.from_device_config_and_schema_config(device_config, subscription_source_node[PTag('tlm', 'schema')])
                    self.subscription_source_configs[dev_sub_key] = SubscriptionSourceConfig(subscription_source_node, schema_settings)
                    dict_set_add(self.device_to_dev_sub_keys, device_key, dev_sub_key)
                else:
                    try_pop(self.subscription_source_configs, dev_sub_key)
                    dict_set_discard(self.device_to_dev_sub_keys, device_key, dev_sub_key)

        return list(iter(updated))

    def state(self, keys: Keypath) -> ?value:
        return try_get(self.subscription_source_configs, keys)

class DeviceSubscriptionSourceBaseRefiner(PassthroughRefiner):
    @property
    _workaround_actonc_issue_1598: bool

    def __init__(self):
        self._workaround_actonc_issue_1598 = True # https://github.com/actonlang/acton/issues/1598
        PassthroughRefiner.__init__(
            self,
            SubscriptionSpec(SubscriptionIdentity(Keypath([
                PTag('ncs', 'devices'),
                PTag('ncs', 'device'),
                Key.wildcard(),
                PTag('tlm', 'telemetrify'),
                PTag('tlm', 'subscription'),
                Key.wildcard(),
                PTag('tlm', 'source')
                ]),
                SUB_TYPE_RUNNING), True)
            )

    @staticmethod
    def id() -> int:
        return 1005

class DeviceSubscriptionSinkBaseRefiner(PassthroughRefiner):
    @property
    _workaround_actonc_issue_1598: bool

    def __init__(self):
        self._workaround_actonc_issue_1598 = True # https://github.com/actonlang/acton/issues/1598
        PassthroughRefiner.__init__(
            self,
            SubscriptionSpec(SubscriptionIdentity(Keypath([
                PTag('ncs', 'devices'),
                PTag('ncs', 'device'),
                Key.wildcard(),
                PTag('tlm', 'telemetrify'),
                PTag('tlm', 'subscription'),
                Key.wildcard(),
                PTag('tlm', 'sink'),
                Key.wildcard()
                ]),
                SUB_TYPE_RUNNING), True)
            )

    @staticmethod
    def id() -> int:
        return 1006

class SinkRefiner(PassthroughRefiner):
    @property
    _workaround_actonc_issue_1598: bool

    def __init__(self):
        self._workaround_actonc_issue_1598 = True # https://github.com/actonlang/acton/issues/1598
        PassthroughRefiner.__init__(
            self,
            SubscriptionSpec(SubscriptionIdentity(Keypath([
                PTag('tlm', 'telemetrify'),
                PTag('tlm', 'sink'),
                Key.wildcard()
                ]),
            SUB_TYPE_RUNNING), True)
        )

    @staticmethod
    def id() -> int:
        return 1007

class DeviceSinksRefiner(Refiner):
    # @property
    # device_sinks: dict[Keypath, TNode]
    @property
    sinks: dict[Keypath, value]
    @property
    device_sink_subs: dict[Keypath, dict[Keypath, set[Keypath]]]
    @property
    sink_devices: dict[Keypath, set[Keypath]]

    def __init__(self):
        Refiner.__init__(
            self,
            [],
            [
                DeviceSubscriptionSinkBaseRefiner.id(),
                SinkRefiner.id()
            ])

        self.sinks = {}
        self.device_sink_subs = {}
        self.sink_devices = {}

    @staticmethod
    def id() -> int:
        return 1008

    def update(self, root: TNode, input_subs: dict[SubscriptionIdentity, list[Keypath]], input_refiners: dict[int, (Refiner, list[Keypath])]) -> list[Keypath]:
        updated: set[Keypath] = set([])

        dev_sub_sink_refiner, dev_sub_sink_keys = input_refiners[DeviceSubscriptionSinkBaseRefiner.id()]
        sink_refiner, sink_keys = input_refiners[SinkRefiner.id()]

        for dev_sub_sink_key in dev_sub_sink_keys:
            device_key = dev_sub_sink_key.try_slice(0, 1)
            sub_key = dev_sub_sink_key.try_slice(1, 2)
            sink_key = dev_sub_sink_key.try_slice(2, 3)
            if device_key is not None and sub_key is not None and sink_key is not None:
                state = dev_sub_sink_refiner.state(dev_sub_sink_key)
                if state is not None:
                    sink_subs = get_or_create(self.device_sink_subs, device_key, lambda: {})
                    if sink_key not in sink_subs:
                        updated.add(device_key + sink_key)
                    get_or_create(sink_subs, sink_key, lambda: set([])).add(sub_key)
                    get_or_create(self.sink_devices, sink_key, lambda: set([])).add(device_key)
                else:
                    sink_subs = try_get(self.device_sink_subs, device_key)
                    if sink_subs is not None:
                        subs = try_get(sink_subs, sink_key)
                        if subs is not None:
                            subs.discard(sub_key)
                            if not subs:
                                del sink_subs[sink_key]
                                dict_set_discard(self.sink_devices, sink_key, device_key)
                                updated.add(device_key + sink_key)
                        if not sink_subs:
                            del self.device_sink_subs[device_key]

        for sink_key in sink_keys:
            state = sink_refiner.state(sink_key)
            if state is not None:
                self.sinks[sink_key] = state
            else:
                try_pop(self.sinks, sink_key)
            updated_devices = try_get(self.sink_devices, sink_key)
            if updated_devices is not None:
                for device_key in updated_devices:
                    updated.add(device_key + sink_key)

        return list(iter(updated))

    def state(self, keys: Keypath) -> ?value:
        device_key = keys.try_slice(0, 1)
        sink_key = keys.try_slice(1, 2)
        if device_key is not None and sink_key is not None:
            devices = try_get(self.sink_devices, sink_key)
            if devices is not None:
                if device_key in devices:
                    return try_get(self.sinks, sink_key)
        return None

# class SubscriptionSinkConfig(object):
#     @property
#     config: TNode
#     @property
#     schema_settings: SchemaSettings

#     def __init__(self, config: TNode, schema_settings: SchemaSettings):
#         self.config = config
#         self.schema_settings = schema_settings

#     def __str__(self) -> str:
#         return "SubscriptionSinkConfig(config=" + optional_str(self.config, "") + ", schema_settings=" + optional_str(self.schema_settings, "") + ")"

#     def __repr__(self):
#         return self.__str__()

class DeviceSubscriptionSinkRefiner(Refiner):
    @property
    dev_sub_sinks: dict[Keypath, TNode]
    @property
    sink_dev_subs: dict[Keypath, set[Keypath]]

    def __init__(self):
        Refiner.__init__(
            self,
            [],
            [
                DeviceSubscriptionSinkBaseRefiner.id(),
                SinkRefiner.id()
            ])

        self.dev_sub_sinks = {}
        self.sink_dev_subs = {}

    @staticmethod
    def id() -> int:
        return 1009

    def update(self, root: TNode, input_subs: dict[SubscriptionIdentity, list[Keypath]], input_refiners: dict[int, (Refiner, list[Keypath])]) -> list[Keypath]:
        updated: set[Keypath] = set([])

        dev_sub_sink_refiner, dev_sub_sink_keys = input_refiners[DeviceSubscriptionSinkBaseRefiner.id()]
        _sink_refiner, sink_keys = input_refiners[SinkRefiner.id()]

        for dev_sub_sink_key in dev_sub_sink_keys:
            device_key = dev_sub_sink_key.try_slice(0, 1)
            sub_key = dev_sub_sink_key.try_slice(1, 2)
            sink_key = dev_sub_sink_key.try_slice(2, 3)
            if device_key is not None and sub_key is not None and sink_key is not None:
                state = dev_sub_sink_refiner.state(dev_sub_sink_key)
                if state is not None and isinstance(state, TNode):
                    self.dev_sub_sinks[dev_sub_sink_key] = state
                    dict_set_add(self.sink_dev_subs, sink_key, device_key + sub_key)
                else:
                    try_pop(self.dev_sub_sinks, dev_sub_sink_key)
                    dict_set_discard(self.sink_dev_subs, sink_key, device_key + sub_key)
                updated.add(dev_sub_sink_key)

        for sink_key in sink_keys:
            dev_sub_keys = try_get(self.sink_dev_subs, sink_key)
            if dev_sub_keys is not None:
                for dev_sub_key in dev_sub_keys:
                    dev_sub_sink_key = dev_sub_key + sink_key
                    updated.add(dev_sub_sink_key)

        return list(iter(updated))

    def state(self, keys: Keypath) -> ?value:
        return try_get(self.dev_sub_sinks, keys)

class LoggingLevelRefiner(PassthroughRefiner):
    @property
    _workaround_actonc_issue_1598: bool

    def __init__(self):
        self._workaround_actonc_issue_1598 = True # https://github.com/actonlang/acton/issues/1598
        PassthroughRefiner.__init__(
            self,
            SubscriptionSpec(SubscriptionIdentity(Keypath([
                PTag('tlm', 'telemetrify'),
                PTag('tlm', 'logging'),
                PTag('tlm', 'level')
                ]),
            SUB_TYPE_RUNNING), True)
        )

    @staticmethod
    def id() -> int:
        return 1101
