# Copyright (C) Deutsche Telekom AG
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import logging

import telemetrify.nso.subscriber
import telemetrify.nsoapi.cdb
import telemetrify.nsoapi.maapi
import telemetrify.nsoapi.schema as schema
import telemetrify.ietf.l3vpn_svc
import telemetrify.ietf.cat8k
import telemetrify.main.sink.m3db
import telemetrify.main.sink.nso
import telemetrify.main.source.netconf
import telemetrify.main.source.vmanage

from telemetrify.common.mod import *
from telemetrify.common.utils import *
from telemetrify.nso.subscriber import *
from telemetrify.nsoapi.cdb import *
from telemetrify.nsoapi.maapi import *
from telemetrify.main.common import *
from telemetrify.main.config import *
import telemetrify.vmanage.transform

actor DeviceStreamer(
        env: Env,
        name: str,
        reached_state_cb: action(int) -> None,
        shared_schema: schema.SharedSchema,
        shared_resources: SharedResources,
        log_handler: ?logging.Handler):

    var logh = logging.Handler("device-streamer")
    if log_handler is not None:
        logh.set_handler(log_handler)

    var log = logging.Logger(logh)

    # var sources_manager: DelegateMiddleManager[Source] = DelegateMiddleManager(on_reached_state, _on_source_reached_state_trampoline)
    # Workaround compiler ordering issue
    var source_manager: DelegateMiddleManager[Source] = DelegateMiddleManager(lambda s: None, lambda i, s: None)
    var subscription_sources: dict[Keypath, Keypath] = {}
    var sinks: dict[Keypath, Sink] = {}

    log.info("DEVICE CREATED", {"name": name})

    def update_config(
            updated_device_config: ?DeviceStreamerConfig,
            subscription_updates: list[(Keypath, ?value)],
            subscription_sink_updates: list[(Keypath, ?value)],
            source_updates: list[(Keypath, ?value)],
            sink_updates: list[(Keypath, ?value)]):

        log.debug("DEVICE CONFIG", {"name": name, "updated_device_config": optional_str(updated_device_config, "None")})

        _subscription_updates = {}
        for k, v in subscription_updates:
            _subscription_updates[str(k)] = str(v) if v is not None else "DELETED"
        log.trace("SUBSCRIPTIONS", _subscription_updates)

        _subscription_sink_updates = {}
        for k, v in subscription_sink_updates:
            _subscription_sink_updates[str(k)] = str(v) if v is not None else "DELETED"
        log.trace("SUBSCRIPTION SINKS", _subscription_sink_updates )

        _source_updates = {}
        for k, v in source_updates:
            _source_updates[str(k)] = str(v) if v is not None else "DELETED"
        log.trace("SOURCES", _source_updates)

        _sink_updates = {}
        for k, v in sink_updates:
            _sink_updates[str(k)] = str(v) if v is not None else "DELETED"
        log.trace("SINKS", _sink_updates)

        source_config_updates: dict[Keypath, TNode] = {}
        updated_source_dev_sub_keys: dict[Keypath, set[Keypath]] = {}
        dev_sub_updates: dict[Keypath, SubscriptionUpdate] = {}

        # Prepare source configs
        for source_key, state in source_updates:
            source_config_updates[source_key] = state if state is not None and isinstance(state, TNode) else tnode_empty()

        # Update sinks
        if sink_updates:
            for sink_key, state in sink_updates:
                _update_sink(sink_key, state)

        # Prepare subscriptions
        for dev_sub_key, state in subscription_updates:
            if state is not None and isinstance(state, SubscriptionSourceConfig):
                config: SubscriptionSourceConfig = state
                source_key = _get_subscription_source_key(config.config)
                subscription_sources[dev_sub_key] = source_key
                sub_update = get_or_create(dev_sub_updates, dev_sub_key, SubscriptionUpdate)
                sub_update.config = config
                dict_set_add(updated_source_dev_sub_keys, source_key, dev_sub_key)
            else:
                source_key = try_pop(subscription_sources, dev_sub_key)
                if source_key is not None:
                    dict_set_add(updated_source_dev_sub_keys, source_key, dev_sub_key)

        # Prepare subscription sinks
        for dev_sub_sink_key, state in subscription_sink_updates:
            dev_sub_key = dev_sub_sink_key.try_slice(0, 2)
            sink_key = dev_sub_sink_key.try_slice(2, 3)
            if dev_sub_key is not None and sink_key is not None:
                if dev_sub_key in subscription_sources:
                    sub_update = get_or_create(dev_sub_updates, dev_sub_key, SubscriptionUpdate)
                    sub_sink: ?SubscriptionSink = None
                    if state is not None and isinstance(state, TNode):
                        sub_sink = _create_subscription_sink(sink_key, state)
                    sub_update.sinks.append((sink_key, sub_sink))

        # Update sources / subscriptions
        for source_key, dev_sub_keys in updated_source_dev_sub_keys.items():
            source_sub_updates: list[(Keypath, ?SubscriptionUpdate)] = []
            for dev_sub_key in dev_sub_keys:
                source_sub_updates.append((dev_sub_key, try_get(dev_sub_updates, dev_sub_key)))

            def _update_fn(s: Source):
                s.update_config(try_get(source_config_updates, source_key), source_sub_updates)
            source = _update_source(source_key, _update_fn)
            if not source.has_subscriptions():
                DelegateMiddleManager_remove_delegate(source_manager, source_key) # https://github.com/actonlang/acton/issues/1448

    def _get_subscription_source_key(config: TNode) -> Keypath:
        if config[SUBSCRIPTION_TYPE_KEY_ACTION_POLLER].exists():
            return SOURCE_KEY_NETCONF
        if config[SUBSCRIPTION_TYPE_KEY_GET_POLLER].exists():
            return SOURCE_KEY_NETCONF
        if config[SUBSCRIPTION_TYPE_KEY_VMANAGE_POLLER].exists():
            return SOURCE_KEY_VMANAGE_HTTP

        raise Exception("Unknown subscription type: " + str(config))

    def _update_source(source_key: Keypath, update_fn: proc(Source) -> None) -> Source:
        _source: ?Source = DelegateMiddleManager_try_get_delegate(source_manager, source_key)
        if _source is not None:
            update_fn(_source)
            return _source
        else:
            if source_key == SOURCE_KEY_NETCONF:
                _id, _reached_state_cb = DelegateMiddleManager_reserve_delegate(source_manager, source_key) # https://github.com/actonlang/acton/issues/1448
                source_act = telemetrify.main.source.netconf.NetconfSource(_reached_state_cb, env.cap, shared_schema, logh)
                source = Source(source_act.set_target_state, source_act.update_config)
                DelegateMiddleManager_add_delegate(source_manager, _id, source, update_fn) # https://github.com/actonlang/acton/issues/1448
                return source

            if source_key == SOURCE_KEY_VMANAGE_HTTP:
                _id, _reached_state_cb = DelegateMiddleManager_reserve_delegate(source_manager, source_key) # https://github.com/actonlang/acton/issues/1448
                source_act = telemetrify.main.source.vmanage.VManageSource(_reached_state_cb, env.cap, shared_schema, logh)
                source = Source(source_act.set_target_state, source_act.update_config)
                DelegateMiddleManager_add_delegate(source_manager, _id, source, update_fn) # https://github.com/actonlang/acton/issues/1448
                return source

        raise Exception("Unknown source type: " + str(source_key))

    def _update_sink(sink_key: Keypath, config: ?value):
        old_sink = try_pop(sinks, sink_key)
        if old_sink is not None:
            old_sink.close()

        if config is not None and isinstance(config, TNode):
            if config[PTag('tlm', 'm3db')].exists():
                sink_act = telemetrify.main.sink.m3db.M3dbSink(env.cap, config, shared_schema, logh)
                sinks[sink_key] = Sink(sink_act.write, sink_act.close)
                return
            # elif config[PTag('tlm', 'nso-data-provider')].exists():
            #     ...
            #     sinks[sink_key] = sink
            #     return
            elif config[PTag('tlm', 'nso-cdb')].exists():
                sink_act = telemetrify.main.sink.nso.NsoCdbSink(env, config, shared_schema, logh)
                sinks[sink_key] = Sink(sink_act.write, sink_act.close)
                return

    def _create_subscription_sink(sink_key: Keypath, config: TNode) -> ?SubscriptionSink:
        sink: ?Sink = try_get(sinks, sink_key)

        if sink is not None:
            head_cb: action(Node, TNode, ?action() -> None) -> None = action lambda n, p, d: sink.write(n, p, config, d)

            transforms: list[Transform] = []
            # TODO: Make sure we get elements as 'ordered-by user' from CdbCache/TNode.
            for _transform_elem in reversed(list(config[PTag('tlm', 'transform')])):
                transform = _create_transform(_transform_elem, head_cb)
                if transform is not None:
                    transforms.append(transform)
                    head_cb = transform.post # head_cb = transform.post_fn
                else:
                    pass
                    # TODO
                    # raise Exception("Unknown transform type: " + str(_transform_elem))

            return SubscriptionSink(config, sink, transforms, head_cb)

        return None

    def _create_transform(config: TNode, next_cb: action(Node, TNode, ?action() -> None) -> None) -> ?Transform:
        # Magic name string for hardcoded transform for now... i.e. demo.
        if eq_optional(config[PTag('tlm', 'name')].try_str(), "vmanage"):
            transform_act = telemetrify.vmanage.transform.Transform(
                next_cb,
                shared_resources.request_l3vpn_svc_tracker,
                shared_resources.release_l3vpn_svc_tracker,
                logh)
            return Transform(transform_act.transform, transform_act.close)
        elif eq_optional(config[PTag('tlm', 'name')].try_str(), "cat8k-ip-sla"):
            transform_act = telemetrify.ietf.cat8k.IpSlaTransform(
                next_cb,
                shared_resources.request_l3vpn_svc_tracker,
                shared_resources.release_l3vpn_svc_tracker,
                logh)
            return Transform(transform_act.transform, transform_act.close)
        return None

    def set_target_state(target_state: int):
        log.debug("DEVICE SET TARGET STATE", {"name": name, "target_state": state_str(target_state)})
        if not DelegateMiddleManager_set_target_state(source_manager, target_state):
            log.error("DEVICE UNEXPECTED STATE ignoring", {"name": name, "target_state": state_str(target_state)})

    def on_reached_state(state: int):
        log.info("DEVICE REACHED STATE " + state_str(state), {"name": name})

        if source_manager.target_state == STATE_CLOSED:
            for sink in sinks.values():
                sink.close()
            #sinks.clear()
            sinks = {}

        reached_state_cb(state)

    def _on_source_reached_state_trampoline(_id: DelegateId, state: int):
        # manager.on_delegate_reached_state(_id, state)
        DelegateMiddleManager_on_delegate_reached_state(source_manager, _id, state) # https://github.com/actonlang/acton/issues/1448

    # Workaround compiler ordering issue
    source_manager._reached_state_cb = on_reached_state
    source_manager._delegate_manager._on_delegate_reached_state_trampoline_fn = _on_source_reached_state_trampoline

class DeviceStreamerWrapper(object):
    @property
    set_target_state_fn: action(int) -> None
    @property
    update_config_fn: action(
            ?DeviceStreamerConfig,
            list[(Keypath, ?value)],
            list[(Keypath, ?value)],
            list[(Keypath, ?value)],
            list[(Keypath, ?value)]) -> None

    def __init__(self,
            set_target_state_fn: action(int) -> None,
            update_config_fn: action(
                ?DeviceStreamerConfig,
                list[(Keypath, ?value)],
                list[(Keypath, ?value)],
                list[(Keypath, ?value)],
                list[(Keypath, ?value)]) -> None):

        self.set_target_state_fn = set_target_state_fn
        self.update_config_fn = update_config_fn

    def update_config(self,
            updated_device_config: ?DeviceStreamerConfig,
            subscription_updates: list[(Keypath, ?value)],
            subscription_sink_updates: list[(Keypath, ?value)],
            source_updates: list[(Keypath, ?value)],
            sink_updates: list[(Keypath, ?value)]):

        self.update_config_fn(
            updated_device_config,
            subscription_updates,
            subscription_sink_updates,
            source_updates,
            sink_updates)

extension DeviceStreamerWrapper(Delegate):
    def set_target_state(self, target_state: int) -> None:
        self.set_target_state_fn(target_state)

actor SharedResources(env: Env, shared_schema: schema.SharedSchema, log_handler: logging.Handler):
    var l3vpn_svc_tracker: ?telemetrify.ietf.l3vpn_svc.L3vpnSvcTracker = None

    # def request_l3vpn_svc_tracker(cb: action(telemetrify.ietf.l3vpn_svc.L3vpnSvcTracker) -> None):
    # TODO: Why do we get this error when there is MORE than one reference to the method, but NOT if there is ONLY one?
    # ERROR: Error when compiling telemetrify.main.main module: Type error
    #  1425:9-33
    #      |
    # 1425 |    def request_l3vpn_svc_tracker(cb: action(telemetrify.ietf.l3vpn_svc.L3vpnSvcTracker) -> None):
    #      |        ^^^^^^^^^^^^^^^^^^^^^^^^^
    # NoInfo (Loc 58253 58278) 63
    def request_l3vpn_svc_tracker(cb):
        r = l3vpn_svc_tracker
        if r is not None:
            cb(r)
        else:
            n = telemetrify.ietf.l3vpn_svc.L3vpnSvcTracker(env, shared_schema, log_handler)
            l3vpn_svc_tracker = n
            cb(n)

    def release_l3vpn_svc_tracker(tracker: telemetrify.ietf.l3vpn_svc.L3vpnSvcTracker):
        pass # TODO: Could keep refcount and release when not used

actor main(env):
    # var device_streamers: DelegateManager[DeviceStreamerWrapper] = DelegateManager(
    #     _on_device_streamer_reached_state_trampoline,
    #     lambda s: None,
    #     target_state=STATE_RUNNING)
    # Workaround compiler ordering issue
    var device_streamers: DelegateManager[DeviceStreamerWrapper] = DelegateManager(lambda i, s: None, lambda s: None)
    var cache: ?telemetrify.nso.subscriber.CdbCache = None
    var shared_resources: ?SharedResources = None

    var logh = logging.Handler("telemetrify")
    var log = logging.Logger(logh)

    logh.set_output_level(logging.NOTICE)
    logh.add_sink(logging.StdoutSink())

    def _on_maapi_connect_error(e):
        log.error("MAAPI connect failed:" + str(e), None)

    def _on_maapi_connect(c):
        log.info("MAAPI connected!!!!", None)
        c.load_schema(_on_load_schema)

    def _on_load_schema(c, e: ?Exception, shared_schema: ?schema.SharedSchema):
        if e is None and shared_schema is not None:
            log.info("MAAPI loaded schema!!!!", None)
            shared_resources = SharedResources(env, shared_schema, logh)
            cdb_connection = telemetrify.nsoapi.cdb.CdbConnection(env, 4569, "telemetrify",
                action lambda c: _on_cdb_sub_connect(c, shared_schema), _on_cdb_connect_error, logh, None)
        else:
            log.error("MAAPI load schema failed:" + optional_str(e, ""), None)
            await async env.exit(1)

    def _on_cdb_connect_error(e):
        log.error("CDB connect failed:" + str(e), None)
        await async env.exit(1)

    def _on_cdb_sub_connect(sc, s):
        log.info("CDB (sub) connected!!!!", None)
        cdb_connection = telemetrify.nsoapi.cdb.CdbConnection(env, 4569, "telemetrify",
            action lambda cc: _on_cdb_cmd_connect(sc, cc, s), _on_cdb_connect_error, logh, None)

    def _on_cdb_cmd_connect(sc, cc, s):
        log.info("CDB (cmd) connected!!!!", None)
        cache = telemetrify.nso.subscriber.CdbCache(sc, cc, s,
            [
                DeviceSettingsRefiner,
                DeviceNedIdBaseRefiner,
                DeviceStreamerRefiner,
                DeviceSourceNetconfRefiner,
                DeviceSourceVmanageRefiner,
                DeviceSourceRefiner,
                DeviceSubscriptionSourceBaseRefiner,
                DeviceSubscriptionSourceRefiner,
                DeviceSubscriptionSinkBaseRefiner,
                DeviceSubscriptionSinkRefiner,
                SinkRefiner,
                DeviceSinksRefiner,
                LoggingLevelRefiner,
            ],
            [([
                #DeviceSettingsRefiner.id(), # For DEBUG printouts only
                #DeviceNedIdBaseRefiner.id(), # For DEBUG printouts only
                DeviceStreamerRefiner.id(),
                #DeviceSourceNetconfRefiner.id(), # For DEBUG printouts only
                #DeviceSourceVmanageRefiner.id(), # For DEBUG printouts only
                DeviceSourceRefiner.id(),
                #DeviceSubscriptionSourceBaseRefiner.id(), # For DEBUG printouts only
                DeviceSubscriptionSourceRefiner.id(),
                #DeviceSubscriptionSinkBaseRefiner.id(), # For DEBUG printouts purposes
                DeviceSubscriptionSinkRefiner.id(),
                #SinkRefiner.id(), # For DEBUG printouts purposes
                DeviceSinksRefiner.id(),
                LoggingLevelRefiner.id()
            ],
            lambda r: _on_config_update(r, s))], _on_config_cache_error,
            logh)
        #await async env.exit(0)

    def _on_config_update(refiner_updates: dict[int, list[(Keypath, ?value)]], shared_schema: schema.SharedSchema):
        for refiner_id, updates in refiner_updates.items():
            log.debug("refiner_id:", {"refiner_id": refiner_id})
            _updates = {}
            for k, v in updates:
                _updates[str(k)] = str(v) if v is not None else "DELETED"
            log.debug("refiner updates", _updates)

        dev_config: list[(Keypath, ?value)] = refiner_updates[DeviceStreamerRefiner.id()]
        sub_config: list[(Keypath, ?value)] = refiner_updates[DeviceSubscriptionSourceRefiner.id()]
        sub_sink_config: list[(Keypath, ?value)] = refiner_updates[DeviceSubscriptionSinkRefiner.id()]
        source_config: list[(Keypath, ?value)] = refiner_updates[DeviceSourceRefiner.id()]
        # sink_config: list[(Keypath, ?value)] = refiner_updates[SinkRefiner.id()]
        sink_config: list[(Keypath, ?value)] = refiner_updates[DeviceSinksRefiner.id()]

        updated_device_keys: set[Keypath] = set([])

        updated_subscriptions: dict[Keypath, list[(Keypath, ?value)]] = {}
        updated_subscription_sinks: dict[Keypath, list[(Keypath, ?value)]] = {}
        updated_device_sources: dict[Keypath, list[(Keypath, ?value)]] = {}
        updated_device_sinks: dict[Keypath, list[(Keypath, ?value)]] = {}
        updated_device_configs: dict[Keypath, DeviceStreamerConfig] = {}

        for dev_sub_key, state in sub_config:
            device_key = dev_sub_key.try_slice(0, 1)
            if device_key is not None:
                dict_list_append(updated_subscriptions, device_key, (dev_sub_key, state))
                updated_device_keys.add(device_key)

        for dev_sub_sink_key, state in sub_sink_config:
            device_key = dev_sub_sink_key.try_slice(0, 1)
            if device_key is not None:
                dict_list_append(updated_subscription_sinks, device_key, (dev_sub_sink_key, state))
                updated_device_keys.add(device_key)

        for device_source_key, state in source_config:
            device_key = device_source_key.try_slice(0, 1)
            source_key = device_source_key.try_slice(1, 2)
            if device_key is not None and source_key is not None:
                dict_list_append(updated_device_sources, device_key, (source_key, state))
                updated_device_keys.add(device_key)

        for device_sink_key, state in sink_config:
            device_key = device_sink_key.try_slice(0, 1)
            sink_key = device_sink_key.try_slice(1, 2)
            if device_key is not None and sink_key is not None:
                dict_list_append(updated_device_sinks, device_key, (sink_key, state))
                updated_device_keys.add(device_key)

        for device_key, state in dev_config:
            if state is not None and isinstance(state, DeviceStreamerConfig):
                updated_device_keys.add(device_key)
                updated_device_configs[device_key] = state
            else:
                DelegateManager_remove(device_streamers, device_key) # https://github.com/actonlang/acton/issues/1448
                updated_device_keys.discard(device_key)

        for updated_device_key in updated_device_keys:
            def _update_fn(d):
                d.update_config(
                    try_get(updated_device_configs, updated_device_key),
                    updated_subscriptions.get(updated_device_key, []),
                    updated_subscription_sinks.get(updated_device_key, []),
                    updated_device_sources.get(updated_device_key, []),
                    updated_device_sinks.get(updated_device_key, []))

            entry = DelegateManager_try_get(device_streamers, updated_device_key)
            if entry is not None:
                _update_fn(entry)
            else:
                _device_name_key = updated_device_key.try_get_key(0)
                if _device_name_key is not None:
                    device_name = _device_name_key[0]
                    _shared_resources = shared_resources
                    if isinstance(device_name, str) and _shared_resources is not None:
                        _id, reached_state_cb = DelegateManager_reserve(device_streamers, updated_device_key) # https://github.com/actonlang/acton/issues/1448
                        ds_act = DeviceStreamer(env, device_name, reached_state_cb, shared_schema, _shared_resources, logh)
                        device_streamer = DeviceStreamerWrapper(ds_act.set_target_state, ds_act.update_config)
                        DelegateManager_add(device_streamers, _id, device_streamer, _update_fn) # https://github.com/actonlang/acton/issues/1448

        # Logging
        _on_logging_level(refiner_updates[LoggingLevelRefiner.id()])

    def _on_device_streamer_reached_state_trampoline(_id: DelegateId, state: int):
        # device_streamers.on_delegate_reached_state(_id, state)
        DelegateManager_on_delegate_reached_state(device_streamers, _id, state) # https://github.com/actonlang/acton/issues/1448

    def _on_logging_level(updates: list[(Keypath, ?value)]):
        level: ?int = None
        for _keypath, state in updates:
            if state is not None and isinstance(state, TNode):
                #_val = state.try_str()
                _leaf: TNode = state
                _val = _leaf.try_str()
                if _val is not None:
                    if _val == 'off':
                        level = logging.OFF
                    elif _val == 'emergency':
                        level = logging.EMERGENCY
                    elif _val == 'alert':
                        level = logging.ALERT
                    elif _val == 'critical':
                        level = logging.CRITICAL
                    elif _val == 'error':
                        level = logging.ERROR
                    elif _val == 'warning':
                        level = logging.WARNING
                    elif _val == 'info':
                        level = logging.INFO
                    elif _val == 'notice':
                        level = logging.NOTICE
                    elif _val == 'debug':
                        level = logging.DEBUG
                    elif _val == 'verbose':
                        level = logging.VERBOSE
                    elif _val == 'trace':
                        level = logging.TRACE
                    elif _val == 'all':
                        level = logging.ALL
                    else:
                        raise Exception("Unimplemented logging level value: " + str(_val))

        if level is not None:
            logh.set_output_level(level)

    def _on_config_cache_error(e):
        log.error("CdbCache failed:" + optional_str(e.error_message, ""), None)
        await async env.exit(1)

    # Workaround compiler ordering issue
    device_streamers._on_delegate_reached_state_trampoline_fn = _on_device_streamer_reached_state_trampoline
    DelegateManager_set_target_state(device_streamers, STATE_RUNNING)

    log.info("Starting up...", None)
    maapi_connection = telemetrify.nsoapi.maapi.MaapiConnection(env, 4569, _on_maapi_connect, _on_maapi_connect_error, logh, None)
