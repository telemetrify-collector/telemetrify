import logging
import net
import time

import telemetrify.nsoapi.schema as schema
import telemetrify.tsdb.writer
import tsdb.m3

from telemetrify.common.mod import *
from telemetrify.common.utils import *
from telemetrify.nsoapi.schema import SchemaPath

actor M3dbSink(auth: WorldCap, config: TNode, shared_schema: schema.SharedSchema, log_handler: logging.Handler):
    var logh = logging.Handler("m3db-sink")
    if log_handler is not None:
        logh.set_handler(log_handler)

    var log = logging.Logger(logh)

    config_m3db = config[PTag('tlm', 'm3db')]
    address = config_m3db[PTag('tlm', 'address')].req_str()
    port = config_m3db[PTag('tlm', 'port')].req_int()

    var client: ?tsdb.m3.Client = None
    var writer: ?telemetrify.tsdb.writer.TSDBWriter = None

    log.info("SINK m3db CREATED", None)

    def write(node: Node, source_params: TNode, sink_config: TNode) -> None:
        w = writer
        if w is not None:
            _schema_path: ?value = source_params[PTag(None, 'schema_path')].value()
            schema_path: ?SchemaPath = _schema_path if _schema_path is not None and isinstance(_schema_path, SchemaPath) else None
            _timestamp: ?value = source_params[PTag(None, 'timestamp')].value()
            timestamp: time.Instant = _timestamp if _timestamp is not None and isinstance(_timestamp, time.Instant) else time.time()
            base_tags: list[(str, str)] = []
            for tag_entry in sink_config[PTag(None, 'base_tags')].iter():
                _tag = tag_entry[PTag(None, 'name')].try_str()
                _value = tag_entry[PTag(None, 'value')].try_str()
                if _tag is not None and _value is not None:
                    base_tags.append((_tag, _value))

            m3db_timestamp = timestamp.second # TODO: Subsecond precision
            # TODO:
            # Why: Cannot unify ?T_619 and telemetrify.common.mod.SchemaPath
            # when argment is ?SchemaPath ?
            #w.write(node, schema_path, [], base_tags, m3db_timestamp, _on_write_done)
            w.write(node, schema_path if schema_path is not None else SchemaPath([], []), base_tags, m3db_timestamp, _on_write_done)
        else:
            # TODO:
            # Buffer until (re-)connected or signal connection upwards for possible source subscription sync?
            # Not really relevant for periodic time-series ...
            pass
            # # <TEST>
            # _schema_path: ?value = source_params[PTag(None, 'schema_path')].value()
            # schema_path: ?SchemaPath = _schema_path if _schema_path is not None and isinstance(_schema_path, SchemaPath) else None
            # _timestamp: ?value = source_params[PTag(None, 'timestamp')].value()
            # timestamp: time.Instant = _timestamp if _timestamp is not None and isinstance(_timestamp, time.Instant) else time.time()
            # base_tags: list[(str, str)] = []
            # for tag_entry in sink_config[PTag(None, 'base_tags')].iter():
            #     _tag = tag_entry[PTag(None, 'name')].try_str()
            #     _value = tag_entry[PTag(None, 'value')].try_str()
            #     if _tag is not None and _value is not None:
            #         base_tags.append((_tag, _value))
            # m3db_timestamp = timestamp.second # TODO: Subsecond precision
            # print("SINK m3db WRITE Attempted", node, optional_str(schema_path, "None"), base_tags, m3db_timestamp)
            # # </TEST>

    def close():
        # TODO: Flush writer?
        # _writer = writer
        # if _writer is not None:
        #     _writer.flush()
        _client = client
        if _client is not None:
            # TODO:
            # _client.close()
            pass

        log.info("SINK m3db CLOSED", None)

    def _on_tsdb_connect(c: tsdb.m3.Client):
        client = c
        c.quick_init(_on_tsdb_init)
        log.info("SINK m3db CONNECTED", None)

    def _on_tsdb_init(c: tsdb.m3.Client, success: bool):
        writer = telemetrify.tsdb.writer.TSDBWriter(c, shared_schema, logh)
        log.info("SINK m3db INITIALIZED", None)

    def _on_tsdb_error(c: tsdb.m3.Client, e):
        log.error("SINK m3db CLIENT ERROR:", {"error": str(e)})
        # TODO: Reconnect ourselves or pass along upwards?

    def _on_write_done(c, e):
        if e is not None:
            log.error("SINK m3db WRITE ERROR:", {"error": str(e)})
        else:
            log.info("SINK m3db WRITE DONE", None)

    #log_handler.add_sink(logging.StdoutSink())

    #log = logging.Logger(log_handler)

    tsdb.m3.Client(net.TCPConnectCap(net.TCPCap(net.NetCap(auth))), address, port, _on_tsdb_connect, _on_tsdb_error, logh)
