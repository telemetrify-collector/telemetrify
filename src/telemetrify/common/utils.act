# Copyright (C) Deutsche Telekom AG
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

# Workaround actonc error:
# ld.lld: error: undefined symbol: $EqOptG_new
def eq_optional[T(Eq)](a: ?T, b: ?T) -> bool:
    return a is not None and b is not None and a == b or a is None and b is None

def safe_hash(h: int) -> int: # TODO: Remove when https://github.com/actonlang/acton/issues/1348 is fixed
    limit = 2**63-1
    sign = 1
    if h < 0:
        limit = 2**63
        sign = -1
        h = -h

    while h > limit:
        f = h // limit
        h %= limit
        h += f

    return sign * h

_SCALE: int = 3

class Queue[T](object):
    @property
    _d: list[?T] # TODO: How to allow T to be ?U. Per-item wrapper?
    @property
    _start: int
    @property
    _len: int

    def __init__(self):
        self._d = []
        self._start = 0
        self._len = 0

    def __len__(self) -> int:
        return self._len

    def __bool__(self) -> bool:
        #return len(self) > 0
        return self.__len__() > 0

    def _realign(self):
        d = self._d
        self._d = d[self._start:] + d[:self._start]

    def append(self, item: T):
        # print("Q: Before append:", len(self._d), self._start, self._len)
        cap = len(self._d)
        d: list[?T] = self._d
        if self._len < cap:
            d[(self._start + self._len) % cap] = item
        else:
            if self._start > 0:
                self._realign()
                d.append(item)
                # spare = max(1, cap // _SCALE) # Type inference error
                _min: int = 1
                _max: int = cap // _SCALE
                spare = _max if _max > _min else _min
                for i in range(0, spare, 1):
                    d.append(None)
            else:
                d.append(item)
        self._len += 1
        # print("Q: After append:", len(self._d), self._start, self._len)

    def extend(self, iterable: Iterable[T]):
        for item in iterable:
            self.append(item)

    def peek(self) -> T:
        # print("Q: Before peek:", len(self._d), self._start, self._len)
        if not self:
            raise IndexError(self._start, "pop from empty Queue")
        item = self._d[self._start]
        if item is not None: # TODO: How to differentiate nested ?U. Per-item wrapper?
            # print("Q: Peek return:", item)
            return item
        raise ValueError("Queue internal error")

    def pop(self) -> T:
        # print("Q: Before pop:", len(self._d), self._start, self._len)
        if not self:
            raise IndexError(self._start, "pop from empty Queue")
        item = self._d[self._start]
        # self._d[self._start] = None # Type inference error
        d: list[?T] = self._d
        d[self._start] = None
        self._start = (self._start + 1) % len(self._d)
        self._len -= 1
        # print("Q: After pop:", len(self._d), self._start, self._len)
        if item is not None: # TODO: How to differentiate nested ?U. Per-item wrapper?
            # print("Q: Pop return:", item)
            return item
        raise ValueError("Queue internal error")

# class Deque[T](object):

# _list_swap[T](l: list[T], a: int, b: int):
#     tmp = l[a]
#     l[a] = l[b]
#     l[b] = tmp

class BiDict[K(Hashable), V(Hashable)](object):
    @property
    key_to_val: dict[K, V]
    @property
    val_to_key: dict[V, K]

    def __init__(self):
        self.key_to_val = {}
        self.val_to_key = {}

    def set(self, k: K, v: V):
        BiDict.try_pop_val(self, k)
        BiDict.try_pop_key(self, v)
        self.key_to_val[k] = v
        self.val_to_key[v] = k

    def try_get_val(self, k: K) -> ?V:
        return try_get(self.key_to_val, k)

    def try_get_key(self, v: V) -> ?K:
        return try_get(self.val_to_key, v)

    def try_pop_val(self, k: K) -> ?V:
        v = try_pop(self.key_to_val, k)
        if v is not None:
            del self.val_to_key[v]
        return v

    def try_pop_key(self, v: V) -> ?K:
        k = try_pop(self.val_to_key, v)
        if k is not None:
            del self.key_to_val[k]
        return k

    def clear(self):
        # self.key_to_val.clear()
        # self.val_to_key.clear()
        self.key_to_val = {}
        self.val_to_key = {}

class BiMultiDict[K(Hashable), V(Hashable)](object):
    @property
    key_to_val: dict[K, set[V]]
    @property
    val_to_key: dict[V, K]

    def __init__(self):
        self.key_to_val = {}
        self.val_to_key = {}

    def add(self, k: K, v: V):
        vk = BiMultiDict.try_pop_key(self, v)
        dict_set_add(self.key_to_val, k, v)
        self.val_to_key[v] = k

    def try_get_vals(self, k: K) -> ?set[V]:
        return try_get(self.key_to_val, k)

    def try_get_key(self, v: V) -> ?K:
        return try_get(self.val_to_key, v)

    def try_pop_vals(self, k: K) -> ?set[V]:
        vals = try_pop(self.key_to_val, k)
        if vals is not None:
            for v in vals:
                del self.val_to_key[v]
        return vals

    def try_pop_key(self, v: V) -> ?K:
        k = try_pop(self.val_to_key, v)
        if k is not None:
            dict_set_discard(self.key_to_val, k, v)
        return k

    def clear(self):
        # self.key_to_val.clear()
        # self.val_to_key.clear()
        self.key_to_val = {}
        self.val_to_key = {}

class UniqueAndSharedKeyDict[U(Hashable), S(Hashable), V](object):
    @property
    unique_to_shared_and_val: dict[U, (S, V)]
    @property
    shared_to_unique: dict[S, U]

    def __init__(self):
        self.unique_to_shared_and_val = {}
        self.shared_to_unique = {}

    def __len__(self) -> int:
        return len(self.unique_to_shared_and_val)

    def unique_keys(self):
        return self.unique_to_shared_and_val.keys()

    def shared_value_iter(self) -> Iterator[(S, V)]:
        return iter(self.unique_to_shared_and_val.values())

    def has_unique(self, unique: U) -> bool:
        return unique in self.unique_to_shared_and_val

    def set(self, unique: U, shared: S, v: V):
        try_pop(self.shared_to_unique, shared)
        self.unique_to_shared_and_val[unique] = (shared, v)

    def try_get_unique(self, unique: U) -> ?V:
        shared_v: ?(S, V) = try_get(self.unique_to_shared_and_val, unique)
        if shared_v is not None:
            return shared_v.1
        return None

    def try_pop_unique(self, unique: U) -> ?V:
        shared_v: ?(S, V) = try_pop(self.unique_to_shared_and_val, unique)
        if shared_v is not None:
            try_pop(self.shared_to_unique, shared_v.0)
            return shared_v.1
        return None

    def try_pop_shared(self, shared: S) -> ?V:
        unique = try_pop(self.shared_to_unique, shared)
        if unique is not None:
            shared_v = try_pop(self.unique_to_shared_and_val, unique)
            if shared_v is not None:
                return shared_v.1
        return None

    def try_pop_shared_item(self, shared: S) -> ?(U, V):
        unique = try_pop(self.shared_to_unique, shared)
        if unique is not None:
            shared_v = try_pop(self.unique_to_shared_and_val, unique)
            if shared_v is not None:
                return (unique, shared_v.1)
        return None

    def clear(self):
        # self.unique_to_shared_and_val.clear()
        # self.shared_to_unique.clear()
        self.unique_to_shared_and_val = {}
        self.shared_to_unique = {}

protocol TryGetMapping[A(Eq), B](Mapping[A, B]):
    try_get: (A) -> ?B

# Affected by: https://github.com/actonlang/acton/issues/1126
# extension dict[A(Hashable), B](TryGetMapping[A, B]):
#     def try_get(self, a: A) -> ?B:
#         # Without support for catching KeyError
#         # it looks like we need to do double hash lookups for now
#         if self.__contains__(a):
#             return self[a]
#         else:
#             return None

def try_get[A(Eq), B](m: Mapping[A, B], a: A) -> ?B:
    # Without support for catching KeyError
    # it looks like we need to do double hash lookups for now
    if m.__contains__(a):
        return m[a]
    else:
        return None

def try_pop[A(Eq), B](m: Mapping[A, B], a: A) -> ?B:
    # Without support for catching KeyError
    # it looks like we need to do triple hash lookups for now
    if m.__contains__(a):
        b = m[a]
        # del m[a]
        m.__delitem__(a)
        return b
    else:
        return None

def try_discard[A(Eq), B](m: Mapping[A, B], a: A) -> ?B:
    # Without support for catching KeyError
    # it looks like we need to do triple hash lookups for now
    if m.__contains__(a):
        b = m[a]
        # del m[a]
        m.__delitem__(a)
        return b
    else:
        return None

#def get_or_create[A(Eq), B](m: Mapping[A, B], a: A, b: () -> B) -> B:
#def get_or_create[A(Eq), B, M(Mapping[A, B], Indexed[A])](m: M, a: A, b: () -> B) -> B:
def get_or_create[A(Hashable), B](m: dict[A, B], a: A, b: () -> B) -> B:
    g: ?B = try_get(m, a)
    if g is not None:
        return g
    #m[a] = c = b()
    c: B = b()
    m[a] = c
    return c

def mapping_str[A(Eq), B](m: Mapping[A, B]) -> str:
    l: list[str] = []
    #for k, v in m.items():
    for p in m.items():
        k, v = p
        unsafe_list_append(l, str(k) + ": " + str(v))
    return "{" + ", ".join(l) + "}"

def list_pop[T](l: list[T]) -> T:
    res = l[-1]
    del l[-1]
    return res

def list_try_pop[T](l: list[T]) -> ?T:
    if len(l) > 0:
        return list_pop(l)
    return None

def list_extend[T](target: list[T], source: Iterable[T]):
    for item in source:
        target.append(item)

def list_concat[T](a: list[T], b: list[T]) -> list[T]:
    # Due to https://github.com/actonlang/acton/issues/1461
    if not a:
        return b
    if not b:
        return a
    return a + b

def list_eq[T(Eq)](a: list[T], b: list[T]) -> bool:
    a_len = len(a)
    if a_len != len(b):
        return False

    for i in range(0, a_len, 1):
        if a[i] != b[i]:
            return False
    return True

def list_hash[T(Hashable)](a: list[T]) -> int:
    h = 0
    for x in a:
        h += hash(x)
    return safe_hash(h)

pure def unsafe_list_append[T](target: list[T], item: T) -> None:
    """
    Used with care, e.g. when we want to append to a list owned within a pure function
    where list.append would would mark the calling function as non-pure regardless.
    """
    # target.append(item)
    NotImplemented

def list_reversed[T](a: list[T]) -> list[T]:
    r: list[T] = list(a)
    r.reverse()
    return r

def list_str[T](a: list[T]) -> str:
    l: list[str] = []
    for x in a:
        unsafe_list_append(l, str(x))
    return "[" + ", ".join(l) + "]"

def set_update[T(Hashable)](target: set[T], source: Iterable[T]):
    for item in source:
        target.add(item)

def set_difference[T(Hashable)](self: set[T], other: set[T]):
    result = set([])
    for item in self:
        if item not in other:
            result.add(item)
    return result

def set_str[T(Hashable)](a: set[T]) -> str:
    l: list[str] = []
    for x in a:
        unsafe_list_append(l, str(x))
    return "{" + ", ".join(l) + "}"

def dict_list_append[K(Hashable), V](d: dict[K, list[V]], k: K, v: V):
    l = try_get(d, k)
    if l is not None:
        l.append(v)
    else:
        d[k] = [v]

def dict_set_add[K(Hashable), V(Hashable)](d: dict[K, set[V]], k: K, v: V):
    s = try_get(d, k)
    if s is not None:
        s.add(v)
    else:
        d[k] = set([v])

def dict_set_update[K(Hashable), V(Hashable)](d: dict[K, set[V]], k: K, source: Iterable[V]):
    s = try_get(d, k)
    if s is not None:
        set_update(s, source)
    else:
        d[k] = set(iter(source))

def dict_set_discard[K(Hashable), V(Hashable)](d: dict[K, set[V]], k: K, v: V):
    s = try_get(d, k)
    if s is not None:
        s.discard(v)
        if len(s) == 0:
            del d[k]

def dict_dict_add[K1(Hashable), K2(Hashable), V](d1: dict[K1, dict[K2, V]], k1: K1, k2: K2, v: V):
    try:
        d2 = d1[k1]
    except KeyError:
        d1[k1] = {k2: v}
    else:
        d2[k2] = v

def dict_dict_try_pop[K1(Hashable), K2(Hashable), V](d1: dict[K1, dict[K2, V]], k1: K1, k2: K2) -> ?V:
    try:
        d2 = d1[k1]
    except KeyError:
        return None
    else:
        v = try_pop(d2, k2)
        if not bool(d2):
            del d1[k1]
        return v

def optional_str[T](v: ?T, default: str) -> str:
    return str(v) if v is not None else default

def min2[T(Ord)](a: T, b: T) -> T:
    return a if a <= b else b

def max2[T(Ord)](a: T, b: T) -> T:
    return a if a >= b else b

class MinHeap[T(Ord)](object):
    @property
    _items: list[T]

    def __init__(self):
        self._items = []

    def insert(self, v: T):
        items = self._items
        curr = len(items)
        items.append(v)
        while curr > 0:
            parent = curr // 2
            parent_v = items[parent]
            if v >= parent_v:
                break
            items[parent] = v
            items[curr] = parent_v
            curr = parent

    def try_pop(self) -> ?T:
        items = self._items
        items_len = len(items)
        if items_len == 0:
            return None
        retval = items[0]
        v = list_pop(items)
        if items_len >= 2:
            items_len -= 1
            curr = 0
            left = 1
            right = 2
            has_left = left < items_len
            has_right = right < items_len
            items[curr] = v
            while has_left and (v > items[left] or has_right and v > items[right]):
                if not has_right or items[left] < items[right]:
                    items[curr] = items[left]
                    items[left] = v
                    curr = left
                else:
                    items[curr] = items[right]
                    items[right] = v
                    curr = right
                left = curr * 2
                right = left + 1
                has_left = left < items_len
                has_right = right < items_len
        return retval

# Workaround for https://github.com/actonlang/acton/issues/1126
protocol Ord2:
    @staticmethod
    eq: (Self, Self) -> bool
    @staticmethod
    ne: (Self, Self) -> bool
    @staticmethod
    lt: (Self, Self) -> bool
    @staticmethod
    le: (Self, Self) -> bool
    @staticmethod
    gt: (Self, Self) -> bool
    @staticmethod
    ge: (Self, Self) -> bool
    def ne(a, b):
        return not Ord2.eq(a, b)
    def le(a, b):
        return Ord2.lt(a, b) or Ord2.eq(a, b)
    def gt(a, b):
        return Ord2.lt(b, a)
    def ge(a, b):
        return Ord2.le(b, a)

# Workaround for https://github.com/actonlang/acton/issues/1126
class MinHeap_Ord2[T(Ord2)](object):
    @property
    _items: list[T]

    def __init__(self):
        self._items = []

    def insert(self, v: T):
        items = self._items
        curr = len(items)
        items.append(v)
        while curr > 0:
            parent = curr // 2
            parent_v = items[parent]
            #if v >= parent_v:
            if Ord2.ge(v, parent_v):
                break
            items[parent] = v
            items[curr] = parent_v
            curr = parent

    def try_pop(self) -> ?T:
        items = self._items
        items_len = len(items)
        if items_len == 0:
            return None
        retval = items[0]
        v = list_pop(items)
        if items_len >= 2:
            items_len -= 1
            curr = 0
            left = 1
            right = 2
            has_left = left < items_len
            has_right = right < items_len
            items[curr] = v
            #while has_left and (v > items[left] or has_right and v > items[right]):
            while has_left and (Ord2.gt(v, items[left]) or has_right and Ord2.gt(v, items[right])):
                #if items[left] < items[right] or not has_right:
                if not has_right or Ord2.lt(items[left], items[right]):
                    items[curr] = items[left]
                    items[left] = v
                    curr = left
                else:
                    items[curr] = items[right]
                    items[right] = v
                    curr = right
                left = curr * 2
                right = left + 1
                has_left = left < items_len
                has_right = right < items_len
        return retval

# class HashableTuple2[A(Hashable), B(Hashable)]:
#     @property
#     a: A
#     @property
#     b: B

#     #def __init__(self, a: A, b: B): # actonc: Acton/Solver.hs:(197,1)-(222,51): Non-exhaustive patterns in function rank
#     def __init__(self, a, b):
#         self.a = a
#         self.b = b

# extension HashableTuple2(Hashable):
#     __eq__(self, other) -> bool:

class Wardrobe[T](object):
    @property
    next_ticket: int
    @property
    items: dict[int, T]

    def __init__(self):
        self.next_ticket = 0
        self.items = {}

    def put(self, item: T) -> int:
        ticket = self.next_ticket
        self.next_ticket = ticket + 1
        self.items[ticket] = item
        return ticket

    def borrow(self, ticket: int) -> T:
        return self.items[ticket]

    def pop(self, ticket: int) -> T:
        #item = self.items.pop(ticket)
        item = self.items[ticket]
        del self.items[ticket]
        return item

    def pop_all(self):
        items = self.items
        self.items = {}
        return items.items()

    def discard(self, ticket):
        try:
            del self.items[ticket]
        except KeyError:
            pass

    def get_tickets(self):
        return self.items.keys()

    def clear(self):
        #self.items.clear()
        self.items = {}

def try_parse_int(s: str) -> ?int:
    s = s.strip(" \t\n")

    v = 0
    sign = 1
    _len = len(s)
    i = 0

    while i < _len:
        c = s[i]
        if c == "-":
            sign = -sign
        elif c.isdecimal():
            v = int(c)
            i += 1
            break
        elif c != "+":
            return None
        i += 1

    while i < _len:
        c = s[i]
        if not c.isdecimal():
            break
        v *= 10
        v += int(c)
        i += 1

    return sign * v

def try_parse_float(s: str) -> ?float:
    parts = try_parse_float_parts(s)
    if parts is not None:
        significand, exponent = parts
        return float(significand) * float(10)**float(exponent)
    return None

def try_parse_float_parts(s: str) -> ?(int, int):
    s = s.strip(" \t\n")

    p = s.split('e', -1)
    plen = len(p)
    exp = 0
    if plen == 2:
        _exp = try_parse_int(p[1])
        if _exp is not None:
            exp = _exp
        else:
            return None
    elif plen != 1:
        return None

    f = p[0].split(".", -1)
    flen = len(f)

    significand: int = 0

    if flen == 1:
        _s = try_parse_int(f[0])
        if _s is not None:
            significand = _s
        else:
            return None
    elif flen == 2:
        ip = f[0]
        fp = f[1]
        if not fp.isdecimal():
            return None
        _s = try_parse_int(ip + fp)
        if _s is not None:
            significand = _s
        else:
            return None
        exp -= len(fp)
    else:
        return None

    return (significand, exp)

def try_parse_hex(s: str) -> ?int:
    s = s.strip(" \t\r\n")
    p = s.split("0x", 1)
    plen = len(p)
    if plen == 2 and not p[0]:
        s = p[1]
    elif plen != 1:
        return None

    v = 0
    for c in s:
        h = 0
        if c == '0':
            h = 0
        elif c == '1':
            h = 1
        elif c == '2':
            h = 2
        elif c == '3':
            h = 3
        elif c == '4':
            h = 4
        elif c == '5':
            h = 5
        elif c == '6':
            h = 6
        elif c == '7':
            h = 7
        elif c == '8':
            h = 8
        elif c == '9':
            h = 9
        elif c == 'A' or c == 'a':
            h = 10
        elif c == 'B' or c == 'b':
            h = 11
        elif c == 'C' or c == 'c':
            h = 12
        elif c == 'D' or c == 'd':
            h = 13
        elif c == 'E' or c == 'e':
            h = 14
        elif c == 'F' or c == 'f':
            h = 15
        else:
            return None
        v *= 16
        v += h

    return v

def to_byte_hexpair_str(v: int) -> str:
    # return nibble_to_hex(v >> 4 & 0xF) + nibble_to_hex(v & 0xF) # BUG: Runtime error on bitwise operations
    return nibble_to_hex((v // 0x10) % 0x10) + nibble_to_hex(v % 0x10)

def nibble_to_hex(v: int) -> str:
    if v == 0:
        return '0'
    if v == 1:
        return '1'
    if v == 2:
        return '2'
    if v == 3:
        return '3'
    if v == 4:
        return '4'
    if v == 5:
        return '5'
    if v == 6:
        return '6'
    if v == 7:
        return '7'
    if v == 8:
        return '8'
    if v == 9:
        return '9'
    if v == 10:
        return 'a'
    if v == 11:
        return 'b'
    if v == 12:
        return 'c'
    if v == 13:
        return 'd'
    if v == 14:
        return 'e'
    elif v == 15:
        return 'f'
    else:
        raise ValueError("Value out of nibble range.")

def to_n_dec_str(v: int, min_dec: int) -> str:
    s = str(v)
    sl = []
    for i in range(0, min_dec - len(s), 1):
        unsafe_list_append(sl, "0")
    return "".join(sl) + s

def uint_to_bytes_le(v: int) -> bytes:
    if v < 0:
        raise ValueError("Negative value")
    if v == 0:
        return bytes([0])
    bs: list[int] = []
    while v != 0:
        # bs.append(v & 0xFF) # BUG: Runtime error on bitwise operations
        # v >>= 8 # BUG: Runtime error on bitwise operations
        bs.append(v % 0x100)
        v /= 0x100
    return bytes(bs)

class Decimal64:
    @property
    significand: int
    @property
    exponent: int

    def __init__(self, significand: int, exponent: int):
        self.significand = significand
        self.exponent = exponent

    def __str__(self) -> str:
        #return str(self.significand) + "e" + str(self.exponent)
        s = str(self.integral_part())
        if self.exponent < 0:
            s += "."
            f = self.fractional_part()
            s += to_n_dec_str(f.significand, -f.exponent)
        return s

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?Decimal64:
        parts = try_parse_float_parts(s)
        if parts is not None:
            _significand, _exponent = parts
            return Decimal64(_significand, _exponent)
        return None

    def try_lossless_realign(self, new_exponent: int) -> ?Decimal64:
        exponent_diff = self.exponent - new_exponent
        if exponent_diff == 0:
            return self
        elif exponent_diff < 0:
            divider = 10**-exponent_diff
            if self.significand % divider == 0:
                # TODO: Validate IEEE 754 Decimal64 limits
                return Decimal64(self.significand // divider, new_exponent)
            else:
                return None # Loss of precision
        else: # alignment > 0:
            # TODO: Validate IEEE 754 Decimal64 limits
            return Decimal64(self.significand * 10**exponent_diff, new_exponent)

    def lossy_realign(self, new_exponent: int) -> Decimal64:
        exponent_diff = self.exponent - new_exponent
        if exponent_diff == 0:
            return self
        elif exponent_diff < 0:
            # TODO: Validate IEEE 754 Decimal64 limits
            return Decimal64(self.significand // 10**-exponent_diff, new_exponent)
        else: # alignment > 0:
            # TODO: Validate IEEE 754 Decimal64 limits
            return Decimal64(self.significand * 10**exponent_diff, new_exponent)

    def to_float(self) -> float:
        return float(self.significand) / float(10**(self.exponent))

    def integral_part(self) -> int:
        if self.exponent >= 0:
            return self.significand
        else:
            return self.significand // 10**-self.exponent

    def fractional_part(self) -> Decimal64:
        divider = 10**-self.exponent
        return Decimal64(self.significand % divider, self.exponent)

extension Decimal64(Hashable):
    def __eq__(self, other: Decimal64) -> bool:
        # TODO: Might want to compare realigned values, otoh in
        #       our use-case(s) the exponent is usually fixed by (YANG) model?
        return self.significand == other.significand and self.exponent == other.exponent

    def __hash__(self) -> int:
        return safe_hash(hash(self.significand))

class IPv4Address:
    @property
    data: (int, int, int, int)

    def __init__(self, data: (int, int, int, int)):
        self.data = data

    def __str__(self) -> str:
        d = self.data
        return str(d.0) + "." + str(d.1) + "." + str(d.2) + "." + str(d.3)

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?IPv4Address:
        #return IPv4Address((1,2,3,4))
        NotImplemented

extension IPv4Address(Hashable):
    def __eq__(self, other: IPv4Address) -> bool:
        # return self.data == other.data
        s = self.data
        o = other.data
        return \
            s.0 == o.0 and \
            s.1 == o.1 and \
            s.2 == o.2 and \
            s.3 == o.3

    def __hash__(self) -> int:
        #return hash(self.data)
        d = self.data
        return safe_hash(2*hash(d.3) + 3*hash(d.2) + 5*hash(d.1) + 7*hash(d.0))

class IPv6Address:
    @property
    data: (int, int, int, int, int, int, int, int)

    def __init__(self, data: (int, int, int, int, int, int, int, int)):
        self.data = data

    def __str__(self) -> str:
        # TODO: conventional format
        d = self.data
        return hex(d.0) + ":" + hex(d.1) + ":" + hex(d.2) + ":" + hex(d.3) \
            + ":" + hex(d.4) + ":" + hex(d.5) + ":" + hex(d.6) + ":" + hex(d.7)

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?IPv6Address:
        #return IPv6Address((1,2,3,4,5,6,7,8))
        NotImplemented

extension IPv6Address(Hashable):
    def __eq__(self, other: IPv6Address) -> bool:
        # return self.data == other.data
        s = self.data
        o = other.data
        return \
            s.0 == o.0 and \
            s.1 == o.1 and \
            s.2 == o.2 and \
            s.3 == o.3 and \
            s.4 == o.4 and \
            s.5 == o.5 and \
            s.6 == o.6 and \
            s.7 == o.7

    def __hash__(self) -> int:
        #return hash(self.data)
        d = self.data
        return safe_hash(2*hash(d.7) + 3*hash(d.6) + 5*hash(d.5) + 7*hash(d.4) + hash(d.3) + 11*hash(d.2) + 13*hash(d.1) + 17*hash(d.0))

class IPv4Network:
    @property
    address: IPv4Address
    @property
    mask_len: int

    def __init__(self, address: IPv4Address, mask_len: int):
        self.address = address
        self.mask_len = mask_len

    def __str__(self) -> str:
        return str(self.address) + "/" + str(self.mask_len) # TODO: conventional format

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?IPv4Network:
        p = s.strip(" \t").split("/", -1)
        if len(p) == 2:
            addr = IPv4Address.try_parse(p[0])
            if addr is not None:
                _mask_len = try_parse_int(p[1])
                if _mask_len is not None and _mask_len >= 0 and _mask_len <= 32:
                    return IPv4Network(addr, _mask_len)
        return None

    # def is_strict(self):
    #     # TODO: if all host bits are zero

extension IPv4Network(Hashable):
    def __eq__(self, other: IPv4Network) -> bool:
        return self.address == other.address and self.mask_len == other.mask_len

    def __hash__(self) -> int:
        return safe_hash(hash(self.address) + 137 * hash(self.mask_len))

class IPv6Network:
    @property
    address: IPv6Address
    @property
    mask_len: int

    def __init__(self, address: IPv6Address, mask_len: int):
        self.address = address
        self.mask_len = mask_len

    def __str__(self) -> str:
        return str(self.address) + "/" + str(self.mask_len) # TODO: conventional format

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?IPv6Network:
        p = s.strip(" \t").split("/", -1)
        if len(p) == 2:
            addr = IPv6Address.try_parse(p[0])
            if addr is not None:
                _mask_len = try_parse_int(p[1])
                if _mask_len is not None and _mask_len >= 0 and _mask_len <= 128:
                    return IPv6Network(addr, _mask_len)
        return None

    # def is_strict(self):
    #     # TODO: if all host bits are zero

extension IPv6Network(Hashable):
    def __eq__(self, other: IPv6Network) -> bool:
        return self.address == other.address and self.mask_len == other.mask_len

    def __hash__(self) -> int:
        return safe_hash(hash(self.address) + 137 * hash(self.mask_len))

class DateTime:
    @property
    year: int
    @property
    month: int
    @property
    day: int
    @property
    hour: int
    @property
    minute: int
    @property
    second: int
    @property
    microsecond: int
    @property
    timezone_hour: ?int
    @property
    timezone_minute: ?int

    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, microsecond: int, timezone_hour: ?int, timezone_minute: ?int):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second
        self.microsecond = microsecond
        self.timezone_hour = timezone_hour
        self.timezone_minute = timezone_minute

    def __str__(self) -> str:
        tz = ""
        tz_h = self.timezone_hour
        tz_m = self.timezone_minute
        if tz_h is not None and tz_m is not None:
            if tz_h == 0 and tz_m == 0:
                tz = "Z"
            else:
                # The nso java-api seems to be missing a way to represent negative offsets less than one hour
                # e.g. "-0:30" as the sign is carried by the 'hour' integer
                # TODO: Test actual nso behavour
                if tz_h == 0 and tz_m < 0:
                    tz = "-" + str(tz_h) + ":" + str(tz_m)
                else:
                    tz = str(tz_h) + ":" + str(tz_m)

        return to_n_dec_str(self.year, 4) + "-" + to_n_dec_str(self.month, 2) + "-" + to_n_dec_str(self.day, 2) + "T" \
            + to_n_dec_str(self.hour, 2) + ":" + to_n_dec_str(self.minute, 2) + ":" + to_n_dec_str(self.second, 2) + "." + to_n_dec_str(self.microsecond, 6) \
            + tz

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?DateTime:
        s = s.strip(" ")
        p = s.split("T", -1)
        if len(p) != 2:
            return None

        p0: str = p[0]
        p1: str = p[1]

        p_date = p0.split("-", 3)
        if len(p_date) != 3:
            return None

        _year = try_parse_int(p_date[0])
        _month = try_parse_int(p_date[1])
        _day = try_parse_int(p_date[2])

        p_time = p1.split(":", -1)
        _hour = try_parse_int(p_time[0])
        _minute = try_parse_int(p_time[1])

        p_rest: str = p_time[2]
        p_sec = ""
        p_tz = ""
        p_tz_sign = "+"
        _tz_h = None
        _tz_m = None

        p_z = p_rest.split("Z", -1)
        if len(p_z) >= 2:
            p_sec = p_z[0]
            _tz_h = 0
            _tz_m = 0
        else:
            p_ptz = p_rest.split("+", -1)
            if len(p_ptz) >= 2:
                p_sec = p_ptz[0]
                p_tz = p_ptz[1]
            else:
                p_ptz = p_rest.split("-", -1)
                if len(p_ptz) >= 2:
                    p_sec = p_ptz[0]
                    p_tz_sign = "-"
                    p_tz = p_ptz[1]
                else:
                    p_sec = p_rest

        _seconds = Decimal64.try_parse(p_sec)

        if p_tz:
            pp_tz = p_tz.split(":", -1)
            if len(pp_tz) >= 1:
                _tz_h = try_parse_int(pp_tz[0])
                if len(pp_tz) >= 2:
                    _tz_m = try_parse_int(pp_tz[1])
                else:
                    _tz_m = 0
                if p_tz_sign == "-":
                    if eq_optional(_tz_h, 0) and eq_optional(_tz_m, 0):
                        _tz_h = None
                        _tz_m = None
                    else:
                        # Is the sign for tz_minutes inherited from tz_hour or is it independent?
                        # TODO: Test actual nso behavour
                        if _tz_h is not None:
                            _tz_h = -_tz_h
                        if _tz_m is not None:
                            _tz_m = -_tz_m

        if isinstance(_year, int) and isinstance(_month, int) and isinstance(_day, int) \
                and isinstance(_hour, int) and isinstance(_minute, int) and isinstance(_seconds, Decimal64):
            _microseconds = _seconds.fractional_part().try_lossless_realign(-6)
            if _microseconds is not None:
                return DateTime(_year, _month, _day, _hour, _minute, _seconds.integral_part(), _microseconds.significand, _tz_h, _tz_m)

        return None

    # @staticmethod
    # def try_parse(s: str, fmt: str):
    #     pass

    # @staticmethod
    # def try_parse_iso(s: str):
    #     return DateTime.try_parse(s, "%Y-%m-%dT%H:%M:%S.%f%z")

extension DateTime(Hashable):
    def __eq__(self, other: DateTime) -> bool:
        return \
            self.year == other.year and \
            self.month == other.month and \
            self.day == other.day and \
            self.hour == other.hour and \
            self.minute == other.minute and \
            self.second == other.second and \
            self.microsecond == other.microsecond and \
            eq_optional(self.timezone_hour, other.timezone_hour) and \
            eq_optional(self.timezone_minute, other.timezone_minute)

    def __hash__(self) -> int:
        _tz_h = self.timezone_hour
        _tz_m = self.timezone_minute
        return safe_hash(
            23 * hash(self.year) +
            19 * hash(self.month) +
            17 * hash(self.day) +
            13 * hash(self.hour) +
            11 * hash(self.minute) +
            7 * hash(self.second) +
            5 * hash(self.microsecond) +
            (3 * hash(_tz_h)) if _tz_h is not None else 0 +
            (2 * hash(_tz_m)) if _tz_m is not None else 0)

class Date:
    @property
    year: int
    @property
    month: int
    @property
    day: int
    @property
    timezone_hour: ?int
    @property
    timezone_minute: ?int

    def __init__(self, year: int, month: int, day: int, timezone_hour: ?int, timezone_minute: ?int):
        self.year = year
        self.month = month
        self.day = day
        self.timezone_hour = timezone_hour
        self.timezone_minute = timezone_minute

    def __str__(self) -> str:
        tz = ""
        tz_h = self.timezone_hour
        tz_m = self.timezone_minute
        if tz_h is not None and tz_m is not None:
            if tz_h == 0 and tz_m == 0:
                tz = "Z"
            else:
                # The nso java-api seems to be missing a way to represent negative offsets less than one hour
                # e.g. "-0:30" as the sign is carried by the 'hour' integer
                # TODO: Test actual nso behavour
                if tz_h == 0 and tz_m < 0:
                    tz = "-" + str(tz_h) + ":" + str(tz_m)
                else:
                    tz = str(tz_h) + ":" + str(tz_m)

        return to_n_dec_str(self.year, 4) + "-" + to_n_dec_str(self.month, 2) + "-" + to_n_dec_str(self.day, 2) + tz

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?Date:
        s = s.strip(" ")

        p_date = s.split("-", 3)
        if len(p_date) != 3:
            return None

        _year = try_parse_int(p_date[0])
        _month = try_parse_int(p_date[1])

        p_rest: str = p_date[2]
        p_day = ""
        p_tz = ""
        p_tz_sign = "+"
        _tz_h = None
        _tz_m = None

        p_z = p_rest.split("Z", -1)
        if len(p_z) >= 2:
            p_day = p_z[0]
            _tz_h = 0
            _tz_m = 0
        else:
            p_ptz = p_rest.split("+", -1)
            if len(p_ptz) >= 2:
                p_day = p_ptz[0]
                p_tz = p_ptz[1]
            else:
                p_ptz = p_rest.split("-", -1)
                if len(p_ptz) >= 2:
                    p_day = p_ptz[0]
                    p_tz_sign = "-"
                    p_tz = p_ptz[1]
                else:
                    p_day = p_rest

        _day = try_parse_int(p_day)

        if p_tz:
            pp_tz = p_tz.split(":", -1)
            if len(pp_tz) >= 1:
                _tz_h = try_parse_int(pp_tz[0])
                if len(pp_tz) >= 2:
                    _tz_m = try_parse_int(pp_tz[1])
                else:
                    _tz_m = 0
                if p_tz_sign == "-":
                    if eq_optional(_tz_h, 0) and eq_optional(_tz_m, 0):
                        _tz_h = None
                        _tz_m = None
                    else:
                        # Is the sign for tz_minutes inherited from tz_hour or is it independent?
                        # TODO: Test actual nso behavour
                        if _tz_h is not None:
                            _tz_h = -_tz_h
                        if _tz_m is not None:
                            _tz_m = -_tz_m

        if isinstance(_year, int) and isinstance(_month, int) and isinstance(_day, int):
            return Date(_year, _month, _day, _tz_h, _tz_m)

        return None

extension Date(Hashable):
    def __eq__(self, other: Date) -> bool:
        return \
            self.year == other.year and \
            self.month == other.month and \
            self.day == other.day and \
            eq_optional(self.timezone_hour, other.timezone_hour) and \
            eq_optional(self.timezone_minute, other.timezone_minute)

    def __hash__(self) -> int:
        _tz_h = self.timezone_hour
        _tz_m = self.timezone_minute
        return safe_hash(
            11 * hash(self.year) +
            7 * hash(self.month) +
            5 * hash(self.day) +
            (3 * hash(_tz_h)) if _tz_h is not None else 0 +
            (2 * hash(_tz_m)) if _tz_m is not None else 0)

class Time:
    @property
    hour: int
    @property
    minute: int
    @property
    second: int
    @property
    microsecond: int
    @property
    timezone_hour: ?int
    @property
    timezone_minute: ?int

    def __init__(self, hour: int, minute: int, second: int, microsecond: int, timezone_hour: ?int, timezone_minute: ?int):
        self.hour = hour
        self.minute = minute
        self.second = second
        self.microsecond = microsecond
        self.timezone_hour = timezone_hour
        self.timezone_minute = timezone_minute

    def __str__(self) -> str:
        tz = ""
        tz_h = self.timezone_hour
        tz_m = self.timezone_minute
        if tz_h is not None and tz_m is not None:
            if tz_h == 0 and tz_m == 0:
                tz = "Z"
            else:
                # The nso java-api seems to be missing a way to represent negative offsets less than one hour
                # e.g. "-0:30" as the sign is carried by the 'hour' integer
                # TODO: Test actual nso behavour
                if tz_h == 0 and tz_m < 0:
                    tz = "-" + str(tz_h) + ":" + str(tz_m)
                else:
                    tz = str(tz_h) + ":" + str(tz_m)

        return to_n_dec_str(self.hour, 2) + ":" + to_n_dec_str(self.minute, 2) + ":" + to_n_dec_str(self.second, 2) + "." + to_n_dec_str(self.microsecond, 6) + tz

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?Time:
        s = s.strip(" ")

        p_time = s.split(":", -1)
        _hour = try_parse_int(p_time[0])
        _minute = try_parse_int(p_time[1])

        p_rest: str = p_time[2]
        p_sec = ""
        p_tz = ""
        p_tz_sign = "+"
        _tz_h = None
        _tz_m = None

        p_z = p_rest.split("Z", -1)
        if len(p_z) >= 2:
            p_sec = p_z[0]
            _tz_h = 0
            _tz_m = 0
        else:
            p_ptz = p_rest.split("+", -1)
            if len(p_ptz) >= 2:
                p_sec = p_ptz[0]
                p_tz = p_ptz[1]
            else:
                p_ptz = p_rest.split("-", -1)
                if len(p_ptz) >= 2:
                    p_sec = p_ptz[0]
                    p_tz_sign = "+"
                    p_tz = p_ptz[1]
                else:
                    p_sec = p_rest

        _seconds = Decimal64.try_parse(p_sec)

        if p_tz:
            pp_tz = p_tz.split(":", -1)
            if len(pp_tz) >= 1:
                _tz_h = try_parse_int(pp_tz[0])
                if len(pp_tz) >= 2:
                    _tz_m = try_parse_int(pp_tz[1])
                else:
                    _tz_m = 0
                if p_tz_sign == "-":
                    if eq_optional(_tz_h, 0) and eq_optional(_tz_m, 0):
                        _tz_h = None
                        _tz_m = None
                    else:
                        # Is the sign for tz_minutes inherited from tz_hour or is it independent?
                        # TODO: Test actual nso behavour
                        if _tz_h is not None:
                            _tz_h = -_tz_h
                        if _tz_m is not None:
                            _tz_m = -_tz_m

        if isinstance(_hour, int) and isinstance(_minute, int) and isinstance(_seconds, Decimal64):
            _microseconds = _seconds.fractional_part().try_lossless_realign(-6)
            if _microseconds is not None:
                return Time(_hour, _minute, _seconds.integral_part(), _microseconds.significand, _tz_h, _tz_m)

        return None

extension Time(Hashable):
    def __eq__(self, other: Time) -> bool:
        return \
            self.hour == other.hour and \
            self.minute == other.minute and \
            self.second == other.second and \
            self.microsecond == other.microsecond and \
            eq_optional(self.timezone_hour, other.timezone_hour) and \
            eq_optional(self.timezone_minute, other.timezone_minute)

    def __hash__(self) -> int:
        _tz_h = self.timezone_hour
        _tz_m = self.timezone_minute
        return safe_hash(
            13 * hash(self.hour) +
            11 * hash(self.minute) +
            7 * hash(self.second) +
            5 * hash(self.microsecond) +
            (3 * hash(_tz_h)) if _tz_h is not None else 0 +
            (2 * hash(_tz_m)) if _tz_m is not None else 0)

class Duration:
    @property
    year: int
    @property
    month: int
    @property
    day: int
    @property
    hour: int
    @property
    minute: int
    @property
    second: int
    @property
    microsecond: int

    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int, microsecond: int):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second
        self.microsecond = microsecond

    def __str__(self) -> str:
        sl = ["P"]
        if self.year != 0:
            unsafe_list_append(sl, str(self.year))
            unsafe_list_append(sl, "Y")
        if self.month != 0:
            unsafe_list_append(sl, str(self.month))
            unsafe_list_append(sl, "M")
        if self.day != 0:
            unsafe_list_append(sl, str(self.day))
            unsafe_list_append(sl, "D")
        if self.hour != 0 or self.minute != 0 or self.second != 0 or self.microsecond != 0:
            unsafe_list_append(sl, "T")
            if self.hour != 0:
                unsafe_list_append(sl, str(self.hour))
                unsafe_list_append(sl, "H")
            if self.minute != 0:
                unsafe_list_append(sl, str(self.minute))
                unsafe_list_append(sl, "M")
            if self.second != 0 or self.microsecond != 0:
                if self.microsecond == 0:
                    unsafe_list_append(sl, str(self.second))
                else:
                    unsafe_list_append(sl, str(Decimal64(self.second * 10**6 + self.microsecond, 6)))
                unsafe_list_append(sl, "S")
        return "".join(sl)

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    @staticmethod
    def try_parse(s: str) -> ?Duration:
        fmt = "PYMDTHMS"
        fmt_len = len(fmt)
        s = s.strip(" PT")

        _year: ?int = 0
        _month: ?int = 0
        _day: ?int = 0
        _hour: ?int = 0
        _minute: ?int = 0
        _seconds: ?Decimal64 = Decimal64(0, 0)

        fmt_i = 0
        n_begin = 0
        n_end = 0

        for i in range(0, len(s), 1):
            c = s[i]
            if c.isdecimal() or c == ".":
                n_end += 1
            else:
                while True:
                    if c != fmt[fmt_i]:
                        fmt_i += 1
                        if fmt_i >= fmt_len:
                            return None
                        else:
                            continue

                    if c == 'P':
                        if n_begin != n_end:
                            return None
                    if c == 'Y':
                        _year = try_parse_int(s[n_begin:n_end:1])
                    elif c == 'M':
                        _month = try_parse_int(s[n_begin:n_end:1])
                    elif c == 'D':
                        _day = try_parse_int(s[n_begin:n_end:1])
                    elif c == 'T':
                        if n_begin != n_end:
                            return None
                    elif c == 'H':
                        _hour = try_parse_int(s[n_begin:n_end:1])
                    elif c == 'M':
                        _minute = try_parse_int(s[n_begin:n_end:1])
                    elif c == 'S':
                        _seconds = Decimal64.try_parse(s[n_begin:n_end:1])
                    n_end += 1
                    n_begin = n_end
                    fmt_i += 1

        if isinstance(_year, int) and isinstance(_month, int) and isinstance(_day, int) \
                and isinstance(_hour, int) and isinstance(_minute, int) and isinstance(_seconds, Decimal64):
            _microseconds = _seconds.fractional_part().try_lossless_realign(-6)
            if _microseconds is not None:
                return Duration(_year, _month, _day, _hour, _minute, _seconds.integral_part(), _microseconds.significand)

        return None

extension Duration(Hashable):
    def __eq__(self, other: Duration) -> bool:
        return \
            self.year == other.year and \
            self.month == other.month and \
            self.day == other.hour and \
            self.hour == other.hour and \
            self.minute == other.minute and \
            self.second == other.second and \
            self.microsecond == other.microsecond

    def __hash__(self) -> int:
        return safe_hash(
            23 * hash(self.year) +
            19 * hash(self.month) +
            17 * hash(self.day) +
            13 * hash(self.hour) +
            11 * hash(self.minute) +
            7 * hash(self.second) +
            5 * hash(self.microsecond))

class Oid:
    _ids: list[int]

    def __init__(self, ids: list[int]):
        self._ids = ids

    def __str__(self) -> str:
        #return ".".join(str(_id) for _id in self._ids)
        sl = []
        for _id in self._ids:
            unsafe_list_append(sl, str(_id))
        return ".".join(sl)

    def __repr__(self):
        return self.__str__() # TODO: Proper repr

    def ids(self) -> list[int]:
        return self._ids

extension Oid(Hashable):
    def __eq__(self, other: Oid) -> bool:
        # return self._ids == other._ids
        self_len = len(self._ids)
        if self_len != len(other._ids):
            return False
        for i in range(0, self_len, 1):
            if not self._ids[i] == other._ids[i]:
                return False
        return True

    def __hash__(self) -> int:
        _hash: int = 0
        for _id in self._ids:
            _hash = _hash * 7 + hash(_id)
        return safe_hash(_hash)
