from acton_streamer.common.mod import *
from acton_streamer.common.utils import *
from acton_streamer.nsoapi.cdb import *
from acton_streamer.nsoapi.conf import *
from acton_streamer.nsoapi.conv import *
from acton_streamer.nsoapi.proto import *
from acton_streamer.nsoapi.schema import *

class Refiner(object):
    @property
    priority: int
    @property
    subscription_dependencies: list[Keypath]
    @property
    refiner_dependencies: list[int]

    def __init__(self):
        raise Exception("Not Implemented")

    @staticmethod
    def id() -> int:
        raise Exception("Not Implemented")

    mut def update(self, tree: TNode, input_subs: dict[Keypath, list[Keypath]], input_refiners: dict[int, (Refiner, list[Keypath])]) -> list[Keypath]:
        raise Exception("Not Implemented")

    def state(self, keys: Keypath) -> ?value:
        raise Exception("Not Implemented")

# extension Refiner(Ord):
#     def __eq__(self, other) -> bool:
#         self.priority == other.priority and self.id() == other.id()

#     def __lt__(self, other) -> bool:
#         return self.priority < other.priority #or self == other and self.id < other.id

# Workaround for https://github.com/actonlang/acton/issues/1126
extension Refiner(Ord2):
    def eq(self, other) -> bool:
        return self.priority == other.priority and self.id() == other.id()

    def lt(self, other) -> bool:
        return self.priority < other.priority #or self == other and self.id < other.id

extension Refiner(Hashable):
    def __eq__(self, other) -> bool:
        return self.priority == other.priority and self.id() == other.id()

    def __hash__(self) -> int:
        return safe_hash(self.id() + 1000002043 * self.priority)

def _get_subpath_num_keys(sub_path: Keypath) -> int:
    c = 0
    for _id in sub_path:
        if isinstance(_id, Key):
            c += 1
    return c

def _get_subpath_keys(node: TNode, max_keys: int) -> list[Keypath]:
    """
        Invariant:
            Tree (node) is of a single subscription path where max_keys is the number of keys in that subscription path.
            i.e. no container siblings within the subscription path
    """

    if max_keys < 1:
        return []

    keys: list[Keypath] = []
    curr_keys: list[Id] = []
    stack: list[TTree] = []

    if isinstance(node, TTree):
        stack.append(node)

        while stack:
            n = list_pop(stack)
            key = n.key()
            if key is not None:
                curr_keys.append(key)
                if len(curr_keys) >= max_keys:
                    keys.append(Keypath(list(curr_keys)))
                    list_pop(curr_keys)
                    continue
            for c in list_reversed(list(n.iter())):
                if isinstance(c, TTree):
                    stack.append(c)
    return keys

actor ConfigCache(cdb_sub_conn: CdbConnection,
            cdb_cmd_conn: CdbConnection,
            shared_schema: SharedSchema,
            refiner_ctors: list[pure() -> Refiner],
            callbacks: list[(list[int], action(dict[int, list[(Keypath, ?value)]]) -> None)],
            on_error: action(Exception) -> None):

    var _refiners: dict[int, Refiner] = {}
    var _callback_indexes: dict[int, list[int]] = {}

    #var _schema = shared_schema.shared_schema()
    var _schema = unsafe_get_shared_schema(shared_schema)

    var _sub_ids: dict[int, (Keypath, int, set[Refiner])] = {}
    var __refiner_dependents: dict[Refiner, list[Refiner]] = {}

    var _pending_sub_ids: list[int] = []
    var _pending_sub_modifications: list[(int, EList)] = []

    var _root = TTree(OP_NONE, PTag.root(), None, {})

    def _assign_priority(r: Refiner):
        if r.priority == 0:
            #r.priority = 1 + max([_assign_priority(_refiners[i]) for i in r.refiner_dependencies], 0)
            mp = 0
            for i in r.refiner_dependencies:
                dp = _assign_priority(_refiners[i])
                if dp > mp:
                    mp = dp
            r.priority = 1 + mp
        return r.priority

    sub_paths: set[Keypath] = set([])

    for c in refiner_ctors:
        r = c()
        #sub_paths.update(r.subscription_dependencies)
        set_update(sub_paths, r.subscription_dependencies)
        if r.id() in _refiners:
            raise ValueError("ConfigCache: Attempted to register duplicate refiner-id")
        _refiners[r.id()] = r

    for r in _refiners.values():
        _assign_priority(r)
        for refiner_id in r.refiner_dependencies:
            dependency = _refiners[refiner_id]
            dict_list_append(__refiner_dependents, dependency, r)

    for i in range(0, len(callbacks), 1):
        dependency_ids = callbacks[i].0
        for dependency_id in dependency_ids:
            dict_list_append(_callback_indexes, dependency_id, i)

    def update() -> None:
        updated_sub_paths: dict[Keypath, list[Keypath]] = {}
        updated_refiners: dict[Refiner, list[Keypath]] = {}
        scheduled_refiners: set[Refiner] = set([])

        #schedule_heap: MinHeap[Refiner] = MinHeap()
        schedule_heap: MinHeap_Ord2[Refiner] = MinHeap_Ord2()

        for sub_id, etvs in _pending_sub_modifications:
            merge_root = etagvals_to_ttree(etvs, Cursor(_schema))
            if isinstance(merge_root, TTree):
                #print("Got ttree: " + str(merge_root))
                _root.merge(merge_root)
                #print("New root: " + str(_root))

                sub_entry = try_get(_sub_ids, sub_id)
                if sub_entry is not None:
                    sub_path, max_keys, refiners = sub_entry
                    keys = _get_subpath_keys(merge_root, max_keys)
                    #print("Got keys: " + list_str(keys))
                    updated_sub_paths[sub_path] = keys
                    for refiner in refiners:
                        if refiner not in scheduled_refiners:
                            #schedule_heap.insert(refiner)
                            MinHeap_Ord2.insert(schedule_heap, refiner)
                            scheduled_refiners.add(refiner)

            elif isinstance(merge_root, Exception):
                on_error(Exception("Get modifications to tnode conversion error: " + merge_root.error_message))

        _pending_sub_modifications.clear()

        while True:
            #curr_refiner = schedule_heap.try_pop()
            curr_refiner = MinHeap_Ord2.try_pop(schedule_heap) # https://github.com/actonlang/acton/issues/1448
            if curr_refiner is not None:
                input_subs: dict[Keypath, list[Keypath]] = {}
                input_refiners: dict[int, (Refiner, list[Keypath])] = {}
                for sub_path in curr_refiner.subscription_dependencies:
                    input_subs[sub_path] = updated_sub_paths.get(sub_path, [])
                for dependency_id in curr_refiner.refiner_dependencies:
                    dependency = _refiners[dependency_id]
                    input_refiners[dependency_id] = (dependency, updated_refiners.get(dependency, []))
                updated_keys = curr_refiner.update(_root, input_subs, input_refiners)
                updated_refiners[curr_refiner] = updated_keys
                dependents = try_get(__refiner_dependents, curr_refiner)
                if dependents is not None:
                    for dependent in dependents:
                        if dependent not in scheduled_refiners:
                            #schedule_heap.insert(dependent)
                            MinHeap_Ord2.insert(schedule_heap, dependent) # https://github.com/actonlang/acton/issues/1448
                            scheduled_refiners.add(dependent)
            else:
                break

        trigger_callback_indexes: set[int] = set([])
        for refiner in scheduled_refiners:
            refiner_id = refiner.id()
            set_update(trigger_callback_indexes, _callback_indexes.get(refiner_id, []))
        for callback_index in trigger_callback_indexes:
            dependency_ids: list[int], callback: action(dict[int, list[(Keypath, ?value)]]) -> None = callbacks[callback_index]
            args: dict[int, list[(Keypath, ?value)]] = {}
            for dependency_id in dependency_ids:
                dependency = _refiners[dependency_id]
                updates: list[(Keypath, ?value)] = []
                for keys in updated_refiners.get(dependency, []):
                    updates.append((keys, dependency.state(keys)))
                args[dependency_id] = updates

            callback(args)

    def _on_sub_event(c: CdbConnection, v: value) -> None:
        if isinstance(v, list):
            print("Sub event: Triggered sub-ids:", v)
            _pending_sub_ids = v
            _do_get_modifications()
        elif isinstance(v, Exception):
            print("Sub event error:", v.error_message)
            on_error(Exception("Sub event error: " + v.error_message))
        else:
            print("Sub event error:", v)
            on_error(Exception("Sub event error: " + str(v)))

    def _do_get_modifications():
        #if _pending_sub_ids:
        if len(_pending_sub_ids) > 0:
            sub_id = list_pop(_pending_sub_ids)
            # TODO: Why does setting a ?EKeypath parameter to None result in actonc: Cannot infer None < acton_streamer.nsoapi.conf.EKeypath
            #cdb_sub_conn.get_modifications(sub_id, CDB_GET_MODS_INCLUDE_LISTS | CDB_GET_MODS_WANT_ANCESTOR_DELETE, None, _on_get_modifications)
            cdb_sub_conn.get_modifications(sub_id, CDB_GET_MODS_INCLUDE_LISTS | CDB_GET_MODS_WANT_ANCESTOR_DELETE, EKeypath([]), lambda c, v: _on_get_modifications(c, v, sub_id))
        else:
            cdb_sub_conn.sync_subscription_socket(CDB_SUB_SYNC_DONE_PRIORITY, _on_sync_subscription_socket, _on_sub_event)

    def _on_get_modifications(c: CdbConnection, v: value, sub_id: int):
        if isinstance(v, EList):
            #
            print(v)
            #
            _pending_sub_modifications.append((sub_id, v))
            _do_get_modifications()
        elif isinstance(v, Exception):
            print("Get modifications error:", v.error_message)
            on_error(Exception("Get modifications error: " + v.error_message))
        else:
            print("Get modifications error:", v)
            on_error(Exception("Get modifications error: " + str(v)))

    def _on_sync_subscription_socket(c: CdbConnection, v: ?Exception):
        if v is not None:
            on_error(Exception("Sub sync error: " + str(v.error_message)))
        update()

    def _on_subscription_success(sub_ids: dict[Keypath, int]) -> None:
        for sub_path, sub_id in sub_ids.items():
            _sub_ids[sub_id] = (sub_path, _get_subpath_num_keys(sub_path), set([]))
        for refiner in _refiners.values():
            sub_paths = refiner.subscription_dependencies
            for sub_path in sub_paths:
                sub_id = try_get(sub_ids, sub_path)
                if sub_id is not None:
                    _sub_ids[sub_id].2.add(refiner)

        cdb_cmd_conn.trigger_subscriptions(list(_sub_ids.keys()), _on_trigger_subscriptions)

    def _on_trigger_subscriptions(c: CdbConnection, v: ?Exception):
        if v is not None:
            on_error(Exception("Initial trigger_subscriptions error: " + str(v.error_message)))

    _SubscriptionSetup(cdb_sub_conn, sub_paths, shared_schema, _on_sub_event, _on_subscription_success, on_error)

actor _SubscriptionSetup(cdb_sub_conn: CdbConnection, subscription_paths: set[Keypath], shared_schema: SharedSchema,
                            sub_event_cb: action(CdbConnection, value) -> None,
                            on_success: action(dict[Keypath, int]) -> None, on_error: action(Exception) -> None):

    #var _schema = shared_schema.shared_schema()
    var _schema = unsafe_get_shared_schema(shared_schema)

    var _subscription_points: dict[Keypath, int] = {}

    def _do_subscribe():
        #if paths:
        if len(subscription_paths) != 0:
            path = subscription_paths.pop()
            #ekp = keypath_to_ekeypath(path, Cursor(_schema), False)
            # Luckily IKP works for subscriptions as HKP paths with namespace transitions fail
            # during subscribe_done with error i ncserr.log where it tries to lookup a tag with the parent
            # namespace rather then the one actually specified!
            ekp = keypath_to_ekeypath(path, Cursor(_schema), True)
            if ekp is not None:
                cdb_sub_conn.subscribe(CDB_SUB_TYPE_RUNNING, 0, 0, ekp, lambda c, v: _on_subscribe(c, v, path))
            else:
                on_error(ValueError("Invalid subscription path"))
        else:
            cdb_sub_conn.subscribe_done(_on_subscribe_done, sub_event_cb)

    def _on_subscribe(c, v, kp):
        if isinstance(v, int):
            _subscription_points[kp] = v
            _do_subscribe()
        else:
            on_error(ValueError("Invalid subscription path"))

    def _on_subscribe_done(c, e):
        if e is not None:
            on_error(ValueError("Subscribe_done failed"))
        else:
            on_success(_subscription_points)

    _do_subscribe()
