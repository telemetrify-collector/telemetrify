import nsoapi.conf as conf
from nsoapi.conf import *
from nsoapi.proto import *
from nsoapi.utils import *

# confd_cs_node.flags
CS_NODE_IS_LIST: i64 = 1
CS_NODE_IS_WRITE: i64 = 1 << 1
CS_NODE_IS_CDB: i64 = 1 << 2
CS_NODE_IS_ACTION: i64 = 1 << 3
CS_NODE_IS_PARAM: i64 = 1 << 4
CS_NODE_IS_RESULT: i64 = 1 << 5
CS_NODE_IS_NOTIF: i64 = 1 << 6
CS_NODE_IS_CASE: i64 = 1 << 7
CS_NODE_IS_CONTAINER: i64 = 1 << 8
CS_NODE_HAS_WHEN: i64 = 1 << 9
CS_NODE_HAS_DISPLAY_WHEN: i64 = 1 << 10
CS_NODE_META_DATA: i64 = 1 << 11
CS_NODE_IS_WRITE_ALL: i64 = 1 << 12
CS_NODE_IS_LEAF_LIST: i64 = 1 << 13
CS_NODE_IS_LEAFREF: i64 = 1 << 14
CS_NODE_HAS_MOUNT_POINT: i64 = 1 << 15
CS_NODE_IS_STRING_AS_BINARY: i64 = 1 << 16

# confd value range flags
CONFD_RANGE_MIN_INCLUSIVE: i64 = 1
CONFD_RANGE_MIN_EXCLUSIVE: i64 = 1 << 1
CONFD_RANGE_MAX_INCLUSIVE: i64 = 1 << 2
CONFD_RANGE_MAX_EXCLUSIVE: i64 = 1 << 3

# NODE_NP_CONTAINER = 1
# NODE_P_CONTAINER = 2
# NODE_LIST = 3
# NODE_EMPTY_LEAF = 5
# NODE_NON_EMPTY_LEAF = 6
# NODE_LEAF_LIST = 7
# # NODE_ACTION = 16 # action/rpc
# # NODE_PARAM = 17
# # NODE_RESULT = 18
# # NODE_NOTIFICATION = 32

ROOT_MOUNT_ID = HTag(0, 0)

class Schema:
    @property
    _roots: HTagDict[Node]
    @property
    _nshash_to_namespace: dict[int, NamespaceDescription]
    @property
    _cns_to_namespace: dict[str, NamespaceDescription]
    @property
    _hash_to_name: dict[int, str]
    @property
    _name_to_hash: dict[str, int]
    @property
    _mount_id_maps: dict[HTag, NamespaceMaps]

    def __init__(self,
                    roots: HTagDict[Node],
                    nshash_to_namespace: dict[int, NamespaceDescription],
                    cns_to_namespace: dict[str, NamespaceDescription],
                    hash_to_name: dict[int, str],
                    name_to_hash: dict[str, int],
                    mount_id_maps: dict[HTag, NamespaceMaps]):
        self._roots = roots
        self._nshash_to_namespace = nshash_to_namespace
        self._cns_to_namespace = cns_to_namespace
        self._hash_to_name = hash_to_name
        self._name_to_hash = name_to_hash
        self._mount_id_maps = mount_id_maps

    def cns_to_namespace(self, cns: str) -> ?NamespaceDescription:
        return try_get(self._cns_to_namespace, cns)

    def nshash_to_namespace(self, ns_hash: int) -> ?NamespaceDescription:
        return try_get(self._nshash_to_namespace, ns_hash)

    def hash_to_name(self, _hash: int) -> ?str:
        return try_get(self._hash_to_name, _hash)

    def name_to_hash(self, name: str) -> ?int:
        return try_get(self._name_to_hash, name)

    def mount_id_map(self, mount_id: HTag) -> ?NamespaceMaps:
        return try_get(self._mount_id_maps, mount_id)

class Cursor:
    @property
    _schema: Schema
    @property
    _path: list[Node]
    @property
    _mount_points: list[?(HTag, NamespaceMaps)]

    def __init__(self, schema: Schema):
        self._schema = schema
        self._path = []
        _mount_points = []

    def push(self, tag: Tag) -> bool:
        node: ?Node = None
        raise Exception("Not Implemented")
        if node is not None:
            if node.is_mount_point():
                self._mount_points.append(None)

    def pop(self):
        path = self._path
        if len(path) >= 1:
            node: Node = path[-1]
            if node.is_mount_point():
                #self._mount_points.pop()
                del self._mount_points[-1:]
        #path.pop()
        del path[-1:]

    def set_mount_id(self: Cursor, mount_id: HTag) -> bool:
        ns_maps = self._schema.mount_id_map(mount_id)
        if ns_maps is not None:
            self._mount_points[-1] = (mount_id, ns_maps)
            return True
        return False

    def node(self: Cursor) -> Node:
        return self._path[-1]

    def prefix_to_namespace(self, prefix: str) -> ?NamespaceDescription:
        mount_points = self._mount_points
        for i in range(len(mount_points)-1, -1, -1):
            entry: ?(HTag, NamespaceMaps) = mount_points[i]
            if entry is not None:
                nsmaps: NamespaceMaps = entry.1
                ns_descr = try_get(nsmaps.prefix_to_namespace, prefix)
                if ns_descr is not None:
                    return ns_descr
        return None

    def ns_to_namespace(self, ns: str) -> ?NamespaceDescription:
        mount_points = self._mount_points
        for i in range(len(mount_points)-1, -1, -1):
            entry: ?(HTag, NamespaceMaps) = mount_points[i]
            if entry is not None:
                nsmaps: NamespaceMaps = entry.1
                ns_descr = try_get(nsmaps.ns_to_namespace, ns)
                if ns_descr is not None:
                    return ns_descr
        return None

    def module_to_namespace(self, module: str) -> ?NamespaceDescription:
        mount_points = self._mount_points
        for i in range(len(mount_points)-1, -1, -1):
            entry: ?(HTag, NamespaceMaps) = mount_points[i]
            if entry is not None:
                nsmaps: NamespaceMaps = entry.1
                ns_descr = try_get(nsmaps.module_to_namespace, module)
                if ns_descr is not None:
                    return ns_descr
        return None

    def cns_to_namespace(self, cns: str) -> ?NamespaceDescription:
        return self._schema.cns_to_namespace(cns)

    def prefix_to_ns(self, prefix: str) -> ?str:
        ns_descr = self.prefix_to_namespace(prefix)
        if ns_descr is not None:
            return ns_descr.ns
        return None

    def prefix_to_nshash(self, prefix: str) -> ?int:
        ns_descr = self.prefix_to_namespace(prefix)
        if ns_descr is not None:
            return ns_descr.ns_hash
        return None

    def ns_to_nshash(self, ns: str) -> ?int:
        ns_descr = self.ns_to_namespace(ns)
        if ns_descr is not None:
            return ns_descr.ns_hash
        return None

    def ns_to_prefix(self, ns: str) -> ?str:
        ns_descr = self.ns_to_namespace(ns)
        if ns_descr is not None:
            return ns_descr.prefix
        return None

    def module_to_ns(self, module: str) -> ?str:
        ns_descr = self.module_to_namespace(module)
        if ns_descr is not None:
            return ns_descr.ns
        return None

    def module_to_nshash(self, module: str) -> ?int:
        ns_descr = self.module_to_namespace(module)
        if ns_descr is not None:
            return ns_descr.ns_hash
        return None

    def nshash_to_prefix(self, ns_hash: int) -> ?str:
        ns_descr = self._schema.nshash_to_namespace(ns_hash)
        if ns_descr is not None:
            return ns_descr.prefix
        return None

    def nshash_to_ns(self, ns_hash: int) -> ?str:
        ns_descr = self._schema.nshash_to_namespace(ns_hash)
        if ns_descr is not None:
            return ns_descr.ns
        return None

    def nshash_to_module(self, ns_hash: int) -> ?str:
        ns_descr = self._schema.nshash_to_namespace(ns_hash)
        if ns_descr is not None:
            return ns_descr.module
        return None

    def lookup_ptag(self, tag: Tag) -> ?PTag:
        if isinstance(tag, PTag):
            return tag
        elif isinstance(tag, ITag):
            _ns = tag.ns
            if _ns is not None:
                prefix = self.ns_to_prefix(_ns)
                if prefix is not None:
                    return PTag(prefix, tag.name)
            elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                return PTag(None, tag.name)
        elif isinstance(tag, HTag):
            name = self._schema.hash_to_name(tag.name_hash)
            if name is not None:
                if tag.ns_hash != 0:
                    return PTag(None, name)
                elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                    prefix = self.nshash_to_prefix(tag.ns_hash)
                    if prefix is not None:
                        return PTag(prefix, name)
        return None

    def lookup_itag(self, tag: Tag) -> ?ITag:
        if isinstance(tag, ITag):
            return tag
        elif isinstance(tag, PTag):
            _prefix = tag.prefix
            if _prefix is not None:
                ns = self.prefix_to_ns(_prefix)
                if ns is not None:
                    return ITag(ns, tag.name)
            elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                return ITag(None, tag.name)
        elif isinstance(tag, HTag):
            name = self._schema.hash_to_name(tag.name_hash)
            if name is not None:
                if tag.ns_hash != 0:
                    return ITag(None, name)
                elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                    ns = self.nshash_to_ns(tag.ns_hash)
                    if ns is not None:
                        return ITag(ns, name)
        return None

    def lookup_htag(self, tag: Tag) -> ?HTag:
        if isinstance(tag, HTag):
            return tag
        elif isinstance(tag, PTag):
            name_hash = self._schema.name_to_hash(tag.name)
            if name_hash is not None:
                _prefix = tag.prefix
                if _prefix is not None:
                    ns_hash = self.prefix_to_nshash(_prefix)
                    if ns_hash is not None:
                        return HTag(ns_hash, name_hash)
                    else:
                        return HTag(0, name_hash)
        elif isinstance(tag, ITag):
            name_hash = self._schema.name_to_hash(tag.name)
            if name_hash is not None:
                _ns = tag.ns
                if _ns is not None:
                    ns_hash = self.ns_to_nshash(_ns)
                    if ns_hash is not None:
                        return HTag(ns_hash, name_hash)
                    else:
                        return HTag(0, name_hash)
        return None

class NamespaceMaps:
    @property
    ns_to_namespace: dict[str, NamespaceDescription]
    @property
    prefix_to_namespace: dict[str, NamespaceDescription]
    @property
    module_to_namespace: dict[str, NamespaceDescription]

    def __init__(self,
                    ns_to_namespace: dict[str, NamespaceDescription],
                    prefix_to_namespace: dict[str, NamespaceDescription],
                    module_to_namespace: dict[str, NamespaceDescription]):
        self.ns_to_namespace = ns_to_namespace
        self.prefix_to_namespace = prefix_to_namespace
        self.module_to_namespace = module_to_namespace

class NamespaceDescription:
    @property
    cns: str
    @property
    ns: str
    @property
    prefix: str
    @property
    ns_hash: int
    @property
    revision: str
    @property
    module: str

    def __init__(self,
            cns: str,
            ns: str,
            prefix: str,
            ns_hash: int,
            revision: str,
            module: str):
        self.cns = cns
        self.ns = ns
        self.prefix = prefix
        self.ns_hash = ns_hash
        self.revision = revision
        self.module = module

    def __str__(self):
        return "NamespaceDescription(" \
            + self.cns + self.ns + "," + self.prefix + "," + str(self.ns_hash) + "," \
            + self.revision + "," + self.module + ")"

    @staticmethod
    def from_ns_tuple(elems: list[EObject]) -> ?NamespaceDescription:
        if len(elems) >= 6:
            _cns = elems[1]
            _prefix = elems[2]
            _ns_hash = elems[3]
            _revision = elems[4]
            _module = elems[5]
            if isinstance(_cns, EAtom) \
                    and isinstance(_prefix, EAtom) \
                    and isinstance(_ns_hash, EInt) \
                    and isinstance(_revision, EBinary) \
                    and isinstance(_module, EBinary):

                ns = _cns.val.split("#", 1)[-1]

                return NamespaceDescription(
                    _cns.val,
                    ns,
                    _prefix.val,
                    _ns_hash.val,
                    str(_revision),
                    str(_module))
        return None

class RawNode:
    @property
    node_id: int
    @property
    tag_hash: int
    @property
    ns_hash: int
    @property
    key_node_id: int
    @property
    min_occurs: int
    @property
    max_occurs: int
    @property
    conf_type: int
    @property
    type_ns_hash: int
    @property
    type_name: str
    @property
    default_value: ?value
    @property
    info_flags: int
    @property
    child_node_id: int
    @property
    next_node_id: int
    @property
    choice_ordinal: int
    @property
    metadata: dict[str, str]
    @property
    mount_id_hashes: ?(int, int) # ?tuple[int, int]

    def __init__(self,
            node_id: int,
            tag_hash: int,
            ns_hash: int,
            key_node_id: int,
            min_occurs: int,
            max_occurs: int,
            conf_type: int,
            type_ns_hash: int,
            type_name: str,
            default_value: ?value,
            info_flags: int,
            child_node_id: int,
            next_node_id: int,
            choice_ordinal: int,
            metadata: dict[str, str],
            mount_id_hashes: ?(int, int)):
        self.node_id = node_id
        self.tag_hash = tag_hash
        self.ns_hash = ns_hash
        self.key_node_id = key_node_id
        self.min_occurs = min_occurs
        self.max_occurs = max_occurs
        self.conf_type = conf_type
        self.type_ns_hash = type_ns_hash
        self.type_name = type_name
        self.default_value = default_value
        self.info_flags = info_flags
        self.child_node_id = child_node_id
        self.next_node_id = next_node_id
        self.choice_ordinal = choice_ordinal
        self.metadata = metadata
        self.mount_id_hashes = mount_id_hashes

    @staticmethod
    def from_ns_tuple(elems: list[EObject]) -> ?RawNode:
        if len(elems) >= 18:
            _node_id = elems[1]
            _tag_hash = elems[2]
            _ns_hash = elems[3]
            _key_node_id = elems[4]
            _min_occurs = elems[5]
            _max_occurs = elems[6] # Seems bugged, e.g. reported as (1) for lists without max-elements.
            _conf_type = elems[7]
            _type_ns_hash = elems[8]
            _type_name = elems[9]
            _default_value = elems[10]
            _info_flags = elems[11]
            _child_node_id = elems[12]
            _next_node_id = elems[13]
            _choice_ordinal = elems[14]
            _metadata = elems[16]
            _mount_id = elems[17]

            if isinstance(_node_id, EInt) \
                    and isinstance(_tag_hash, EInt) \
                    and isinstance(_ns_hash, EInt) \
                    and isinstance(_key_node_id, EInt) \
                    and isinstance(_min_occurs, EInt) \
                    and isinstance(_max_occurs, EInt) \
                    and isinstance(_conf_type, EInt) \
                    and isinstance(_type_ns_hash, EInt) \
                    and isinstance(_type_name, EAtom) \
                    and isinstance(_info_flags, EInt) \
                    and isinstance(_child_node_id, EInt) \
                    and isinstance(_next_node_id, EInt) \
                    and isinstance(_choice_ordinal, EInt) \
                    and isinstance(_metadata, EList):

                metadata: dict[str, str] = {}
                for e in _metadata.elems:
                    if isinstance(e, ETuple):
                        if len(e.elems) == 2:
                            _key = e.elems[0]
                            _val = e.elems[1]
                            metadata[str(_key)] = str(_val)

                mount_id: ?(int, int) = None
                if isinstance(_mount_id, ETuple):
                    _elems = _mount_id.elems
                    if len(_elems) == 2:
                        _mount_id_ns_hash = _elems[0]
                        _mount_id_name_hash = _elems[1]
                        if isinstance(_mount_id_ns_hash, EInt) and isinstance(_mount_id_name_hash, EInt):
                            mount_id = (_mount_id_ns_hash.val, _mount_id_name_hash.val)

                return RawNode(
                    _node_id.val,
                    _tag_hash.val,
                    _ns_hash.val,
                    _key_node_id.val,
                    _min_occurs.val,
                    _max_occurs.val,
                    _conf_type.val,
                    _type_ns_hash.val,
                    _type_name.val,
                    _default_value,
                    _info_flags.val,
                    _child_node_id.val,
                    _next_node_id.val,
                    _choice_ordinal.val,
                    metadata,
                    mount_id)

        return None

class RawKeys:
    @property
    node_id: int
    @property
    key_hashes: list[int]

    def __init__(self, node_id: int, key_hashes: list[int]):
        self.node_id = node_id
        self.key_hashes = key_hashes

    @staticmethod
    def from_ns_tuple(elems: list[EObject]) -> ?RawKeys:
        if len(elems) >= 3:
            _node_id = elems[1]
            _key_hashes = elems[2]

            if isinstance(_node_id, EInt) and isinstance(_key_hashes, EList):
                keys: list[int] = []
                for e in _key_hashes.elems:
                    if isinstance(e, EInt):
                        keys.append(e.val)
                return RawKeys(_node_id.val, keys)

class TypeId:
    @property
    ns_hash: int
    @property
    name: str
    # @property
    # ns_descr: NamespaceDescription
    # @property
    # name: str

    def __init__(self, ns_hash: int, name: str):
        self.ns_hash = ns_hash
        self.name = name

    def __str__(self) -> str:
        return str(self.ns_hash) + ":" + self.name

extension TypeId(Hashable):
    def __eq__(self, other: TypeId) -> bool:
        return self.name == other.name and self.ns_hash == other.ns_hash

    def __hash__(self) -> int:
        return self.ns_hash + hash(self.name)

class Node:
    # @property:
    # node_type: int
    @property
    tag: HTag
    @property
    min_occurs: int
    @property
    max_occurs: int
    @property
    flags: i64
    @property
    conf_type: int
    @property
    value_type: ?Type
    @property
    keys: list[Node]
    @property
    children: dict[HTag, Node]

    def __init__(self, tag: HTag, min_occurs: int, max_occurs: int, flags: i64, conf_type: int, value_type: ?Type, keys: list[Node], children: dict[HTag, Node]):
        self.tag = tag
        self.min_occurs = min_occurs
        self.max_occurs = max_occurs
        self.flags = flags
        self.conf_type = conf_type
        self.value_type = value_type
        self.keys = keys
        self.children = children

        # self.node_type = 0
        # if self.is_np_container():
        #     self.node_type = NODE_NP_CONTAINER
        # if self.is_p_container():
        #     self.node_type = NODE_P_CONTAINER
        # if self.is_list():
        #     self.node_type = NODE_LIST
        # if self.is_empty_leaf():
        #     self.node_type = NODE_EMPTY_LEAF
        # if self.is_non_empty_leaf():
        #     self.node_type = NODE_NON_EMPTY_LEAF
        # if self.is_leaf_list():
        #     self.node_type = NODE_LEAF_LIST

    def is_container(self):
        return self.flags & CS_NODE_IS_CONTAINER != 0

    def is_np_container(self):
        return self.is_container() and self.min_occurs == 1

    def is_p_container(self):
        return self.is_container() and self.min_occurs == 0

    def is_leaf(self):
        # return self.value_type is not None
        return not self.children and self.flags & (
                CS_NODE_IS_CONTAINER |
                CS_NODE_IS_LIST |
                CS_NODE_IS_ACTION |
                CS_NODE_IS_NOTIF |
                CS_NODE_IS_LEAF_LIST) == 0

    def is_empty_leaf(self):
        return self.is_leaf() and self.conf_type == C_XMLTAG

    def is_non_empty_leaf(self):
        return self.is_leaf() and self.conf_type != C_XMLTAG

    def is_leaf_list(self):
        return self.flags & CS_NODE_IS_LEAF_LIST != 0

    def is_oper(self):
        return self.flags & CS_NODE_IS_WRITE == 0

    def is_mount_point(self):
        return self.flags & CS_NODE_HAS_MOUNT_POINT != 0

    # def get_namespace(self, schema: Schema) -> NamespaceDescription:
    #     ...

    # def get_name(self, schema: Schema) -> str:
    #     ...

class Type(object):
    @property
    type_id: TypeId
    @property
    parent_type: ?Type
    @property
    conf_type: ?int
    # @property
    # derivation: str

    def __init__(self, type_id: TypeId, parent_type: ?Type, conf_type: ?int):
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = conf_type

    # def __str__(self) -> str:
    #     return "type " + str(self.type_id)

    @staticmethod
    def builtin_types() -> dict[TypeId, Type]:
        types: dict[TypeId, Type] = {}
        def append(t: Type) -> None:
            types[t.type_id] = t

        append(Type(TypeId(0, "int8"), None, C_INT8))
        append(Type(TypeId(0, "int16"), None, C_INT16))
        append(Type(TypeId(0, "int32"), None, C_INT32))
        append(Type(TypeId(0, "int64"), None, C_INT64))
        append(Type(TypeId(0, "uint8"), None, C_INT8))
        append(Type(TypeId(0, "uint16"), None, C_UINT16))
        append(Type(TypeId(0, "uint32"), None, C_UINT32))
        append(Type(TypeId(0, "uint64"), None, C_UINT64))
        append(Type(TypeId(0, "string"), None, C_BUF))
        append(Type(TypeId(0, "boolean"), None, C_BOOL))
        append(Type(TypeId(0, "hex-list"), None, C_BINARY)) # Not enabled in ConfD/NCS
        append(Type(TypeId(0, "hexList"), None, C_BINARY)) # Not enabled in ConfD/NCS
        append(Type(TypeId(0, "octet-list"), None, C_BINARY)) # TODO: E.g. \d+\(.\d+)
        append(Type(TypeId(0, "octetList"), None, C_BINARY)) # TODO: E.g. \d+\(.\d+)
        append(Type(TypeId(0, "md5-digest-string"), None, C_BUF))
        append(Type(TypeId(0, "des3-cbc-encrypted-string"), None, C_BUF))
        append(Type(TypeId(0, "aes-cfb-128-encrypted-string"), None, C_BUF))
        append(Type(TypeId(0, "aes-256-cfb-128-encrypted-string"), None, C_BUF))
        append(Type(TypeId(0, "inetAddressIPv4"), None, C_IPV4))
        append(Type(TypeId(0, "inetAddressIPv6"), None, C_IPV6))
        append(Type(TypeId(0, "Counter32"), None, C_UINT32))
        append(Type(TypeId(0, "Counter64"), None, C_UINT64))
        append(Type(TypeId(0, "Guage32"), None, C_UINT32))
        append(Type(TypeId(0, "inetPortNumber"), None, C_UINT16))
        append(Type(TypeId(0, "inetAddressDNS"), None, C_BUF))
        append(Type(TypeId(0, "oid"), None, C_OID)) # TODO: First identified must be 0,1,2)
        append(UnionType(TypeId(0, "inetAddressIP"), None, [types[TypeId(0, "inetAddressIPv4")], types[TypeId(0, "inetAddressIPv6")]]))
        append(UnionType(TypeId(0, "inetAddress"), None, [types[TypeId(0, "inetAddressIP")], types[TypeId(0, "inetAddressDNS")]]))
        append(Type(TypeId(0, "ipv4Prefix"), None, C_IPV4PREFIX))
        append(Type(TypeId(0, "ipv6Prefix"), None, C_IPV6PREFIX))
        append(UnionType(TypeId(0, "ipPrefix"), None, [types[TypeId(0, "ipv4Prefix")], types[TypeId(0, "ipv6Prefix")]]))
        append(Type(TypeId(0, "size"), None, C_UINT64)) # TODO: with 2^10^x prefixes G,M,K,B
        append(Type(TypeId(0, "MD5DigestString"), None, C_BUF))
        append(Type(TypeId(0, "SHA256DigestString"), None, C_BUF))
        append(Type(TypeId(0, "SHA512DigestString"), None, C_BUF))
        append(Type(TypeId(0, "cryptHash"), None, C_BUF))
        append(Type(TypeId(0, "DES3CBCIVEncryptedString"), None, C_BUF))
        append(Type(TypeId(0, "AESCFB128IVEncryptedString"), None, C_BUF))
        append(Type(TypeId(0, "AES256CFB128IVEncryptedString"), None, C_BUF))
        append(Type(TypeId(0, "byte"), None, C_INT8))
        append(Type(TypeId(0, "short"), None, C_INT16))
        append(Type(TypeId(0, "int"), None, C_INT32))
        append(Type(TypeId(0, "long"), None, C_INT64))
        append(Type(TypeId(0, "unsignedByte"), None, C_INT8))
        append(Type(TypeId(0, "unsignedShort"), None, C_INT16))
        append(Type(TypeId(0, "unsignedInt"), None, C_INT32))
        append(Type(TypeId(0, "unsignedLong"), None, C_INT64))
        append(Type(TypeId(0, "double"), None, C_DOUBLE))
        append(Type(TypeId(0, "objectRef"), None, C_INSTANCE_IDENTIFIER))
        append(Type(TypeId(0, "identityref"), None, C_IDENTITYREF))
        append(Type(TypeId(0, "dateTime"), None, C_DATETIME))
        append(Type(TypeId(0, "date"), None, C_DATE))
        append(Type(TypeId(0, "time"), None, C_TIME))
        append(Type(TypeId(0, "duration"), None, C_DURATION))
        append(Type(TypeId(0, "decimal"), None, C_DOUBLE))
        append(Type(TypeId(0, "integer"), None, C_INT64))
        append(Type(TypeId(0, "float"), None, C_DOUBLE))
        append(Type(TypeId(0, "hexBinary"), None, C_BINARY))
        append(Type(TypeId(0, "binary"), None, C_BINARY)) # TODO: base64
        append(Type(TypeId(0, "base64Binary"), None, C_BINARY)) # TODO: base64
        append(RestrictedNumberType(TypeId(0, "nonNegativeInteger"), None, C_UINT64, [TypeRange(0, None, CONFD_RANGE_MIN_INCLUSIVE | CONFD_RANGE_MAX_INCLUSIVE)]))
        append(RestrictedNumberType(TypeId(0, "nonPositiveInteger"), None, C_INT64, [TypeRange(None, 0, CONFD_RANGE_MIN_INCLUSIVE | CONFD_RANGE_MAX_INCLUSIVE)]))
        append(RestrictedNumberType(TypeId(0, "negativeInteger"), None, C_INT64, [TypeRange(None, -1, CONFD_RANGE_MIN_INCLUSIVE | CONFD_RANGE_MAX_INCLUSIVE)]))
        append(RestrictedNumberType(TypeId(0, "positiveInteger"), None, C_UINT64, [TypeRange(1, None, CONFD_RANGE_MIN_INCLUSIVE | CONFD_RANGE_MAX_INCLUSIVE)]))
        append(Type(TypeId(0, "normalizedString"), None, C_BUF)) # TODO: Replace whitespace with space e.g. ' '
        append(Type(TypeId(0, "token"), None, C_BUF)) # TODO: Replace any consecutive whitespace with single space e.g. ' '
        append(Type(TypeId(0, "NOTATION"), None, C_BUF)) # TODO: Replace any consecutive whitespace with single space e.g. ' '
        append(Type(TypeId(0, "language"), None, C_BUF)) # TODO: [a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*
        append(Type(TypeId(0, "NMTOKEN"), None, C_BUF)) # TODO: [A-Za-z0-9._:-]+
        append(Type(TypeId(0, "Name"), None, C_BUF)) # TODO: [A-Za-z_:][A-Za-z0-9._:-]*
        append(Type(TypeId(0, "NCName"), None, C_BUF)) # TODO: [^:]*
        append(Type(TypeId(0, "ID"), None, C_BUF)) # TODO: [^:]*
        append(Type(TypeId(0, "IDREF"), None, C_BUF)) # TODO: [^:]*
        append(Type(TypeId(0, "ENTITY"), None, C_BUF)) # TODO: [^:]*
        append(ListType(TypeId(0, "NMTOKEN-LIST"), None, types[TypeId(0, "NMTOKEN")]))
        append(ListRestrictionType(TypeId(0, "NMTOKENS"), types[TypeId(0, "NMTOKEN")], [TypeRange(1, None, 0)]))
        append(ListType(TypeId(0, "IDREF-LIST"), None, types[TypeId(0, "NCName")]))
        append(ListRestrictionType(TypeId(0, "IDREFS"), types[TypeId(0, "NCName")], [TypeRange(1, None, 0)]))
        append(ListRestrictionType(TypeId(0, "ENTITIES"), types[TypeId(0, "NCName")], [TypeRange(1, None, 0)]))
        append(Type(TypeId(0, "dottedQuad"), None, C_DQUAD))
        append(Type(TypeId(0, "hexString"), None, C_HEXSTR))
        append(Type(TypeId(0, "ipv4AddressAndPrefixLength"), None, C_IPV4_AND_PLEN))
        append(Type(TypeId(0, "ipv6AddressAndPrefixLength"), None, C_IPV6_AND_PLEN))
        append(UnionType(TypeId(0, "ipAddressAndPrefixLength"), None, [types[TypeId(0, "ipv4AddressAndPrefixLength")], types[TypeId(0, "ipv6AddressAndPrefixLength")]]))

        return types

    @staticmethod
    def from_ns_tuple(elems: list[EObject], ns_descr: NamespaceDescription, types: dict[TypeId, Type]) -> ?Type:
        if len(elems) >= 6:
            _derivation = elems[1]
            _name = elems[2]
            _parent_ns_hash = elems[3]
            _parent_name = elems[4]
            _opaque = elems[5]
            if isinstance(_derivation, EAtom) \
                    and isinstance(_name, EAtom) \
                    and isinstance(_parent_ns_hash, EInt) \
                    and isinstance(_parent_name, EAtom) \
                    and isinstance(_opaque, EObject):

                derivation = str(_derivation)
                type_id = TypeId(ns_descr.ns_hash, str(_name))

                parent_type_id = TypeId(_parent_ns_hash.val, str(_parent_name))
                parent_type: ?Type = try_get(types, parent_type_id)

                if derivation == "none":
                    pass
                elif derivation == "enum":
                    return EnumType.from_ns_opaque(type_id, parent_type, _opaque)
                elif derivation == "idref":
                    return IdentityType.from_ns_opaque(type_id, parent_type, _opaque)
                elif derivation == "bits":
                    return BitsType.from_ns_opaque(type_id, parent_type, _opaque)
                elif derivation == "decimal64":
                    return Decimal64Type.from_ns_opaque(type_id, parent_type, _opaque)
                elif derivation == "union":
                    return UnionType.from_ns_opaque(type_id, parent_type, _opaque, types)
                elif derivation == "list":
                    return ListType.from_ns_opaque(type_id, parent_type, _opaque, types)
                elif derivation == "number":
                    return RestrictedNumberType.from_ns_opaque(type_id, parent_type, _opaque)
                elif derivation == "string":
                    return StringType.from_ns_opaque(type_id, parent_type, _opaque)
                elif derivation == "list_restr":
                    return ListRestrictionType.from_ns_opaque(type_id, parent_type, _opaque)
                elif derivation == "display_hint":
                    return DisplayHintType.from_ns_opaque(type_id, parent_type, _opaque)
                elif derivation == "identity":
                    pass
                return Type(type_id, parent_type, None)
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        retval = None
        parent = self.parent_type
        if parent is not None:
            retval = parent.netconf_to_value(s, cursor, prefix_to_ns)
        if retval is None:
            _conf_type = self.conf_type
            if _conf_type is not None:
                retval = Any.netconf_to_value(s, _conf_type, cursor, prefix_to_ns)
            if retval is None:
                shallow_type = cursor.node().conf_type
                # if shallow_type != _conf_type:
                # Workaround actonc error:
                # ld.lld: error: undefined symbol: $EqOptG_new
                if not eq_optional(shallow_type, _conf_type):
                    retval = Any.netconf_to_value(s, shallow_type, cursor, prefix_to_ns)
        return retval

    def value_to_netconf(self, v: ?value, cursor: Cursor) -> ?str:
        retval = None
        parent = self.parent_type
        if parent is not None:
            retval = parent.value_to_netconf(v, cursor)
        if retval is None:
            retval = Any.value_to_netconf(v, cursor)
        return retval

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        retval = None
        parent = self.parent_type
        if parent is not None:
            retval = parent.value_to_eobject(v, cursor, use_ikp)
        if retval is None:
            retval = Any.value_to_eobject(v, cursor, use_ikp)
        return retval

    def eobject_to_value(self, cursor: Cursor, obj: ?EObject) -> ?value:
        return None

    # def netconf_to_eobject(self, node: Node, s: str) -> ?EObject:
    #     return netvalue_to_eobject(netconf_to_value(node, s))

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        return False # TODO

class EnumType(Type):
    @property
    name_to_ordinal: dict[str, int]
    @property
    ordinal_to_name: dict[int, str]

    def __init__(self, type_id: TypeId, parent_type: ?Type, name_to_ordinal: dict[str, int]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = C_ENUM_VALUE
        self.name_to_ordinal = name_to_ordinal
        _ordinal_to_name = {}
        for name, ordinal in name_to_ordinal.items():
            _ordinal_to_name[ordinal] = name
        self.ordinal_to_name = _ordinal_to_name

    def __str__(self):
        return Type.__str__(self) + " enum " + str(self.name_to_ordinal)

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        if isinstance(opaque, EList):
            name_to_ordinal: dict[str, int] = {}
            for _elem in reversed(opaque.elems):
                if isinstance(_elem, ETuple):
                    _pair = _elem.elems
                    if len(_pair) == 2:
                        _ename = _pair[0]
                        _ordinal = _pair[1]
                        if isinstance(_ename, EBinary) and isinstance(_ordinal, EInt):
                            name_to_ordinal[str(_ename)] = _ordinal.val
            return EnumType(type_id, parent_type, name_to_ordinal)
        return None

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        if v is not None:
            if isinstance(v, str):
                ordinal = try_get(self.name_to_ordinal, v)
                if ordinal is not None:
                    return ETuple([EInt(C_ENUM_VALUE), EInt(ordinal)])
            elif isinstance(v, int):
                return ETuple([EInt(C_ENUM_VALUE), EInt(v)])
        return None

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        if v is not None:
            if isinstance(v, str):
                return v in self.name_to_ordinal
            elif isinstance(v, int):
                return v in self.ordinal_to_name
        return False

class UnionType(Type):
    @property
    types: list[Type]

    def __init__(self, type_id: TypeId, parent_type: ?Type, types: list[Type]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.types = types

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject, types: dict[TypeId, Type]) -> ?Type:
        if isinstance(opaque, EList):
            utypes = []
            for _elem in reversed(opaque.elems):
                if isinstance(_elem, ETuple):
                    _elems = _elem.elems
                    if len(_elems) == 3:
                        _ns_hash = _elems[0]
                        _name = _elems[1]
                        if isinstance(_ns_hash, EInt) and isinstance(_name, EAtom):
                            type_id = TypeId(_ns_hash.val, str(_name))
                            t = try_get(types, type_id)
                            if t is not None:
                                utypes.append(t)
                            else:
                                print("WARNING: Invalid schema union member type_id ref:", type_id)
            return UnionType(type_id, parent_type, utypes)
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        for t in self.types:
            res = t.netconf_to_value(s, cursor, prefix_to_ns)
            if res is not None:
                return res
        return None

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        for t in self.types:
            res = t.value_to_eobject(v, cursor, use_ikp)
            if res is not None:
                return res
        return None

class RestrictedNumberType(Type):
    @property
    ranges: list[TypeRange]

    def __init__(self, type_id: TypeId, parent_type: ?Type, conf_type: ?int, ranges: list[TypeRange]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = conf_type
        self.ranges = ranges

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        # TODO
        return RestrictedNumberType(type_id, parent_type, None, [])

class BitsType(Type):
    @property
    pos_to_name: dict[int, str]
    @property
    name_to_pos: dict[str, int]

    def __init__(self, type_id: TypeId, parent_type: ?Type, conf_type: ?int, pos_to_name: dict[int, str]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = conf_type
        self.pos_to_name = pos_to_name
        _name_to_pos: dict[str, int] = {}
        for pos, name in pos_to_name.items():
            _name_to_pos[name] = pos
        self.name_to_pos = _name_to_pos

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        if isinstance(opaque, ETuple) and len(opaque.elems) == 2:
            elems = opaque.elems
            _width = elems[0]
            _bits = elems[1]
            if isinstance(_width, EInt) and isinstance(_bits, EList):
                width = _width.val
                _conf_type = C_BITBIG
                if width <= 32:
                    _conf_type = C_BIT32
                elif width <= 64:
                    _conf_type = C_BIT64
                _pos_to_name: dict[int, str] = {}
                for _bit_elem in _bits.elems:
                    if isinstance(_bit_elem, ETuple) and len(_bit_elem.elems) == 2:
                        _elems = _bit_elem.elems
                        _bit_name = _elems[0]
                        _bit_pos = _elems[1]
                        if isinstance(_bit_name, EBinary) and isinstance(_bit_pos, EInt):
                            bit_name = str(_bit_name)
                            bit_pos = _bit_pos.val
                            _pos_to_name[bit_pos] = bit_name
                return BitsType(type_id, parent_type, _conf_type, _pos_to_name)
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        p = s.split(" ", -1)
        # mask: int = 0
        # BUG: Runtime error on bitwise operations
        # for bit_name in p:
        #     bit_pos = try_get(self.name_to_pos, bit_name)
        #     if bit_pos is not None:
        #         mask |= 1 << bit_pos # BUG: Runtime error on bitwise operations
        #     else:
        #         return False
        # for bit_name in set(p):
        #     bit_pos = try_get(self.name_to_pos, bit_name)
        #     if bit_pos is not None:
        #         mask += 2**bit_pos
        #     else:
        #         return False
        # return mask
        v: set[str] = set(p)
        return v

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        if v is not None:
            # if isinstance(v, set[str]):
            if isinstance(v, set):
                mask: int = 0
                # BUG: Runtime error on bitwise operations
                # for bit_name in v:
                #     bit_pos = try_get(self.name_to_pos, bit_name)
                #     if bit_pos is not None:
                #         mask |= 1 << bit_pos # BUG: Runtime error on bitwise operations
                #     else:
                #         return None
                for bit_name in v:
                    if isinstance(bit_name, str):
                        bit_pos = try_get(self.name_to_pos, bit_name)
                        if bit_pos is not None:
                            mask += 2**bit_pos
                        elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                            return None
                    elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                        return None
                _conf_type = self.conf_type
                if _conf_type is not None:
                    if _conf_type == C_BIT32 or _conf_type == C_BIT64:
                        return ETuple([EInt(_conf_type), EInt(mask)])
                    elif _conf_type == C_BITBIG:
                        return ETuple([EInt(_conf_type), EBinary(uint_to_bytes_le(mask))])
                    elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                        return None
                elif True: # else: # Workaround: https://github.com/actonlang/acton/issues/1161
                    return None
        return None

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        # if v is not None and isinstance(v, Iterable):
        #     for bit_name in v:
        #         if bit_name not in self.name_to_pos:
        #             return False
        #     return True
        if v is not None:
            if isinstance(v, set):
                for bit_name in v:
                    if bit_name not in self.name_to_pos:
                        return False
                return True
            elif isinstance(v, list):
                for bit_name in v:
                    if bit_name not in self.name_to_pos:
                        return False
                return True
        return False

class Decimal64Type(Type):
    @property
    fraction_digits: int
    @property
    ranges: list[TypeRange]

    def __init__(self, type_id: TypeId, parent_type: ?Type, fraction_digits: int, ranges: list[TypeRange]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = C_DECIMAL64
        self.fraction_digits = fraction_digits
        self.ranges = ranges

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        if isinstance(opaque, ETuple) and len(opaque.elems) == 2:
            elems = opaque.elems
            _fraction_digits = elems[0]
            _ranges = elems[1]
            if isinstance(_fraction_digits, EInt) and isinstance(_ranges, EList):
                return Decimal64Type(type_id, parent_type, _fraction_digits.val, []) # TODO: ranges
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        d = Decimal64.try_parse(s)
        return d.try_lossless_realignment(-self.fraction_digits) if d is not None else None

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        # TODO
        return False

class ListType(Type):
    @property
    elem_type: Type

    def __init__(self, type_id: TypeId, parent_type: ?Type, elem_type: Type):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = None
        self.elem_type = elem_type

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject, types: dict[TypeId, Type]) -> ?Type:
        if isinstance(opaque, ETuple) and len(opaque.elems) == 2:
            elems = opaque.elems
            _ns_hash = elems[0]
            _name = elems[1]
            if isinstance(_ns_hash, EInt) and isinstance(_name, EAtom):
                type_id = TypeId(_ns_hash.val, str(_name))
                t = try_get(types, type_id)
                if t is not None:
                    return ListType(type_id, parent_type, t)
                else:
                    print("WARNING: Invalid schema list elem type_id ref:", type_id)
        return None

    def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        # Not really viable to parse multiple elements of any type ('string'-type in particular)
        # hence here we only allow single value
        return self.elem_type.netconf_to_value(s, cursor, prefix_to_ns)

    def value_to_eobject(self, v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        # if v is not None and isinstance(v, Iterable):
        #     elems = []
        #     for o in v:
        #         eo = self.elem_type.value_to_eobject(o, cursor, use_ikp)
        #         if eo is not None:
        #             elems.append(eo)
        #         else:
        #             return None
        #     return EList(elems, True)
        if v is not None:
            if isinstance(v, set):
                elems: list[EObject] = []
                _elem_type: Type = self.elem_type
                for o in v:
                    eo: ?EObject = _elem_type.value_to_eobject(o, cursor, use_ikp)
                    if eo is not None:
                        elems.append(eo)
                    else:
                        return None
                return EList(elems, True)
            elif isinstance(v, list):
                elems: list[EObject] = []
                _elem_type: Type = self.elem_type
                for o in v:
                    eo: ?EObject = _elem_type.value_to_eobject(o, cursor, use_ikp)
                    if eo is not None:
                        elems.append(eo)
                    else:
                        return None
                return EList(elems, True)
        return None

class ListRestrictionType(Type):
    @property
    ranges: list[TypeRange]

    def __init__(self, type_id: TypeId, parent_type: ?Type, ranges: list[TypeRange]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = None
        self.ranges = ranges

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        # TODO
        return ListRestrictionType(type_id, parent_type, [])

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        # TODO
        return False

class DisplayHintType(Type):
    def __init__(self, type_id: TypeId, parent_type: ?Type):
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = None

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        # TODO
        return DisplayHintType(type_id, parent_type)

class StringType(Type):
    @property
    ranges: list[TypeRange]
    @property
    pattern: ?value # TODO: regex

    def __init__(self, type_id: TypeId, parent_type: ?Type, ranges: list[TypeRange], regex: ?value):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = None
        self.ranges = ranges
        self.pattern = None

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        # TODO
        return StringType(type_id, parent_type, [], None)

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        # TODO
        return False

class IdentityType(Type):
    @property
    identities: set[HTag]

    def __init__(self, type_id: TypeId, parent_type: ?Type, identities: set[HTag]):
        #super(self, type_id, parent_type, conf_type)
        self.type_id = type_id
        self.parent_type = parent_type
        self.conf_type = C_IDENTITYREF
        self.identities = identities

    @staticmethod
    def from_ns_opaque(type_id: TypeId, parent_type: ?Type, opaque: EObject) -> ?Type:
        if isinstance(opaque, EList):
            identities: set[HTag] = set([])
            for _elem in reversed(opaque.elems):
                if isinstance(_elem, ETuple):
                    _elems = _elem.elems
                    if len(_elems) == 3:
                        _qname = _elems[0]
                        _ns_hash = _elems[1]
                        _name_hash = _elems[2]
                        if isinstance(_qname, EAtom) and isinstance(_ns_hash, EInt) and isinstance(_name_hash, EInt):
                            # Won't really need _qname for now
                            identities.add(HTag(_ns_hash.val, _name_hash.val))
            return IdentityType(type_id, parent_type, identities)
        return None

    # def netconf_to_value(self, s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
    #     v = Type.netconf_to_value(self, s, cursor, prefix_to_ns)
    #     if self.validate_value(cursor, v):
    #         return v
    #     return None

    def validate_value(self, cursor: Cursor, v: ?value) -> bool:
        if v is not None and isinstance(v, Tag):
            htag = cursor.lookup_htag(v)
            if htag is not None:
                return htag in self.identities
        return False

class TypeRange:
    def __init__(self, lo: ?value, hi: ?value, flags: i64):
        self.lo = lo
        self.hi = hi
        self.flags = flags

actor SchemaBuilder():
    var raw_roots: set[int] = set([])
    var raw_nodes: dict[int, RawNode] = {}
    var raw_keys: dict[int, RawKeys] = {}
    var curr_ns: NamespaceDescription = NamespaceDescription("", "", "", 0, "", "")
    var curr_mount_id: HTag = ROOT_MOUNT_ID

    var hash_to_name: dict[int, str] = {}
    var name_to_hash: dict[str, int] = {}
    var namespaces: dict[int, NamespaceDescription] = {}
    var mount_id_namespaces: dict[HTag, list[NamespaceDescription]] = {}
    var roots: dict[HTag, Node] = {}
    var types: dict[TypeId, Type] = Type.builtin_types()

    def on_ns_term(term: EObject) -> value:
        return _for_schema_lists(term, _on_ns_elem)

    def on_hash_term(term: EObject) -> value:
        return _for_schema_lists(term, _on_hash_elem)

    def on_mns_term(term: EObject) -> value:
        return _for_schema_lists(term, _on_mns_elem)

    def _for_schema_lists(term: EObject, on_elem: proc(EObject) -> None) -> value:
        if isinstance(term, EList):
            for e in term.elems:
                #print(e)
                if isinstance(e, EAtom) and str(e) == 'eof':
                    return False
                on_elem(e)
            return True
        else:
            return MaapiProtoError("Unexpected schema term")
        return True

    def _on_ns_elem(elem: EObject):
        if isinstance(elem, ETuple):
            t = elem.elems
            if len(t) >= 1:
                _etype = t[0]
                if isinstance(_etype, EAtom):
                    etype = _etype.val
                    if etype == 'ns':
                        ns_descr = NamespaceDescription.from_ns_tuple(t)
                        if ns_descr is not None:
                            namespaces[ns_descr.ns_hash] = ns_descr
                            curr_ns = ns_descr
                            return
                    elif etype == 'type':
                        #print(elem)
                        type_descr = Type.from_ns_tuple(t, curr_ns, types)
                        if type_descr is not None:
                            types[type_descr.type_id] = type_descr
                            return
                    elif etype == 'keys':
                        keys = RawKeys.from_ns_tuple(t)
                        if keys is not None:
                            raw_keys[keys.node_id] = keys
                            return
                    elif etype == 'node':
                        node = RawNode.from_ns_tuple(t)
                        if node is not None:
                            raw_nodes[node.node_id] = node
                            return
                    elif etype == 'root' and len(t) == 2:
                        _node_id = t[1]
                        if isinstance(_node_id, EInt):
                            node_id = _node_id.val
                            raw_roots.add(node_id)
                            return
                    elif etype == 'parent':
                        _assemble_node_trees()
                        return
        #print("WARNING: Unexpected schema ns elem:", elem)

    def _on_hash_elem(elem: EObject):
        #print(elem)
        if isinstance(elem, ETuple):
            t = elem.elems
            if len(t) == 2:
                name = t[0]
                hash_nr = t[1]
                if isinstance(hash_nr, EInt):
                    if isinstance(name, EAtom):
                        hash_to_name[hash_nr.val] = name.val
                        name_to_hash[name.val] = hash_nr.val
                        return
        #print("WARNING: Unexpected schema hash_db elem:", elem)

    def _on_mns_elem(elem: EObject):
        if isinstance(elem, ETuple):
            t = elem.elems
            if len(t) >= 1:
                _etype = t[0]
                if isinstance(_etype, EAtom):
                    etype = _etype.val
                    if etype == 'mount_id' and len(t) == 2:
                        _mount_id = t[1]
                        if isinstance(_mount_id, ETuple):
                            _elems = _mount_id.elems
                            if len(_elems) == 2:
                                _ns_hash = _elems[0]
                                _name_hash = _elems[1]
                                if isinstance(_ns_hash, EInt) and isinstance(_name_hash, EInt):
                                    # ns = hash_to_name.get(_ns_hash.val, "")
                                    # name = hash_to_name.get(_name_hash.val, "")
                                    # if ns and name:
                                    #     print("-- mount_id", ns + ":" + name)
                                    curr_mount_id = HTag(_ns_hash.val, _name_hash.val)
                                    return
                        elif isinstance(_mount_id, EList) and len(_mount_id.elems) == 0:
                            curr_mount_id = ROOT_MOUNT_ID
                            return
                elif isinstance(_etype, ETuple) and len(_etype.elems) == 2 and len(t) >= 2:
                    a_elems = _etype.elems
                    _netype = a_elems[0]
                    _cns = a_elems[1]
                    _b_elems = t[1]
                    if isinstance(_netype, EAtom) and _netype.val == 'ns' and isinstance(_cns, EAtom) \
                        and isinstance(_b_elems, ETuple) and len(_b_elems.elems) >= 4:
                        b_elems = _b_elems.elems
                        _prefix = b_elems[0]
                        _ns = b_elems[1]
                        _module = b_elems[2]
                        _nshash = b_elems[3]
                        if isinstance(_prefix, EAtom) \
                            and isinstance(_ns, EAtom) \
                            and isinstance(_module, EAtom) \
                            and isinstance(_nshash, EInt):
                            ns_hash = _nshash.val
                            ns_descr = try_get(namespaces, ns_hash)
                            if ns_descr is not None:
                                nslist = try_get(mount_id_namespaces, curr_mount_id)
                                if nslist is not None:
                                    nslist.append(ns_descr)
                                else:
                                    mount_id_namespaces[curr_mount_id] = list([ns_descr])
                            else:
                                print("WARNING: mount_id", curr_mount_id, "references unknown namespace:", ns_hash)
                            return
        #print("WARNING: Unexpected schema hash_db elem:", elem)

    def _assemble_node_trees():
        for root_node_id in raw_roots:
            _roots = _build_node_tree(root_node_id)
            for tag, root in _roots.items():
                roots[tag] = root

        raw_roots = set([]) # raw_roots.clear()
        raw_nodes = {} # raw_nodes.clear()
        raw_keys = {} # raw_keys.clear()

    def _build_node_tree(node_id: int) -> dict[HTag, Node]:
        result = {}

        while node_id != 0:
            raw_node = try_get(raw_nodes, node_id)
            if raw_node is not None:
                children = _build_node_tree(raw_node.child_node_id)
                keys = []
                if raw_node.key_node_id != 0:
                    raw_key = try_get(raw_keys, raw_node.key_node_id)
                    if raw_key is not None:
                        for key_hash in raw_key.key_hashes:
                            key_tag = _make_tag(raw_node.ns_hash, key_hash)
                            key_node = try_get(children, key_tag)
                            if key_node is not None:
                                keys.append(key_node)
                            else:
                                print("WARNING: Invalid key hash:", key_hash, "for schema node_id:", node_id)
                    else:
                        print("WARNING: Invalid key node id for schema node_id:", node_id)
                tag = _make_tag(raw_node.ns_hash, raw_node.tag_hash)
                type_descr: ?Type = None
                type_id = TypeId(raw_node.type_ns_hash, raw_node.type_name)
                if type_id:
                    type_descr = try_get(types, type_id)
                node = Node(
                    tag,
                    raw_node.min_occurs,
                    raw_node.max_occurs,
                    i64(raw_node.info_flags),
                    raw_node.conf_type,
                    type_descr,
                    keys,
                    children)
                result[tag] = node

                node_id = raw_node.next_node_id
            else:
                print("WARNING: Invalid schema node_id ref:", node_id)

        return result

    def _make_tag(ns_hash: int, name_hash: int) -> HTag:
        tag = HTag(ns_hash, name_hash)
        return tag
        # TODO: Store tag for reuse

    def build() -> Schema:
        #_pretty_print_nodes(roots, "")
        #_pretty_print_types(types, "")

        _roots: HTagDict[Node] = HTagDict()
        _cns_to_namespace: dict[str, NamespaceDescription] = {}
        _mount_id_maps: dict[HTag, NamespaceMaps] = {}

        for htag, node in roots.items():
            _roots[htag] = node

        for ns_descr in namespaces.values():
            _cns_to_namespace[ns_descr.cns] = ns_descr

        for mount_id, ns_items in mount_id_namespaces.items():
            _ns_to_namespace: dict[str, NamespaceDescription] = {}
            _prefix_to_namespace: dict[str, NamespaceDescription] = {}
            _module_to_namespace: dict[str, NamespaceDescription] = {}
            for ns_descr in ns_items:
                _ns_to_namespace[ns_descr.ns] = ns_descr
                _prefix_to_namespace[ns_descr.prefix] = ns_descr
                _module_to_namespace[ns_descr.module] = ns_descr
            _mount_id_maps[mount_id] = NamespaceMaps(_ns_to_namespace, _prefix_to_namespace, _module_to_namespace)

        return Schema(_roots, namespaces, _cns_to_namespace, hash_to_name, name_to_hash, _mount_id_maps)

    def _pretty_print_nodes(nodes: dict[HTag, Node], indent: str):
        for node in nodes.values():
            keys = ""
            if node.keys:
                key_names = []
                for key in node.keys:
                    key_names.append(hash_to_name[key.tag.name_hash])
                keys = "[" + ", ".join(key_names) + "]"
            flags = ""
            if node.flags:
                flag_names = []

                if node.flags & CS_NODE_IS_CASE != 0:
                    flag_names.append("case")
                if node.flags & CS_NODE_IS_LIST != 0:
                    flag_names.append("list")
                    flag_names.append(str(node.min_occurs) + ".." + str(node.max_occurs))
                if node.flags & CS_NODE_IS_CONTAINER != 0:
                    if node.min_occurs == 0:
                        flag_names.append("presence")
                    flag_names.append("container")
                if node.flags & CS_NODE_IS_WRITE == 0:
                    flag_names.append("oper")
                #if node.flags & CS_NODE_IS_CDB != 0:
                #if node.flags & CS_NODE_IS_ACTION != 0:
                #if node.flags & CS_NODE_IS_PARAM != 0:
                #if node.flags & CS_NODE_IS_RESULT != 0:
                #if node.flags & CS_NODE_IS_NOTIF != 0:
                #if node.flags & CS_NODE_HAS_WHEN != 0:
                #if node.flags & CS_NODE_HAS_DISPLAY_WHEN != 0:
                #if node.flags & CS_NODE_META_DATA != 0:
                #if node.flags & CS_NODE_IS_WRITE_ALL != 0:
                if node.flags & CS_NODE_IS_LEAF_LIST != 0:
                    flag_names.append("leaf-list")
                if node.flags & CS_NODE_IS_LEAFREF != 0:
                    flag_names.append("leafref")
                if node.is_mount_point():
                    flag_names.append("mount-point")
                #if node.flags & CS_NODE_IS_STRING_AS_BINARY != 0:

                if flag_names:
                    flags = " (" + ", ".join(flag_names) + ")"
            type_str = ""
            type_descr = node.value_type
            if type_descr is not None:
                type_str = " : " + str(type_descr)
            print(indent + hash_to_name[node.tag.name_hash] + keys + flags + type_str)
            _pretty_print_nodes(node.children, indent + "  ")

    def _pretty_print_types(types: dict[TypeId, Type], indent: str):
        for t in types.values():
            _pretty_print_type(t, indent)

    def _pretty_print_type(t: Type, indent: str):
        print(indent + str(t))
        parent_type = t.parent_type
        if parent_type is not None:
            _pretty_print_type(parent_type, indent + "  ")

#
# Type conversions
#

class Integer:
    @staticmethod
    def netconf_to_value(s: str) -> ?int:
        return try_parse_int(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if isinstance(v, int):
            return str(v)
        return None

    @staticmethod
    def value_to_eobject(v: ?value, conf_type: int) -> ?EObject:
        if isinstance(v, int):
            if conf_type == C_INT8:
                return ETuple([EInt(C_INT8), EInt(v)])
            elif conf_type == C_INT16:
                return ETuple([EInt(C_INT16), EInt(v)])
            if conf_type == C_INT32:
                return EInt(v)
            elif conf_type == C_INT64:
                return ETuple([EInt(C_INT64), EInt(v)])
            elif conf_type == C_UINT8:
                return ETuple([EInt(C_UINT8), EInt(v)])
            elif conf_type == C_UINT16:
                return ETuple([EInt(C_UINT16), EInt(v)])
            elif conf_type == C_UINT32:
                return ETuple([EInt(C_UINT32), EInt(v)])
            elif conf_type == C_UINT64:
                return ETuple([EInt(C_UINT64), EInt(v)])
            elif conf_type == C_BIT32:
                return ETuple([EInt(C_BIT32), EInt(v)])
            elif conf_type == C_BIT64:
                return ETuple([EInt(C_BIT64), EInt(v)])
        return None

class Bit:
    @staticmethod
    def netconf_to_value(s: str) -> ?int:
        return try_parse_int(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if isinstance(v, int):
            return str(v)
        return None

    @staticmethod
    def value_to_eobject(v: ?value, conf_type: int) -> ?EObject:
        if isinstance(v, int):
            if conf_type == C_BIT32:
                return ETuple([EInt(C_BIT32), EInt(v)])
            elif conf_type == C_BIT64:
                return ETuple([EInt(C_BIT64), EInt(v)])
            elif conf_type == C_BITBIG:
                raise Exception("Not Implemented")
        return None

class Float_:
    @staticmethod
    def netconf_to_value(s: str) -> ?float:
        return try_parse_float(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if isinstance(v, float):
            return str(v)
        return None

    @staticmethod
    def value_to_eobject(v: ?value, conf_type: int) -> ?EObject:
        if isinstance(v, float):
            # if conf_type == C_FLOAT:
            #     raise Exception("Not Implemented")
            if conf_type == C_DOUBLE:
                raise Exception("Not Implemented")

class Boolean:
    @staticmethod
    def netconf_to_value(s: str) -> ?bool:
        if s == 'true':
            return True
        elif s == 'false':
            return False
        else:
            return None

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if isinstance(v, bool):
            return 'true' if v else 'false'
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, bool):
            return EAtom.from_bool(v)
        return None

class IPv4:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv4Address:
        return IPv4Address.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv4Address):
            return ETuple([EInt(v.data.0), EInt(v.data.1), EInt(v.data.2), EInt(v.data.3)])
        return None

class IPv6:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv6Address:
        return IPv6Address.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv6Address):
            return ETuple([
                EInt(v.data.0), EInt(v.data.1), EInt(v.data.2), EInt(v.data.3),
                EInt(v.data.4), EInt(v.data.5), EInt(v.data.6), EInt(v.data.7)])
        return None

class IPv4Prefix:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv4Network:
        return IPv4Network.try_parse(s) # TODO: Verify that host bits are all zero

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv4Network):
            return ETuple([EInt(C_IPV4PREFIX),
                ETuple([EInt(v.address.data.0), EInt(v.address.data.1), EInt(v.address.data.2), EInt(v.address.data.3)]),
                EInt(v.mask_len)])
        return None

class IPv6Prefix:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv6Network:
        return IPv6Network.try_parse(s) # TODO: Verify that host bits are all zero

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv6Network):
            return ETuple([EInt(C_IPV6PREFIX),
                ETuple([EInt(v.address.data.0), EInt(v.address.data.1), EInt(v.address.data.2), EInt(v.address.data.3)]),
                ETuple([EInt(v.address.data.4), EInt(v.address.data.5), EInt(v.address.data.6), EInt(v.address.data.7)]),
                EInt(v.mask_len)])
        return None

class IPv4AndPrefixLen:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv4Network:
        return IPv4Network.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv4Network):
            return ETuple([EInt(C_IPV4PREFIX),
                ETuple([EInt(v.address.data.0), EInt(v.address.data.1), EInt(v.address.data.2), EInt(v.address.data.3)]),
                EInt(v.mask_len)])
        return None

class IPv6AndPrefixLen:
    @staticmethod
    def netconf_to_value(s: str) -> ?IPv6Network:
        return IPv6Network.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if isinstance(v, IPv6Network):
            return ETuple([EInt(C_IPV6PREFIX),
                ETuple([EInt(v.address.data.0), EInt(v.address.data.1), EInt(v.address.data.2), EInt(v.address.data.3)]),
                ETuple([EInt(v.address.data.4), EInt(v.address.data.5), EInt(v.address.data.6), EInt(v.address.data.7)]),
                EInt(v.mask_len)])
        return None

class DateTime_:
    @staticmethod
    def netconf_to_value(s: str) -> ?DateTime:
        return DateTime.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, DateTime):
            d: DateTime = v
            tz_h: ?int = d.timezone_hour
            tz_m: ?int = d.timezone_minute

            return ETuple([
                EInt(C_DATETIME),
                ETuple([
                    EInt(d.year),
                    EInt(d.month),
                    EInt(d.day),
                    EInt(d.hour),
                    EInt(d.minute),
                    EInt(d.second),
                    EInt(d.microsecond),
                    EInt(tz_h) if tz_h is not None else EList([], True),
                    EInt(tz_m) if tz_m is not None else EInt(0)
                    ])
                ])
        return None

class Date_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Date:
        return Date.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, Date):
            d: Date = v
            tz_h: ?int = d.timezone_hour
            tz_m: ?int = d.timezone_minute

            return ETuple([
                EInt(C_DATE),
                ETuple([
                    EInt(d.year),
                    EInt(d.month),
                    EInt(d.day),
                    EInt(tz_h) if tz_h is not None else EList([], True),
                    EInt(tz_m) if tz_m is not None else EInt(0)
                    ])
                ])
        return None

class Time_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Time:
        return Time.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, Time):
            d: Time = v
            tz_h: ?int = d.timezone_hour
            tz_m: ?int = d.timezone_minute

            return ETuple([
                EInt(C_TIME),
                ETuple([
                    EInt(d.hour),
                    EInt(d.minute),
                    EInt(d.second),
                    EInt(d.microsecond),
                    EInt(tz_h) if tz_h is not None else EList([], True),
                    EInt(tz_m) if tz_m is not None else EInt(0)
                    ])
                ])
        return None

class Duration_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Duration:
        return Duration.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, Duration):
            d: Duration = v

            return ETuple([
                EInt(C_DURATION),
                ETuple([
                    EInt(d.year),
                    EInt(d.month),
                    EInt(d.day),
                    EInt(d.hour),
                    EInt(d.minute),
                    EInt(d.second),
                    EInt(d.microsecond),
                    ])
                ])
        return None

class Enumeration:
    @staticmethod
    def netconf_to_value(s: str) -> str:
        return s

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if v is not None and isinstance(v, str):
            return v
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        # This should have been handled in schema type-converter
        return None

class QName:
    @staticmethod
    def netconf_to_value(s: str, prefix_to_ns: ?(?str) -> ?str) -> ?Tag:
        return ConfTaggedTag.netconf_to_value(s, prefix_to_ns)

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        return ConfTaggedTag.value_to_netconf(v, cursor)

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor) -> ?EObject:
        if v is not None and isinstance(v, Tag):
            ptag = cursor.lookup_ptag(v)
            if ptag is not None:
                _p = ptag.prefix
                _prefix = _p if _p is not None else 'undefined'
                return ETuple([EInt(C_QNAME), ETuple([EAtom(_prefix), EAtom(ptag.name)])])
        return None

class ConfTaggedTag:
    @staticmethod
    def netconf_to_value(s: str, prefix_to_ns: ?(?str) -> ?str) -> ?Tag:
        return BasicTag.netconf_to_value(s, prefix_to_ns)

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        return BasicTag.value_to_netconf(v, cursor)

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor, use_ikp: bool, conf_type: int) -> ?EObject:
        inner = BasicTag.value_to_eobject(v, cursor, use_ikp)
        if inner is not None:
            return ETuple([EInt(conf_type), inner])
        return None

class BasicTag:
    @staticmethod
    def netconf_to_value(s: str, prefix_to_ns: ?(?str) -> ?str) -> ?Tag:
        prefix: ?str = None
        p = s.split(":", 1)
        name = p[-1]
        if len(p) == 2:
            prefix = p[0]
        if prefix_to_ns is not None:
            _prefix_to_ns: (?str) -> ?str = prefix_to_ns
            ns = _prefix_to_ns(prefix)
            if ns is not None:
                return ITag(ns, name)
            else:
                return PTag(prefix, name)
        else:
            return PTag(prefix, name)
        return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        if v is not None and isinstance(v, Tag):
            ptag = cursor.lookup_ptag(v)
            if ptag is not None:
                _prefix = ptag.prefix
                return _prefix + ":" + ptag.name if _prefix is not None else ptag.name
        return None

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        if v is not None and isinstance(v, Tag):
            if use_ikp:
                itag = cursor.lookup_itag(v)
                if itag is not None:
                    _ns = itag.ns
                    if _ns is not None:
                        return ETuple([EAtom(_ns), EAtom(itag.name)])
                    else:
                        return EAtom(itag.name)
            else:
                htag = cursor.lookup_htag(v)
                if htag is not None:
                    if htag.ns_hash == 0:
                        return EInt(htag.name_hash)
                    else:
                        return ETuple([EInt(htag.ns_hash), EInt(htag.name_hash)])
        return None

class InstanceIdentifier:
    @staticmethod
    def netconf_to_value(s: str, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?Keypath:
        # TODO: parse xpath -> keypath
        return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor) -> ?EObject:
        # TODO: Implement
        return None

class Oid:
    @staticmethod
    def netconf_to_value(s: str) -> ?list[int]:
        retval = []
        for p in s.split(".", -1):
            n = Integer.netconf_to_value(p)
            if n is not None:
                retval.append(n)
            else:
                return None
        return retval if len(retval) > 0 else None

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if v is not None and isinstance(v, list): # if v is not None and isinstance(v, list[int]):
            # return ".".join(str(x) for x in v)
            sl = []
            for x in v:
                sl.append(str(x))
            return ".".join(sl)
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, list): # if v is not None and isinstance(v, list[int]):
            w = BufferWriter()
            for x in v:
                w.write_u32_be(x)
            return ETuple([EInt(C_OID), EBinary(w.to_bytes())])
        return None

class Binary:
    @staticmethod
    def confstr_to_value(s: str) -> ?bytes:
        if s.startswith("<<", None, None) and s.endswith(">>", None, None):
            # return s.encode() # actonc: #### findAttr' fails for __builtin__.value . decode
            _s: str = s[2:-2]
            return _s.encode()
        return s.encode()

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if v is not None and isinstance(v, bytes):
            _v: bytes = v
            return _v.decode()
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, bytes):
            return ETuple([EInt(C_BINARY), EBinary(v)])
        return None

class Decimal64_:
    @staticmethod
    def netconf_to_value(s: str) -> ?Decimal64:
        # Normally we won't get here as the type class converter has done the conversion
        # in order to align the fraction_digits / exponent
        return Decimal64.try_parse(s)

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if v is not None and isinstance(v, Decimal64):
            return str(v)
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, Decimal64):
            d: Decimal64 = v
            return ETuple([EInt(C_DECIMAL64), ETuple([EInt(d.significand), EInt(-d.exponent)])])
        return None

class DottedQuad:
    @staticmethod
    def confstr_to_value(s: str) -> ?int:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_netconf(v: ?value,) -> ?str:
        # TODO: Implement
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        # TODO: Implement
        return None

class HexString:
    @staticmethod
    def netconf_to_value(s: str) -> ?bytes:
        s = s.strip("<>\"")
        p = s.split(":", -1)
        vl = []
        if len(p) > 0:
            for h in p:
                v = try_parse_hex(h)
                if v is not None and v <= 0xFF:
                    vl.append(v)
                else:
                    return None
            return bytes(vl)
        return None

    @staticmethod
    def value_to_netconf(v: ?value) -> ?str:
        if v is not None and isinstance(v, bytes):
            sl = []
            for b in v:
                sl.append(to_byte_hexpair_str(b))
            return ":".join(sl)
        return None

    @staticmethod
    def value_to_eobject(v: ?value) -> ?EObject:
        if v is not None and isinstance(v, bytes):
            return ETuple([EInt(C_HEXSTR), EBinary(v)])
        return None

class Any:
    @staticmethod
    def netconf_to_value(s: str, conf_type: int, cursor: Cursor, prefix_to_ns: ?(?str) -> ?str) -> ?value:
        if conf_type == C_NOEXISTS:
            return V_NOEXISTS
        elif conf_type == C_XMLTAG:
            return None # Deprecated / Not in use?
        elif conf_type == C_SYMBOL:
            return None # Not in use?
        elif conf_type == C_STR:
            return s
        elif conf_type == C_BUF:
            return s
        elif conf_type == C_INT8:
            return Integer.netconf_to_value(s)
        elif conf_type == C_INT16:
            return Integer.netconf_to_value(s)
        elif conf_type == C_INT32:
            return Integer.netconf_to_value(s)
        elif conf_type == C_INT64:
            return Integer.netconf_to_value(s)
        elif conf_type == C_UINT8:
            return Integer.netconf_to_value(s)
        elif conf_type == C_UINT16:
            return Integer.netconf_to_value(s)
        elif conf_type == C_UINT32:
            return Integer.netconf_to_value(s)
        elif conf_type == C_UINT64:
            return Integer.netconf_to_value(s)
        elif conf_type == C_DOUBLE:
            return Float_.netconf_to_value(s)
        elif conf_type == C_IPV4:
            return IPv4.netconf_to_value(s)
        elif conf_type == C_IPV6:
            return IPv6.netconf_to_value(s)
        elif conf_type == C_BOOL:
            return Boolean.netconf_to_value(s)
        elif conf_type == C_QNAME:
            return QName.netconf_to_value(s, prefix_to_ns) # ITag('undefined', s) # ??? As java-api ...
        elif conf_type == C_DATETIME:
            return DateTime_.netconf_to_value(s)
        elif conf_type == C_DATE:
            return Date_.netconf_to_value(s)
        elif conf_type == C_TIME:
            return Time_.netconf_to_value(s)
        elif conf_type == C_DURATION:
            return Duration_.netconf_to_value(s)
        elif conf_type == C_ENUM_VALUE:
            return Enumeration.netconf_to_value(s)
        elif conf_type == C_BIT32:
            return Bit.netconf_to_value(s)
        elif conf_type == C_BIT64:
            return Bit.netconf_to_value(s)
        elif conf_type == C_BITBIG:
            return Bit.netconf_to_value(s)
        elif conf_type == C_LIST:
            return None # Leaf-list values must be converted per value
        elif conf_type == C_IDENTITYREF:
            return ConfTaggedTag.netconf_to_value(s, prefix_to_ns)
        elif conf_type == C_INSTANCE_IDENTIFIER:
            return InstanceIdentifier.netconf_to_value(s, cursor, prefix_to_ns)
        elif conf_type == C_OID:
            return Oid.netconf_to_value(s)
        elif conf_type == C_BINARY:
            return Binary.confstr_to_value(s)
        elif conf_type == C_IPV4PREFIX:
            return IPv4Prefix.netconf_to_value(s)
        elif conf_type == C_IPV6PREFIX:
            return IPv6Prefix.netconf_to_value(s)
        elif conf_type == C_DEFAULT:
            return V_DEFAULT
        elif conf_type == C_DECIMAL64:
            return Decimal64_.netconf_to_value(s)
        elif conf_type == C_DQUAD:
            return DottedQuad.confstr_to_value(s)
        elif conf_type == C_HEXSTR:
            return HexString.netconf_to_value(s)
        elif conf_type == C_IPV4_AND_PLEN:
            return IPv4AndPrefixLen.netconf_to_value(s)
        elif conf_type == C_IPV6_AND_PLEN:
            return IPv6AndPrefixLen.netconf_to_value(s)
        return None

    @staticmethod
    def value_to_netconf(v: ?value, cursor: Cursor) -> ?str:
        # TODO
        return None

    @staticmethod
    def value_to_eobject(v: ?value, cursor: Cursor, use_ikp: bool) -> ?EObject:
        conf_type = cursor.node().conf_type
        if conf_type == C_NOEXISTS:
            return EAtom('not_found')
        elif conf_type == C_XMLTAG:
            return None # Deprecated?
        elif conf_type == C_SYMBOL:
            return None # Deprecated?
        elif conf_type == C_STR:
            return EBinary.from_str(v + "\0") if v is not None and isinstance(v, str) else None
        elif conf_type == C_BUF:
            return EBinary.from_str(v) if v is not None and isinstance(v, str) else None
        elif conf_type == C_INT8:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_INT16:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_INT32:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_INT64:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_UINT8:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_UINT16:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_UINT32:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_UINT64:
            return Integer.value_to_eobject(v, conf_type)
        elif conf_type == C_DOUBLE:
            return Float_.value_to_eobject(v, conf_type)
        elif conf_type == C_IPV4:
            return IPv4.value_to_eobject(v)
        elif conf_type == C_IPV6:
            return IPv6.value_to_eobject(v)
        elif conf_type == C_BOOL:
            return Boolean.value_to_eobject(v)
        elif conf_type == C_QNAME:
            return QName.value_to_eobject(v, cursor) # ??? As java-api ...
        elif conf_type == C_DATETIME:
            return DateTime_.value_to_eobject(v)
        elif conf_type == C_DATE:
            return Date_.value_to_eobject(v)
        elif conf_type == C_TIME:
            return Time_.value_to_eobject(v)
        elif conf_type == C_DURATION:
            return Duration_.value_to_eobject(v)
        elif conf_type == C_ENUM_VALUE:
            return Enumeration.value_to_eobject(v)
        elif conf_type == C_BIT32:
            return Bit.value_to_eobject(v, C_BIT32)
        elif conf_type == C_BIT64:
            return Bit.value_to_eobject(v, C_BIT64)
        elif conf_type == C_BITBIG:
            return Bit.value_to_eobject(v, C_BITBIG)
        elif conf_type == C_LIST:
            return None # Leaf-list values must be converted per value
        elif conf_type == C_IDENTITYREF:
            return ConfTaggedTag.value_to_eobject(v, cursor, False, C_IDENTITYREF) # Always use hkp format?
        elif conf_type == C_INSTANCE_IDENTIFIER:
            return InstanceIdentifier.value_to_eobject(v, cursor)
        elif conf_type == C_OID:
            return Oid.value_to_eobject(v)
        elif conf_type == C_BINARY:
            return Binary.value_to_eobject(v)
        elif conf_type == C_IPV4PREFIX:
            return IPv4Prefix.value_to_eobject(v)
        elif conf_type == C_IPV6PREFIX:
            return IPv6Prefix.value_to_eobject(v)
        elif conf_type == C_DEFAULT:
            return EAtom('default')
        elif conf_type == C_DECIMAL64:
            return Decimal64_.value_to_eobject(v)
        elif conf_type == C_DQUAD:
            return DottedQuad.value_to_eobject(v)
        elif conf_type == C_HEXSTR:
            return HexString.value_to_eobject(v)
        elif conf_type == C_IPV4_AND_PLEN:
            return IPv4AndPrefixLen.value_to_eobject(v)
        elif conf_type == C_IPV6_AND_PLEN:
            return IPv6AndPrefixLen.value_to_eobject(v)
        return None

    @staticmethod
    def eobject_to_value(v: ?EObject, cursor: Cursor) -> ?value:
        # TODO
        return None
