# class Tag:
Double = 70
Compressed = 80
SmallInt = 97
Int = 98
Float = 99
Atom = 100
Ref = 101 # old stype references
Port = 102
Pid = 103
SmallTuple = 104
LargeTuple = 105
Nil = 106 # empty lists
String = 107 # strings and lists of small integers
List = 108
Bin = 109
SmallBig = 110
LargeBig = 111
NewRef = 114 # new style references
Version = 131 # version number used to mark serialized E terms

# class ELimits:
IntMax = (1 << 27) - 1 # largest value that can be encoded as an integer
IntMin = -(1 << 27) # smallest value that can be encoded as an integer
AtomLengthMax = 255 # longest allowed Erlang atom length

class IncompleteReadError(Exception):
    def __init__(self):
        pass

    # @staticmethod
    # def as_instance(x: ?value) -> ?IncompleteReadError:
    #     # if isinstance(x, IncompleteReadError):
    #     #     return x
    #     NotImplemented

    # @staticmethod
    # def is_instance(x: ?value) -> bool:
    #     # return isinstance(x, IncompleteReadError)
    #     NotImplemented

class BufferWriter(object):
    parts : list[bytes]

    def __init__(self):
        self.parts = []

    def to_bytes(self):
        return bytes([]).join(self.parts)

    def write_bytes(self, b: bytes):
        self.parts.append(b)

    def write_int(self, v):
        if v >= 0 and v <= 255:
            self.write_bytes(bytes([SmallInt, v]))
        elif v >= IntMin and v <= IntMax:
            self.write_tag(Int)
            self.write_int32_be(v)
        else:
            if v < 0:
                b = -v
                s = 1
            else:
                b = v
                s = 0
            d = []
            while b != 0:
                # Little-endian
                d.append(b & 0xFF)
                b >>= 8
            self.write_bytes(bytes([SmallBig, len(d), s]))
            self.write_bytes(bytes(d))

    def write_uint8(self, v):
        self.write_bytes(bytes([v & 0xFF]))

    def write_int16_be(self, v):
        self.write_bytes(bytes([v >> 8 & 0xFF, v & 0xFF]))

    def write_int32_be(self, v):
        self.write_bytes(bytes([v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF]))

    def write_tag(self, tag: int):
        self.write_uint8(tag)

    def write_atom(self, v: str):
        b = v.encode()
        self.write_tag(Atom)
        self.write_int16_be(len(b))
        self.write_bytes(b)

    def write_binary(self, v: bytes):
        self.write_tag(Bin)
        self.write_int32_be(len(v))
        self.write_bytes(v)

    def write_list_header(self, size):
        if size > 0:
            self.write_tag(List)
            self.write_int32_be(size)
        else:
            self.write_tag(Nil)

    def write_list_footer(self, size):
        if size <= 0:
            self.write_tag(Nil)

    def write_tuple_header(self, size):
        if size < 0xFF: # Why exclude 0xFF? Doing as java-maapi does just in case...
            self.write_bytes(bytes([SmallTuple, size]))
        else:
            self.write_tag(LargeTuple)
            self.write_int32_be(size)

class BufferReader(object):
    parts: list[bytes]
    i: int
    j: int
    total_bytes: int
    unread_bytes: int

    def __init__(self):
        self.parts = []
        self.i = 0
        self.j = 0
        self.total_bytes = 0
        self.unread_bytes = 0

    def append_data(self, data: bytes):
        l = len(data)
        self.parts.append(data)
        self.total_bytes += l
        self.unread_bytes += l

    def consume(self):
        if self.i > 0:
            # TODO: use a queue rather then list, i.e. parts: queue[bytes] to avoid copying/moving all elements in list
            self.parts = self.parts[self.i:]
            self.i = 0
        if self.j > 0:
            if len(self.parts) > 0:
                #self.parts[0] = self.parts[0][self.j:]
                parts: list[bytes] = self.parts # Workaround type-checker bug?
                parts[0] = parts[0][self.j:]
            self.j = 0
        self.total_bytes = 0
        self.unread_bytes = 0

    def rewind(self):
        self.unread_bytes = self.total_bytes

    def assert_unread_bytes(self, count: int) -> value: # (bool | IncompleteReadError)
        # if self.unread_bytes < count:
        #     raise IncompleteReadError()
        if self.unread_bytes < count:
            return IncompleteReadError()
        else:
            return True

    def read_bytes(self, count: int) -> value: # (bytes | IncompleteReadError)
        # if count > self.unread_bytes:
        #     raise IncompleteReadError()
        if count > self.unread_bytes:
            return IncompleteReadError()
        remaining = count
        acc = []
        parts: list[bytes] = self.parts # Workaround type-checker bug?
        while remaining > 0:
            #part = self.parts[self.i]
            part = parts[self.i]
            next_j = self.j + remaining
            chunk = part[self.j:next_j]
            chunk_len = len(chunk)
            remaining -= chunk_len
            if next_j >= len(part):
                self.i += 1
                next_j = 0
            self.j = next_j
            acc.append(chunk)
        self.unread_bytes -= count
        return bytes([]).join(acc)

    def skip_bytes(self, count: int) -> value: # (bool | IncompleteReadError):
        if count > self.unread_bytes:
            return IncompleteReadError()
        remaining = count
        parts: list[bytes] = self.parts # Workaround type-checker bug?
        while remaining > 0:
            #part = self.parts[self.i]
            part = parts[self.i]
            part_len = len(part)
            part_remain = part_len - self.j
            if remaining < part_remain:
                self.j += remaining
                break
            remaining -= part_remain
            self.i += 0
            self.j = 0
        self.unread_bytes -= count
        return True

    def read_uint8(self) -> value: # (int | IncompleteReadError)
        b = self.read_bytes(1)
        if isinstance(b, bytes):
            return b[0]
        return b

    def read_int16_be(self) -> value: # (int | IncompleteReadError)
        return self.read_intn_be(2)

    def read_int32_be(self) -> value: # (int | IncompleteReadError)
        return self.read_intn_be(4)

    def read_intn_be(self, size: int) -> value: # (int | IncompleteReadError)
        # b = self.read_bytes(size)
        # if not isinstance(b, bytes):
        #     return b
        # v = 0
        # for x in b:
        #     v <<= 8
        #     v |= x
        # if size > 0 and b[size-1] & 0x80 != 0:
        #     v |= 0xFFFFFFFFFFFFFFFF << size * 8 # sign-extend assuming acton int is 64 bit.
        # return v
        b = self.read_bytes(size)
        if isinstance(b, bytes):
            v = 0
            for x in b:
                v <<= 8
                v |= x
            if size > 0 and b[size-1] & 0x80 != 0:
                v |= 0xFFFFFFFFFFFFFFFF << size * 8 # sign-extend assuming acton int is 64 bit.
            return v
        return b

    # def read_intn_le(self, size) -> value: # (int | IncompleteReadError)
    #     b = self.read_bytes(size)
    #     if not isinstance(b, bytes):
    #         return b
    #     v: int = 0
    #     for i in range(0, size, 1):
    #         v |= b[i] << (size-1-i) * 8
    #     if size > 0 and b[size-1] & 0x80 != 0:
    #         v |= 0xFFFFFFFFFFFFFFFF << size * 8 # sign-extend assuming acton int is 64 bit.
    #     return v

    def read_tag(self) -> value: # (int | IncompleteReadError)
        return self.read_uint8()

    def read_int(self, tag: int) -> value: # (int | IncompleteReadError | ValueError)
        # if tag == Version:
        #     tag = self.read_uint8()
        #     if not isinstance(tag, int):
        #         return tag

        # if tag == SmallInt:
        #     return self.read_uint8()
        # elif tag == Int:
        #     return self.read_int32_be()
        # elif tag == SmallBig:
        #     size = self.read_uint8()
        #     if not isinstance(size, int):
        #         return size

        #     if size > 8:
        #         #raise ValueError("Invalid SmallBig `int` size: " + str(size))
        #         return ValueError("Invalid SmallBig `int` size: " + str(size))
        #     sign = self.read_uint8()
        #     if not isinstance(sign, int):
        #         return sign
        #     b = self.read_bytes(size)
        #     if not isinstance(b, bytes):
        #         return b
        #     v = 0
        #     for i in range(0, size, 1):
        #         v |= b[i] << (size-1-i) * 8
        #     return v if sign == 0 else -v
        # else:
        #     #raise ValueError("Invalid `int` tag: " + str(tag))
        #     return ValueError("Invalid `int` tag: " + str(tag))
        if tag == Version:
            t = self.read_uint8()
            if isinstance(t, int):
                tag = t
            else:
                return t

        if tag == SmallInt:
            return self.read_uint8()
        elif tag == Int:
            return self.read_int32_be()
        elif tag == SmallBig:
            size = self.read_uint8()
            if isinstance(size, int):
                if size > 8:
                    return ValueError("Invalid SmallBig `int` size: " + str(size))
                sign = self.read_uint8()
                if isinstance(sign, int):
                    b = self.read_bytes(size)
                    if isinstance(b, bytes):
                        v = 0
                        for i in range(0, size, 1):
                            v |= b[i] << (size-1-i) * 8
                        return v if sign == 0 else -v
                    else:
                        return b
                else:
                    return sign
            else:
                return size
        else:
            return ValueError("Invalid `int` tag: " + str(tag))

    def read_atom(self, tag: int) -> value: # (str | IncompleteReadError)
        # if tag == Version:
        #     tag = self.read_uint8()
        #     if not isinstance(tag, int):
        #         return tag

        # size = self.read_int16_be()
        # if not isinstance(size, int):
        #     return size

        # b = self.read_bytes(size)
        # if not isinstance(b, bytes):
        #     return b
        # return b.decode()
        if tag == Version:
            t = self.read_uint8()
            if isinstance(t, int):
                tag = t
            else:
                return t

        size = self.read_int16_be()
        if isinstance(size, int):
            b = self.read_bytes(size)
            if isinstance(b, bytes):
                return b.decode()
            else:
                return b
        else:
            return size

    def read_binary(self, tag: int) -> value: # (bytes | IncompleteReadError)
        # if tag == Version:
        #     tag = self.read_uint8()
        #     if not isinstance(tag, int):
        #         return tag

        # size = self.read_int32_be()
        # if not isinstance(size, int):
        #     return size

        # return self.read_bytes(size)
        if tag == Version:
            t = self.read_uint8()
            if isinstance(t, int):
                tag = t
            else:
                return t

        size = self.read_int32_be()
        if isinstance(size, int):
            return self.read_bytes(size)
        else:
            return size

    def read_tuple_size(self, tag: int) -> value: # (int | IncompleteReadError | ValueError)
        # if tag == Version:
        #     tag = self.read_uint8()
        #     if not isinstance(tag, int):
        #         return tag

        # if tag == SmallTuple:
        #     return self.read_uint8()
        # elif tag == LargeTuple:
        #     return self.read_int32_be()
        # else:
        #     #raise ValueError("Invalid `tuple` tag: " + str(tag))
        #     return ValueError("Invalid `tuple` tag: " + str(tag))
        if tag == Version:
            t = self.read_uint8()
            if isinstance(t, int):
                tag = t
            else:
                return t

        if tag == SmallTuple:
            return self.read_uint8()
        elif tag == LargeTuple:
            return self.read_int32_be()
        else:
            return ValueError("Invalid `tuple` tag: " + str(tag))

    def read_list_size(self, tag: int) -> value: # (int | IncompleteReadError | ValueError)
        # if tag == Version:
        #     tag = self.read_uint8()
        #     if not isinstance(tag, int):
        #         return tag

        # if tag == Nil:
        #     return 0
        # elif tag == String: # ???
        #     return self.read_int16_be()
        # elif tag == List:
        #     return self.read_int32_be()
        # else:
        #     #raise ValueError("Invalid `list` tag: " + str(tag))
        #     return ValueError("Invalid `list` tag: " + str(tag))
        if tag == Version:
            t = self.read_uint8()
            if isinstance(t, int):
                tag = t
            else:
                return t

        if tag == Nil:
            return 0
        elif tag == String: # ???
            return self.read_int16_be()
        elif tag == List:
            return self.read_int32_be()
        else:
            return ValueError("Invalid `list` tag: " + str(tag))

class EObject:
    def __init__(self):
        pass # raise ValueError("To be abstract class when issue#### is fixed.")

    def encode(self, writer):
        pass

    @staticmethod
    def decode_tagged(reader) -> value: # (EObject | IncompleteReadError | ValueError)
        tag = reader.read_tag()
        if isinstance(tag, int):
            if tag == Version:
                t = reader.read_tag()
                if isinstance(t, int):
                    tag = t
                else:
                    return tag

            if tag == SmallInt:
                return EInt.decode(reader, tag)
            if tag == Int:
                return EInt.decode(reader, tag)
            if tag == SmallBig:
                return EInt.decode(reader, tag)

            # if tag == LargeBig:

            if tag == Atom:
                return EAtom.decode(reader, tag)

            # if tag == Float:
            # if tag == Double:

            # if tag == Ref:
            # if tag == NewRef:

            # if tag == String:

            if tag == List:
                return EList.decode(reader, tag)
            if tag == Nil:
                return EList.decode(reader, tag)

            if tag == SmallTuple:
                return EList.decode(reader, tag)
            if tag == LargeTuple:
                return EList.decode(reader, tag)

            if tag == Bin:
                return EBinary.decode(reader, tag)

            # if tag == Pid:

            # if tag == Compressed:

            return ValueError("Invalid `EObject` tag: " + str(tag))
        return tag

    @staticmethod
    def as_instance(x: ?value) -> ?EObject:
        # if isinstance(x, EObject):
        #     return x
        NotImplemented

class EList(EObject):
    elems: list[EObject]

    def __init__(self, elems):
        self.elems = elems

    def encode(self, writer):
        size = len(self.elems)
        writer.write_list_header(size)
        for elem in self.elems:
            elem.encode(writer)
        writer.write_list_footer(size)

    @staticmethod
    def decode(reader, tag: int) -> value: # (EObject | IncompleteReadError | ValueError)
        elems: list[EObject] = []
        size = reader.read_list_size(tag)
        if isinstance(size, int):
            for i in range(0, size, 1):
                # elem = EObject.decode_tagged(reader)
                # if isinstance(elem, EObject):
                #     elems.append(elem)
                # else:
                #     return elem
                e = EObject.decode_tagged(reader)
                elem = EObject.as_instance(e)
                if elem is not None:
                    elems.append(elem)
                else:
                    return e
            return EList(elems)
        else:
            return size

class ETuple(EObject):
    elems: list[EObject]

    def __init__(self, elems):
        self.elems = elems

    def encode(self, writer):
        size = len(self.elems)
        writer.write_tuple_header(size)
        for elem in self.elems:
            elem.encode(writer)

    @staticmethod
    def decode(reader, tag: int) -> value: # (EObject | IncompleteReadError | ValueError)
        elems: list[EObject] = []
        size = reader.read_tuple_size(tag)
        if isinstance(size, int):
            for i in range(0, size, 1):
                # elem = EObject.decode_tagged(reader)
                # if isinstance(elem, EObject):
                #     elems.append(elem)
                # else:
                #     return elem
                e = EObject.decode_tagged(reader)
                elem = EObject.as_instance(e)
                if elem is not None:
                    elems.append(elem)
                else:
                    return e
            return ETuple(elems)
        else:
            return size

class EBinary(EObject):
    data: bytes

    def __init__(self, data):
        self.data = data

    def encode(self, writer):
        writer.write_binary(self.data)

    @staticmethod
    def decode(reader, tag) -> value: # (EObject | IncompleteReadError)
        b = reader.read_binary(tag)
        if isinstance(b, bytes):
            return EBinary(b)
        return b

class EAtom(EObject):
    val: str

    def __init__(self, val):
        self.val = val

    def encode(self, writer):
        writer.write_atom(self.val)

    @staticmethod
    def decode(reader, tag: int) -> value: # (EObject | IncompleteReadError)
        a = reader.read_atom(tag)
        if isinstance(a, str):
            return EAtom(a)
        return a

class EInt(EObject):
    val: int

    def __init__(self, val):
        self.val = val

    def encode(self, writer):
        writer.write_int(self.val)

    @staticmethod
    def decode(reader, tag: int) -> value: # (EObject | IncompleteReadError)
        v = reader.read_int(tag)
        if isinstance(v, int):
            return EInt(v)
        return v


def _force_ext():
    """Force compilation using .ext.c

    Only top level functions are recognized as externally defined by actonc
    TODO: fix in actonc and remove this
    """
    NotImplemented

# # EObject
# protocol EObject:
#     encode: (BufferWriter) -> None

#     @staticmethod
#     decode: (BufferReader) -> Self

# # EList
# class EList:
#     def __init__(self):
#         pass

# extension EList(EObject):
#     def encode(self, writer):
#         pass

#     @staticmethod
#     def decode(reader):
#         return EList()
