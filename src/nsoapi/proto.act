# class Tag:
Double = 70
Compressed = 80
SmallInt = 97
Int = 98
Float = 99
Atom = 100
Ref = 101 # old stype references
Port = 102
Pid = 103
SmallTuple = 104
LargeTuple = 105
Nil = 106 # empty lists
String = 107 # strings and lists of small integers
List = 108
Bin = 109
SmallBig = 110
LargeBig = 111
NewRef = 114 # new style references
Version = 131 # version number used to mark serialized E terms

# class ELimits:
IntMax = (1 << 27) - 1 # largest value that can be encoded as an integer
IntMin = -(1 << 27) # smallest value that can be encoded as an integer
AtomLengthMax = 255 # longest allowed Erland atom length

class BufferWriter(object):
    parts : list[bytes]

    def __init__(self):
        self.parts = []

    def to_bytes(self):
        return bytes([]).join(self.parts)

    def write_bytes(self, b: bytes):
        self.parts.append(b)

    def write_int(self, v):
        if v >= 0 and v <= 255:
            self.write_bytes(bytes([SmallInt, v]))
        elif v >= IntMin and v <= IntMax:
            self.write_uint8(Int)
            self.write_int32_be(v)
        else:
            if v < 0:
                b = -v
                s = 1
            else:
                b = v
                s = 0
            d = []
            while b != 0:
                # Little-endian
                d.append(b & 0xFF)
                b >>= 8
            self.write_bytes(bytes([SmallBig, len(d), s]))
            self.write_bytes(bytes(d))

    def write_uint8(self, v):
        self.write_bytes(bytes([v & 0xFF]))

    def write_int16_be(self, v):
        self.write_bytes(bytes([v >> 8 & 0xFF, v & 0xFF]))

    def write_int32_be(self, v):
        self.write_bytes(bytes([v >> 24 & 0xFF, v >> 16 & 0xFF, v >> 8 & 0xFF, v & 0xFF]))

    def write_atom(self, v: str):
        b = v.encode()
        self.write_uint8(Atom)
        self.write_int16_be(len(b))
        self.write_bytes(b)

    def write_binary(self, v: bytes):
        self.write_uint8(Bin)
        self.write_int32_be(len(v))
        self.write_bytes(v)

    def write_list_header(self, size):
        if size > 0:
            self.write_uint8(List)
            self.write_int32_be(size)
        else:
            self.write_uint8(Nil)

    def write_list_footer(self, size):
        if size <= 0:
            self.write_uint8(Nil)

    def write_tuple_header(self, size):
        if size < 0xFF: # Why exclude 0xFF? Doing as java-maapi does just in case...
            self.write_bytes(bytes([SmallTuple, size]))
        else:
            self.write_uint8(LargeTuple)
            self.write_int32_be(size)

class BufferReader(object):
    parts: list[bytes]
    i: int
    j: int

    def __init__(self):
        self.parts = []
        self.i = 0
        self.j = 0

    def read_bytes(self, count):
        remaining = count
        acc = []
        parts: list[bytes] = self.parts # Workaround type-checker bug?
        while remaining > 0:
            #part = self.parts[self.i]
            part = parts[self.i]
            next_j = self.j + remaining
            chunk = part[self.j:next_j]
            chunk_len = len(chunk)
            remaining -= chunk_len
            if next_j >= len(part):
                self.i += 1
                next_j = 0
            self.j = next_j
        return bytes([]).join(acc)

    def read_uint8(self) -> int:
        return self.read_bytes(1)[0]

    def read_int16_be(self) -> int:
        return self.read_intn_be(2)

    def read_int32_be(self) -> int:
        return self.read_intn_be(4)

    def read_intn_be(self, size) -> int:
        b = self.read_bytes(size)
        v = 0
        for x in b:
            v <<= 8
            v |= x
        if size > 0 and b[size-1] & 0x80 != 0:
            v |= 0xFFFFFFFFFFFFFFFF << size * 8 # sign-extend assuming acton int is 64 bit.
        return v

    def read_intn_le(self, size) -> int:
        b = self.read_bytes(size)
        v: int = 0
        for i in range(0, size, 1):
            v |= b[i] << (size-1-i) * 8
        if size > 0 and b[size-1] & 0x80 != 0:
            v |= 0xFFFFFFFFFFFFFFFF << size * 8 # sign-extend assuming acton int is 64 bit.
        return v

    def read_int(self, tag) -> int:
        if tag == Version:
            tag = self.read_uint8()

        v = 0 # Must init even if always overwritten before read

        if tag == SmallInt:
            v = self.read_uint8()
        elif tag == Int:
            v = self.read_int32_be()
        elif tag == SmallBig:
            size = self.read_uint8()
            if size > 8:
                raise ValueError("Invalid SmallBig `int` size: " + str(size))
            sign = self.read_uint8()
            b = self.read_bytes(size)
            v = 0
            for i in range(0, size, 1):
                v |= b[i] << (size-1-i) * 8
            v = v if sign == 0 else -v
        else:
            raise ValueError("Invalid `int` tag: " + str(tag))

        return v

    def read_atom(self, tag) -> str:
        if tag == Version:
            tag = self.read_uint8()

        size = self.read_int16_be()
        return self.read_bytes(size).decode()

    def read_binary(self, tag) -> bytes:
        if tag == Version:
            tag = self.read_uint8()

        size = self.read_int32_be()
        return self.read_bytes(size)

    def read_tuple_size(self, tag) -> int:
        if tag == Version:
            tag = self.read_uint8()

        size = 0 # Must init even if always overwritten before read
        if tag == SmallTuple:
            size = self.read_uint8()
        elif tag == LargeTuple:
            size = self.read_int32_be()
        else:
            raise ValueError("Invalid `tuple` tag: " + str(tag))
        return size

    def read_list_size(self, tag):
        if tag == Version:
            tag = self.read_uint8()

        if tag == Nil:
            size = 0
        elif tag == String: # ???
            size = self.read_int16_be()
        elif tag == List:
            size = self.read_int32_be()
        else:
            raise ValueError("Invalid `list` tag: " + str(tag))

class EObject:
    def __init__(self):
        pass

    def encode(self, writer):
        pass

    @staticmethod
    def decode(reader) -> EObject:
        return EObject()

class EList(EObject):
    def __init__(self):
        pass

    def encode(self, writer):
        pass

    @staticmethod
    def decode(reader):
        return EList()

class ETuple(EObject):
    def __init__(self):
        pass

    def encode(self, writer):
        pass

    @staticmethod
    def decode(reader):
        return ETuple()

class EBinary(EObject):
    def __init__(self):
        pass

    def encode(self, writer):
        pass

    @staticmethod
    def decode(reader):
        return EBinary()

class EAtom(EObject):
    def __init__(self):
        pass

    def encode(self, writer):
        pass

    @staticmethod
    def decode(reader):
        return EAtom()

class EInt(EObject):
    def __init__(self):
        pass

    def encode(self, writer):
        pass

    @staticmethod
    def decode(reader):
        return EInt()

#
# def _force_ext():
#     """Force compilation using .ext.c

#     Only top level functions are recognized as externally defined by actonc
#     TODO: fix in actonc and remove this
#     """
#     NotImplemented

# # EObject
# protocol EObject:
#     encode: (BufferWriter) -> None

#     @staticmethod
#     decode: (BufferReader) -> Self

# # EList
# class EList:
#     def __init__(self):
#         pass

# extension EList(EObject):
#     def encode(self, writer):
#         pass

#     @staticmethod
#     def decode(reader):
#         return EList()
