import net
from nsoapi.proto import *
from nsoapi.conf import *

DB_CANDIDATE = 1
DB_RUNNING = 2
DB_STARTUP = 3
DB_OPERATIONAL = 4
DB_PRE_COMMIT_RUNNING = 6
DB_INTENDED = 7

MODE_READ = 1
MODE_READ_WRITE = 2

_MAAPI_START_USER_SESSION = 100
_MAAPI_END_USER_SESSION = 101
_MAAPI_START_TRANS = 140
_MAAPI_FINISH_TRANS = 142 # AKA MAAPI_STOP_TRANS internally in java-api but finishTrans externally and maapi_finish_trans in c-api
_MAAPI_APPLY_TRANS = 143
_MAAPI_GET_VALUES = 194
_MAAPI_SET_VALUES = 195

_ERL_EXTERN_FMT = Version

class ProtoError(Exception):
    def __init__(self):
        pass

class MaapiException(ProtoError):
    def __init__(self, op: int, error_code: int, error_msg: ?str, conf_path: ?str):
        self.op = op
        self.error_code = error_code
        self.error_msg = error_msg
        self.conf_path = conf_path

    def __str__(self) -> str:
        # return "MaapiException(op=" + str(self.op) \
        #     + ", errcode=" + str(self.error_code) \
        #     + ", errstr=" + str(self.error_msg) \
        #     + ", path=" + str(self.conf_path) + ")"

        error_msg: str = ""
        _error_msg: ?str = self.error_msg
        if _error_msg is not None:
            error_msg = _error_msg
        conf_path: str = "None"
        _conf_path: ?str = self.conf_path
        if _conf_path is not None:
            conf_path = _conf_path
        return "MaapiException(op=" + str(self.op) \
            + ", errcode=" + str(self.error_code) \
            + ", errmsg=" + error_msg \
            + ", path=" + conf_path + ")"

class MaapiProtoError(ProtoError):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self) -> str:
        return "MaapiProtoError(\"" + self.msg + "\")"

class ServerVersionError(ProtoError):
    def __init__(self):
        pass

def addr_to_eobject(addr: str) -> EObject:
    if addr != "127.0.0.1":
        raise Exception("NOT IMPLEMENTED!") # NotImplementedError()
    else:
        return ETuple([EInt(127), EInt(0), EInt(0), EInt(1)])

class UserIdentity:
    # vendor: ?str
    # product: ?str
    # version: ?str
    # client_id: ?str

    def __init__(self, vendor, product, version, client_id):
        self.vendor = vendor
        self.product = product
        self.version = version
        self.client_id = client_id

    @staticmethod
    def from_eobject(o: EObject) -> UserIdentity:
        vendor = None
        product = None
        version = None
        client_id = 'acton-streamer'
        return UserIdentity(vendor, product, version, client_id)

    def to_eobject(self) -> EObject:
        #if self.vendor is None and self.product is None and self.version is None and self.client_id is None:
        _vendor = self.vendor
        _product = self.product
        _version = self.version
        _client_id = self.client_id
        if _vendor is None and _product is None and _version is None and _client_id is None:
             return EAtom('undefined')
        else:
            elems = []
            # elems.append(EBinary(self.vendor.encode()) if self.vendor is not None else EAtom('undefined'))
            # elems.append(EBinary(self.product.encode()) if self.product is not None else EAtom('undefined'))
            # elems.append(EBinary(self.version.encode()) if self.version is not None else EAtom('undefined'))
            # elems.append(EBinary(self.client_id.encode()) if self.client_id is not None else EAtom('undefined'))
            if _vendor is not None and isinstance(_vendor, str):
                vendor: str = _vendor
                elems.append(EBinary(vendor.encode()))
            else:
                elems.append(EAtom('undefined'))
            if _product is not None and isinstance(_product, str):
                product: str = _product
                elems.append(EBinary(product.encode()))
            else:
                elems.append(EAtom('undefined'))
            if _version is not None and isinstance(_version, str):
                version: str = _version
                elems.append(EBinary(version.encode()))
            else:
                elems.append(EAtom('undefined'))
            if _client_id is not None and isinstance(_client_id, str):
                client_id: str = _client_id
                elems.append(EBinary(client_id.encode()))
            else:
                elems.append(EAtom('undefined'))
            return ETuple(elems)

class UserSessionDescription:
    # user: str
    # src_addr: str
    # context: str
    # groups: list[str]
    # proto: ?int
    # user_identity: UserIdentity

    def __init__(self, user, src_addr, context, groups, proto, use_ikp, user_ident: UserIdentity):
        self.user = user
        self.src_addr = src_addr
        self.context = context
        self.groups = groups
        self.proto = proto
        self.use_ikp = use_ikp
        self.user_ident = user_ident

    @staticmethod
    def from_eobject(o: EObject) -> UserSessionDescription:
        user = ""
        src_addr = ""
        context = ""
        groups = []
        proto = 0
        use_ikp = True
        user_ident = UserIdentity(None, None, None, None)
        return UserSessionDescription(user, src_addr, context, groups, proto, use_ikp, user_ident)

    def to_eobject(self, server_vsn) -> EObject:
        if server_vsn > 0x06020000:
            elems = []
            elems.append(EBinary(self.user.encode()))
            elems.append(addr_to_eobject(self.src_addr))
            elems.append(EAtom(self.context))

            # elems.append(EInt(0 if self.proto is None else self.proto))
            proto: ?int = self.proto
            elems.append(EInt(proto if proto is not None else 0))

            elems.append(eatom_from_bool(self.use_ikp))

            # elems.append(EList([EBinary(g.encode()) for g in self.groups], True))
            group_elems = []
            for g in self.groups:
                group_elems.append(EBinary(g.encode()))
            elems.append(EList(group_elems, True))

            elems.append(self.user_ident.to_eobject())

            return ETuple(elems)
        else:
            elems = []
            elems.append(EBinary(self.user.encode()))
            elems.append(addr_to_eobject(self.src_addr))
            elems.append(EAtom(self.context))

            # elems.append(EInt(0 if self.proto is None else self.proto))
            proto: ?int = self.proto
            elems.append(EInt(proto if proto is not None else 0))

            for g in self.groups:
                elems.append(EBinary(g.encode()))

            return EList(elems, True)

actor MaapiConnection(env: Env, port: int, on_connect: action(MaapiConnection) -> None):
    IA_CLIENT_MAAPI = 7
    CLIENT_PROTO_VSN = 78
    CLIENT_VSN = 0x07080000

    listen_auth = net.TCPConnectAuth(net.TCPAuth(net.NetAuth(env.auth)))
    input_stream: BufferReader = BufferReader()

    var recv_queue: list[proc() -> ?value] = [] # TODO: Proper queue with O(1) pop_front & push_back

    proto_vsn = 0
    server_vsn = 0

    # Workaround compiler ordering issue
    var conn: ?net.TCPIPConnection = None

    def self() -> MaapiConnection:
        NotImplemented

    def _write(data: bytes):
        print("MaapiConnection TCP send:", data)
        if conn is not None:
            # conn.write(data)
            # Looks like writes can be reordered unless we wait for them. E.g. actor -> actor ordering is violated?
            await async conn.write(data)
        else:
            # `conn` is made nullable only to workaround compiler ordering issue
            raise ValueError("Attempting to write without valid connection")

    def _connect_maapi_cb() -> ?value:
        e = input_stream.assert_unread_bytes(9)
        if isinstance(e, IncompleteReadError):
            return e

        d = input_stream.read_u8()
        _proto_vsn = input_stream.read_i16_be()
        _server_vsn = input_stream.read_i32_be()

        if isinstance(d, int) and isinstance(_proto_vsn, int) and isinstance(_server_vsn, int):
            if d == 0:
                pass
            elif d == 1:
                raise ServerVersionError()
            elif d == 2:
                # TODO: For non maapi sessions
                pass

            input_stream.skip_bytes(2) # What's here?

            proto_vsn = _proto_vsn
            server_vsn = _server_vsn

            print("MaapiConnection MAAPI connected. proto_vsn: ", proto_vsn, ", server_vsn: ", hex(server_vsn))
            on_connect(self())
        else:
            raise ProtoError()

    def _connect_maapi():
        w = BufferWriter()
        w.write_u8(IA_CLIENT_MAAPI) # TODO: Support access-secret-challenge
        w.write_i16_be(CLIENT_PROTO_VSN)
        w.write_i32_be(CLIENT_VSN)
        w.write_i16_be(0)

        _write(w.to_bytes())

        _add_recv(_connect_maapi_cb)

    def _add_recv(recv: proc() -> ?value):
        recv_queue.append(recv)

    def _pop_recv():
        #return recv_queue.pop(0)
        res = recv_queue[0]
        recv_queue = recv_queue[1:] # TODO: Proper queue with O(1) pop_front
        # We arent't allowed to return a proc(), even for use internally in the actor,
        # presumably due to a general safeguard to avoid leaking non-action-effect or just proc/mut methods?
        # return res

    # def _poll_recv():
    #     if len(recv_queue) >= 1:
    #         recv, done = recv_queue[0]
    #         try:
    #             result = recv()
    #         except IncompleteReadError:
    #             pass
    #         else:
    #             _pop_recv()
    #             done(result)
    #     else:
    #         # TODO: If received unexpected data, reconnect?
    #         pass

    def _poll_recv():
        if len(recv_queue) >= 1:
            recv = recv_queue[0]
            result: ?value = recv()
            if result is not None and isinstance(result, IncompleteReadError):
                input_stream.rewind()
            else:
                input_stream.consume()
                _pop_recv()
        else:
            # If received unexpected data, reconnect.
            # self._on_tcp_error(self.conn, "Received unexpected data.")
            pass

    def _on_tcp_connect(c):
        print("MaapiConnection TCP connected")
        _connect_maapi()

    def _on_tcp_receive(c, data):
        print("MaapiConnection TCP recv:", data)
        input_stream.append_data(data)
        _poll_recv()

    def _on_tcp_error(c, msg):
        print("MaapiConnection TCP error:", msg)
        input_stream.consume()
        # TODO: (re)consider backoff
        after 1: _reconnect()

    def _new_connection():
        return net.TCPIPConnection(listen_auth, "127.0.0.1", port, _on_tcp_connect, _on_tcp_receive, _on_tcp_error)

    def _reconnect():
        conn = _new_connection()

    # Workaround compiler ordering issue
    conn = _new_connection()

    action def _send_maapi_request(op: ?int, thandle: ?int, req: ?EObject, response_cb: action(?value) -> None):
        payload_writer = BufferWriter()
        if req is not None and isinstance(req, EObject):
            print("ENC EObject:", str(req))
            payload_writer.write_tag(_ERL_EXTERN_FMT)
            req.encode(payload_writer)
        payload_data = payload_writer.to_bytes()

        # # <DEBUG>
        # if req is not None and isinstance(req, EObject):
        #     r = BufferReader()
        #     r.append_data(payload_data)
        #     d = eobject_decode_tagged(r)
        #     if isinstance(d, EObject):
        #         print("DEC EObject:", str(d))
        #     else:
        #         print("DEC EObject: <decode failed>")
        # # </DEBUG>

        header_writer = BufferWriter()
        if op is not None:
            header_writer.write_i32_be(op)
            if thandle is not None:
                header_writer.write_i32_be(thandle)
        header_data = header_writer.to_bytes()

        len_writer = BufferWriter()
        header_payload_len = len(header_data) + len(payload_data)
        len_writer.write_i32_be(header_payload_len)
        len_data = len_writer.to_bytes()

        _add_recv(lambda: _maapi_response_cb(op, response_cb))

        # _write(len_data + header_data + payload_data)
        _write(len_data)
        _write(header_data)
        _write(payload_data)

    def _maapi_response_cb(op: ?int, response_cb: action(?value) -> None) -> ?value:
        result = ConfResponse(op if op is not None else -1, None, False, 0, None)
        retval: ?value = result
        _response_len = input_stream.read_i32_be()
        if isinstance(_response_len, int):
            response_len: int = _response_len
            expected_len = response_len + 4
            e = input_stream.assert_unread_bytes(response_len)
            if isinstance(e, IncompleteReadError):
                return e
            e2 = __maapi_response_read_content(op, result, expected_len)
            if e2 is not None:
                if isinstance(e2, IncompleteReadError):
                    return e2
                retval = e2
            else:
                read_len = input_stream.read_bytes_count()
                if read_len != expected_len:
                    print("WARNING: Inconsistent length of MAAPI response, expected:", expected_len, ", actual:", read_len)

        else:
            if isinstance(_response_len, IncompleteReadError):
                return _response_len
            retval = _response_len
        response_cb(retval)

    def __maapi_response_read_content(op: ?int, result, expected_len: int) -> ?value:
        if op is None:
            return __maapi_response_read_term(result)
        else:
            _res_op = input_stream.read_u32_be()
            if isinstance(_res_op, int):
                result.op = _res_op
                #if result.op & CDB_ERROR_FLAG_MASK != 0: # BUG: Runtime error on bitwise operations
                if (result.op // CDB_ERROR_FLAG_MASK) % 2 == 1:
                    result.is_error = True
                    _error_code = input_stream.read_i32_be()
                    if isinstance(_error_code, int):
                        result.error_code = _error_code
                        _error_obj = eobject_decode_tagged(input_stream)
                        if isinstance(_error_obj, EObject):
                            if isinstance(_error_obj, EBinary):
                                #result.error_msg = str(_error_obj)
                                result.error_msg = str(_error_obj)
                            elif isinstance(_error_obj, ETuple):
                                # {String, AppTag} ?
                                if len(_error_obj.elems) >= 1:
                                    e = _error_obj.elems[0]
                                    if isinstance(e, EBinary):
                                        #result.error_msg = str(e)
                                        result.error_msg = str(e)
                            else:
                                result.error_msg = str(_error_obj)
                            return
                        else:
                            return _error_obj
                    else:
                        return _error_code
                else:
                    if input_stream.read_bytes_count() < expected_len:
                        return __maapi_response_read_term(result)
                    else:
                        return
            else:
                return _res_op
            return

    def __maapi_response_read_term(result) -> ?value:
        # _response = EObject.decode_tagged(input_stream)
        _response = eobject_decode_tagged(input_stream)
        if isinstance(_response, EObject):
            result.term = _response
        else:
            return _response

    def try_to_maapi_exception(resp: ConfResponse) -> ?MaapiException:
        if resp.is_error:
            return MaapiException(resp.op, resp.error_code, resp.error_msg, None)
        return None

    def _none_result_cb(resp: ?value, result_cb: action(MaapiConnection, ?Exception) -> None):
        retval: ?Exception = None
        if resp is not None:
            if isinstance(resp, ConfResponse):
                retval = try_to_maapi_exception(resp)
            elif isinstance(resp, Exception):
                retval = resp
        result_cb(self(), retval)

    def _int_result_cb(resp: ?value, result_cb: action(MaapiConnection, value) -> None):
        retval: value = False
        if resp is not None:
            if isinstance(resp, ConfResponse):
                ex = try_to_maapi_exception(resp)
                if ex is not None:
                    retval = ex
                else:
                    t = resp.term
                    if isinstance(t, EInt):
                        retval = t.val
                    else:
                        if isinstance(t, EObject):
                            retval = MaapiProtoError("Unexpected response type: " + str(t))
                        else:
                            retval = MaapiProtoError("Unexpected response type")
            elif isinstance(resp, Exception):
                retval = resp
        result_cb(self(), retval)

    def start_user_session(session_descr: UserSessionDescription, result_cb: action(MaapiConnection, ?Exception) -> None):
        e = session_descr.to_eobject(server_vsn)
        if isinstance(e, EObject):
            _send_maapi_request(_MAAPI_START_USER_SESSION, None, e, lambda v: _none_result_cb(v, result_cb))
            # def _start_user_session_cb(resp: ?value):
            #     _none_result_cb(resp, result_cb)
            # _send_maapi_request(_MAAPI_START_USER_SESSION, None, e, _start_user_session_cb)
        elif isinstance(e, Exception):
            result_cb(self(), e)

    def end_user_session(result_cb: action(MaapiConnection, ?Exception) -> None):
        _send_maapi_request(_MAAPI_END_USER_SESSION, None, None, lambda v: _none_result_cb(v, result_cb))

    def start_trans(db_id: int, mode: int, user_ident: UserIdentity, result_cb: action(MaapiConnection, value) -> None):
        elems = []
        elems.append(EInt(db_id))
        elems.append(EInt(mode))
        if server_vsn > 0x06020000:
            elems.append(user_ident.to_eobject())
        e = ETuple(elems)

        _send_maapi_request(_MAAPI_START_TRANS, None, e, lambda v: _int_result_cb(v, result_cb))

    def apply_trans(thandle: int, keep_open: bool, flags: int, result_cb: action(MaapiConnection, ?Exception) -> None):
        elems = []
        elems.append(eatom_from_bool(keep_open))
        elems.append(EInt(flags))
        e = ETuple(elems)

        _send_maapi_request(_MAAPI_APPLY_TRANS, thandle, e, lambda v: _none_result_cb(v, result_cb))

    def finish_trans(thandle: int, result_cb: action(MaapiConnection, ?Exception) -> None):
        _send_maapi_request(_MAAPI_FINISH_TRANS, thandle, None, lambda v: _none_result_cb(v, result_cb))

    def set_values(thandle: int, path: Keypath, values: list[TagVal], result_cb: action(MaapiConnection, ?Exception) -> None):
        elems = []
        # elems.append(EList([v.to_eobject() for v in values], True))
        velems = []
        for v in values:
            velems.append(v.to_eobject())
        elems.append(EList(velems, True))
        elems.append(path.to_eobject())
        e = ETuple(elems)

        _send_maapi_request(_MAAPI_SET_VALUES, thandle, e, lambda v: _none_result_cb(v, result_cb))

actor main(env):
    def _on_connect(c):
        print("MAAPI connected!!!!")
        c.start_user_session(UserSessionDescription("admin", "127.0.0.1", "system", [], None, True, UserIdentity(None, None, None, None)), _on_user_session)

    def _on_user_session(c, e):
        if e is None:
            print("MAAPI user session started!!!!")
            c.start_trans(DB_OPERATIONAL, MODE_READ_WRITE, UserIdentity(None, None, None, None), _on_start_trans)
        else:
            print("MAAPI user session failed:", e)

    def _on_start_trans(c, thandle):
        if isinstance(thandle, int):
            print("MAAPI started transaction thandle:", thandle)
            #c.set_values(thandle, Keypath([EList([EBinary("http://tail-f.com/ns/ncs".encode()), EBinary("devices".encode())], False)]), [], lambda c, e:_on_set_values(c, e, thandle))
            c.set_values(thandle,
                Keypath([
                    EList([EAtom('http://tail-f.com/ns/ncs'), EAtom('python-vm')], False),
                    EAtom('logging'),
                ]), [
                    # TagVal(ETuple([EList([EAtom('http://tail-f.com/ns/ncs'), EAtom('level')], False)]), ETuple([EInt(C_ENUM_VALUE), EInt(1)]))
                    # TagVal(ETuple([EList([EAtom('http://tail-f.com/ns/ncs'), EAtom('python-vm')], False)]), EAtom('start'))
                    # TagVal(ETuple([EAtom('logging')]), EAtom('start'))
                    # TagVal(ETuple([EAtom('level')]), ETuple([EInt(C_ENUM_VALUE), EInt(1)]))
                    # TagVal(ETuple([EList([EAtom('http://tail-f.com/ns/ncs'), EAtom('python-vm')], False)]), EAtom('stop'))
                ], lambda c, e:_on_set_values(c, e, thandle))
        else:
            print("MAAPI start transaction failed:", thandle)

    def _on_set_values(c, e, thandle):
        if e is None:
            print("MAAPI set_values success thandle:", thandle)
            c.apply_trans(thandle, False, 0, lambda c, e:_on_apply_trans(c, e, thandle))
        else:
            print("MAAPI set_values failed thandle:", thandle, "err:", e)

    def _on_apply_trans(c, e, thandle):
        if e is None:
            print("MAAPI applied transaction thandle:", thandle)
            c.finish_trans(thandle, lambda c, e:_on_finish_trans(c, e, thandle))
        else:
            print("MAAPI apply transaction failed thandle:", thandle, "err:", e)

    def _on_finish_trans(c, e, thandle):
        if e is None:
            print("MAAPI finished transaction thandle:", thandle)
            c.end_user_session(_on_end_user_session)
        else:
            print("MAAPI finish transaction failed thandle:", thandle, "err:", e)

    def _on_end_user_session(c, e):
        if e is None:
            print("MAAPI ended user session")
        else:
            print("MAAPI end user session failed:", e)

    print("Starting up...")
    sess = MaapiConnection(env, 4569, _on_connect)
    #await async env.exit(0)
