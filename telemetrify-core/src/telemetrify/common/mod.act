# Copyright (C) Deutsche Telekom AG
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

from telemetrify.common.utils import *

OP_NONE: int = 0
OP_MERGE: int = 1
OP_REPLACE: int = 2
OP_DELETE: int = 3
OP_NOCREATE: int = 4
# OP_MOVE = 5 # Additional key values
# OP_INSERT = 6 # Additional key values

def op_str(op: int) -> str:
    if op == OP_NONE:
        return "NONE"
    elif op == OP_MERGE:
        return "MERGE"
    elif op == OP_REPLACE:
        return "REPLACE"
    elif op == OP_DELETE:
        return "DELETE"
    elif op == OP_NOCREATE:
        return "NOCREATE"
    else:
        raise Exception("Not Implemented for op: " + str(op))

class Id:
    pass

class Tag(Id):
    def is_root(self) -> bool:
        raise Exception("Not Implemented")

    def prsrc(self) -> str:
        raise NotImplementedError("Can't print source for Tag")

class ITag(Tag):
    @property
    ns: ?str
    @property
    name: str

    def __init__(self, ns: ?str, name: str):
        self.ns = ns
        self.name = name

    def __str__(self) -> str:
        _ns = self.ns
        return _ns + ":" + self.name if _ns is not None else self.name

    def __repr__(self) -> str:
        return "ITag(%s, %s)" % (optional_repr(self.ns), repr(self.name))

    @staticmethod
    def root() -> ITag:
        return ITag(None, "")

    def is_root(self) -> bool:
        _ns: ?str = self.ns
        return _ns is None and not self.name

    # def to_eobject(self) -> EObject:
    #     _ns = self.ns
    #     if _ns is not None:
    #         return EList([EAtom(_ns), EAtom(self.name)], False)
    #     else:
    #         return EAtom(self.name)

    def prsrc(self) -> str:
        _ns = self.ns
        s_ns = '"' + _ns + '"' if _ns is not None else "None"
        return 'ITag(' + s_ns + ', "' + self.name + '")'

extension ITag(Hashable):
    def __eq__(self, other: ITag) -> bool:
        # return self.name == other.name and self.ns == other.ns
        # Workaround actonc error:
        # ld.lld: error: undefined symbol: $EqOptG_new
        return self.name == other.name and eq_optional(self.ns, other.ns)

    def __hash__(self) -> int:
        _ns = self.ns
        return safe_hash(hash(_ns) + hash(self.name) if _ns is not None else hash(self.name))

class PTag(Tag):
    @property
    prefix: ?str
    @property
    name: str

    def __init__(self, prefix: ?str, name: str):
        self.prefix = prefix
        self.name = name

    def __str__(self) -> str:
        _prefix = self.prefix
        return _prefix + ":" + self.name if _prefix is not None else self.name

    def __repr__(self) -> str:
        return "PTag(%s, %s)" % (optional_repr(self.prefix), repr(self.name))

    @staticmethod
    def root() -> PTag:
        return PTag(None, "")

    def is_root(self) -> bool:
        _prefix: ?str = self.prefix
        return _prefix is None and not self.name

extension PTag(Hashable):
    def __eq__(self, other: PTag) -> bool:
        # return self.name == other.name and self.prefix == other.prefix
        # Workaround actonc error:
        # ld.lld: error: undefined symbol: $EqOptG_new
        return self.name == other.name and eq_optional(self.prefix, other.prefix)

    def __hash__(self) -> int:
        _prefix = self.prefix
        return safe_hash(hash(_prefix) + hash(self.name) if _prefix is not None else hash(self.name))

class MTag(Tag):
    @property
    module: ?str
    @property
    name: str

    def __init__(self, module: ?str, name: str):
        self.module = module
        self.name = name

    def __str__(self) -> str:
        _module = self.module
        return _module + ":" + self.name if _module is not None else self.name

    def __repr__(self) -> str:
        return "MTag(%s, %s)" % (optional_repr(self.module), repr(self.name))

    @staticmethod
    def root() -> MTag:
        return MTag(None, "")

    def is_root(self) -> bool:
        _module: ?str = self.module
        return _module is None and not self.name

extension MTag(Hashable):
    def __eq__(self, other: MTag) -> bool:
        # return self.name == other.name and self.module == other.module
        # Workaround actonc error:
        # ld.lld: error: undefined symbol: $EqOptG_new
        return self.name == other.name and eq_optional(self.module, other.module)

    def __hash__(self) -> int:
        _module = self.module
        return safe_hash(hash(_module) + hash(self.name) if _module is not None else hash(self.name))

class HTag(Tag):
    @property
    ns_hash: int
    @property
    name_hash: int

    def __init__(self, ns_hash: int, name_hash: int):
        self.ns_hash = ns_hash
        self.name_hash = name_hash

    def __str__(self) -> str:
        return self.__repr__()

    def __repr__(self) -> str:
        return "HTag(%s, %s)" % (repr(self.ns_hash), repr(self.name_hash))

    @staticmethod
    def root() -> HTag:
        return HTag(0, 0)

    def is_root(self) -> bool:
        return self.ns_hash == 0 and self.name_hash == 0

extension HTag(Hashable):
    def __eq__(self, other: HTag) -> bool:
        return self.name_hash == other.name_hash and self.ns_hash == other.ns_hash

    def __hash__(self) -> int:
        return safe_hash(self.ns_hash + self.name_hash)

def _eq_optional_value(a: ?value, b: ?value):
    return a is not None and b is not None and _eq_value(a, b) or a is None and b is None

def _eq_value(a: value, b: value) -> bool:
    if isinstance(a, int) and isinstance(b, int):
        return a == b
    elif isinstance(a, str) and isinstance(b, str):
        return a == b
    elif isinstance(a, bool) and isinstance(b, bool):
        return a == b
    elif isinstance(a, bytes) and isinstance(b, bytes):
        return a == b
    elif isinstance(a, HTag) and isinstance(b, HTag):
        return a == b
    elif isinstance(a, PTag) and isinstance(b, PTag):
        return a == b
    elif isinstance(a, ITag) and isinstance(b, ITag):
        return a == b
    elif isinstance(a, MTag) and isinstance(b, MTag):
        return a == b
    elif isinstance(a, Decimal64) and isinstance(b, Decimal64):
        return a == b
    elif isinstance(a, IPv4Address) and isinstance(b, IPv4Address):
        return a == b
    elif isinstance(a, IPv6Address) and isinstance(b, IPv6Address):
        return a == b
    elif isinstance(a, IPv4Network) and isinstance(b, IPv4Network):
        return a == b
    elif isinstance(a, IPv6Network) and isinstance(b, IPv6Network):
        return a == b
    elif isinstance(a, DateTime) and isinstance(b, DateTime):
        return a == b
    elif isinstance(a, Date) and isinstance(b, Date):
        return a == b
    elif isinstance(a, Time) and isinstance(b, Time):
        return a == b
    elif isinstance(a, Duration) and isinstance(b, Duration):
        return a == b
    elif isinstance(a, Oid) and isinstance(b, Oid):
        return a == b
    raise Exception("_eq_value: Not Implemented for types " + str(type(a)) + " == " + str(type(b)))

def _hash_value(v: value) -> int:
    # Looks like we need to do this for now?
    # But it would be nice if we could express a `Hashable` constraint on a common super-type to all relevant key/leaf values
    # without needing to e.g. wrap `int`, `str` etc.
    if isinstance(v, int):
        return hash(v)
    elif isinstance(v, str):
        return hash(v)
    elif isinstance(v, bool):
        return hash(v)
    elif isinstance(v, bytes):
        return hash(v)
    elif isinstance(v, HTag):
        return hash(v)
    elif isinstance(v, PTag):
        return hash(v)
    elif isinstance(v, ITag):
        return hash(v)
    elif isinstance(v, MTag):
        return hash(v)
    elif isinstance(v, Decimal64):
        return hash(v)
    elif isinstance(v, IPv4Address):
        return hash(v)
    elif isinstance(v, IPv6Address):
        return hash(v)
    elif isinstance(v, IPv4Network):
        return hash(v)
    elif isinstance(v, IPv6Network):
        return hash(v)
    elif isinstance(v, DateTime):
        return hash(v)
    elif isinstance(v, Date):
        return hash(v)
    elif isinstance(v, Time):
        return hash(v)
    elif isinstance(v, Duration):
        return hash(v)
    elif isinstance(v, Oid):
        return hash(v)
    elif isinstance(v, list): # Leaf-list for completeness although not valid for keys
        return list_hash(v)
    raise Exception("_hash_value: Not Implemented for type: " + str(type(v)) + " of value: " + str(v))

class Key(Id):
    _keys: list[value]

    def __init__(self, keys: list[value]):
        self._keys = keys

    def __str__(self) -> str:
        return "Key(" + list_str(self._keys) + ")"

    def __repr__(self):
        return self.__str__()

    @staticmethod
    def wildcard() -> Key:
        #return KEY_WILDCARD
        return Key([])

    def is_wildcard(self):
        return len(self._keys) == 0

#KEY_WILDCARD = Key([])

extension Key(Hashable):
    def __eq__(self, other: Key) -> bool:
        # return self._keys == other._keys
        self_len = len(self._keys)
        if self_len != len(other._keys):
            return False
        for i in range(0, self_len, 1):
            if not _eq_value(self._keys[i], other._keys[i]):
                return False
        return True

    def __hash__(self) -> int:
        _hash: int = 0
        for _key in self._keys:
            _hash = _hash * 7 + _hash_value(_key)
        return safe_hash(_hash)

extension Key(Collection[value]):
    def __iter__(self) -> Iterator[value]:
        return iter(self._keys)

    @staticmethod
    # def __fromiter__(iterable: Iterable[value]) -> Key:
    def __fromiter__(iterable):
        #return Key(list(iterable))
        return Key(list(iter(iterable)))

    def __len__(self) -> int:
        return len(self._keys)

extension Key(Indexed[int, value]):
    def __getitem__(self, index: int) -> value:
        return self._keys[index]

    def __setitem__(self, index: int, _val: value) -> None:
        # TODO: Future FrozenIndexed protocol?
        raise Exception("Not implemented")

    def __delitem__(self, index: int) -> None:
        # TODO: Future FrozenIndexed protocol?
        raise Exception("Not implemented")

class Keypath:
    path: list[Id]

    def __init__(self, path: list[Id]):
        self.path = path

    def __str__(self) -> str:
        l: list[str] = []
        for x in self.path:
            unsafe_list_append(l, '/')
            unsafe_list_append(l, str(x))
        return "".join(l)

    def __repr__(self):
        return "Keypath(" + self.__str__() + ")"

    def try_get_key(self, index: int) -> ?Key:
        if index < len(self):
            k = self.path[index]
            if isinstance(k, Key):
                return k
        return None

    def try_slice(self, start: int, stop: int) -> ?Keypath:
        if stop <= len(self):
            #return self[index, slen]
            return Keypath(self.path[start:stop])

    def get_slice(self, start: int, stop: int) -> Keypath:
        return Keypath(self.path[start:stop])

    def is_sub_path(self, other: Keypath):
        self_len = len(self)
        return self_len <= len(other) and self.get_common_base_path_len(other) == self_len

    def is_strict_sub_path(self, other: Keypath):
        self_len = len(self)
        return self_len < len(other) and self.get_common_base_path_len(other) == self_len

    def get_common_base_path_len(self, other: Keypath):
        i = 0
        max_len = min2(len(self), len(other))
        while i < max_len:
            if self[i] != other[i]:
                break
            i += 1
        return i

    def get_common_base_path(self, other: Keypath):
        return self.get_slice(0, self.get_common_base_path_len(other))

extension Keypath(Collection[Id]):
    def __iter__(self) -> Iterator[Id]:
        return iter(self.path)

    @staticmethod
    # def __fromiter__(iterable: Iterable[value]) -> Keypath:
    def __fromiter__(iterable):
        return Keypath(list(iter(iterable)))

    def __len__(self) -> int:
        return len(self.path)

extension Keypath(Indexed[int, Id]):
    def __getitem__(self, index: int) -> Id:
        return self.path[index]

    def __setitem__(self, index: int, _val: Id) -> None:
        # TODO: Future FrozenIndexed protocol?
        raise Exception("Not implemented")

    def __delitem__(self, index: int) -> None:
        # TODO: Future FrozenIndexed protocol?
        raise Exception("Not implemented")

# extension Keypath(Sliceable[Keypath]):
#     def __getitem__(self, index: int) -> Id:
#         return Keypath([self.path.__getitem__(index)])

#     def __setitem__(self, index: int, _val: Keypath) -> None:
#         # TODO: Future FrozenIndexed protocol?
#         raise Exception("Not implemented")

#     def __delitem__(self, index: int) -> None:
#         # TODO: Future FrozenIndexed protocol?
#         raise Exception("Not implemented")

#     def __getslice__(self, s: slice) -> Keypath:
#         return Keypath(self.path.__getslice__(s))

#     def __setslice__(self, s: slice, iterable: Iterable[Keypath]) -> None:
#         # TODO: Future FrozenSliceable protocol?
#         raise Exception("Not implemented")

#     def __delslice__(self, s: slice) -> None:
#         # TODO: Future FrozenSliceable protocol?
#         raise Exception("Not implemented")

extension Keypath(Plus):
    def __add__(self, other):
        return Keypath(self.path + other.path)

    def __iadd__(self, other):
        # ERROR: Error when compiling telemetrify.common.mod module: Type error
        # Cannot infer mut < pure
        # self.path += other.path
        # self.path.extend(other.path)
        # return self
        # TODO: Future FrozenPlus protocol?
        raise Exception("Not implemented")

class KeypathBuilder(object):
    pass

class Node(object):
    def __str__(self) -> str:
        return self._str_compact("Node")

    def __repr__(self):
        return self.__str__()

    def _str_compact(self, name: str) -> str:
        _tag = self.tag()
        s_tag = (", " + str(_tag)) if _tag is not None else ""

        _keys = self.keys()
        s_keys = (", " + list_str(_keys)) if _keys else ""

        _value = self.value()
        s_value = (", " + str(_value)) if _value is not None else ""

        _children = self.children()
        s_children = (", " + list_str(_children)) if _children else ""

        return name + "(" + op_str(self.op()) + s_tag + s_keys + s_value + s_children + ")"

    def op(self) -> int:
        return OP_NONE

    def tag(self) -> ?Tag:
        return None

    def namespaces(self) -> ?(?str) -> ?str:
        return None

    def keys(self) -> list[Node]:
        return []

    def value(self) -> ?value:
        return None

    def children(self) -> list[Node]:
        return []

    # def new_instance(self, op: int, tag: ?Tag, namespaces: ?(?str) -> ?str, keys: list[Node], value: ?value, children: list[Node]) -> Node:
    #     raise Exception("Not implemented")
    def prsrc(self, indent: int) -> str:
        raise NotImplementedError("Can't print source for Node")

    def pretty_format_node_tree(self) -> str:
        parts: list[str] = []
        self._pretty_format_node_tree(parts, "")
        return "".join(parts)

    def _pretty_format_node_tree(self, parts: list[str], indent: str):
        _tag = self.tag()
        s_tag = (", " + repr(_tag)) if _tag is not None else ""

        _keys = self.keys()
        s_keys = (", keys=" + list_repr(_keys)) if _keys else ""

        _value = self.value()
        s_value = (", val=" + repr(_value)) if _value is not None else ""

        parts.append(indent + "Node(" + op_str(self.op()) + s_tag + s_keys + s_value + ")\n")

        for child in self.children():
            child._pretty_format_node_tree(parts, indent + "  ")

class XNode(Node):
    @property
    _op: int
    @property
    _tag: ?Tag
    @property
    _namespaces: ?(?str) -> ?str

    # def __init__(self, tag: ?Tag, namespaces: ?(?str) -> ?str):
    #     self._tag = tag
    #     self._namespaces = namespaces

    def op(self) -> int:
        return self._op

    def tag(self) -> ?Tag:
        return self._tag

    def namespaces(self) -> ?(?str) -> ?str:
        return self._namespaces

    def value(self) -> ?value:
        return None

    def children(self) -> list[Node]:
        return []

class XTree(XNode):
    @property
    _children: list[Node]

    def __init__(self, op: int, tag: ?Tag, namespaces: ?(?str) -> ?str, children: list[Node]):
        self._op = op
        self._tag = tag
        self._namespaces = namespaces
        self._children = children

    def children(self) -> list[Node]:
        return self._children

    # def new_instance(self, op: int, tag: ?Tag, namespaces: ?(?str) -> ?str, keys: list[Node], value: ?value, children: list[Node]) -> Node:
    #     if keys:
    #         raise ValueError("XTree does not allow keys")
    #     if value is not None:
    #         raise ValueError("XTree does not allow value")
    #     return XTree(op, tag, namespaces, children)

    # TODO: default indent=0
    def prsrc(self, indent: int) -> str:
        """Print source code of self and call children"""
        _tag = self._tag
        s_tag = ", " + (_tag.prsrc() if _tag is not None else "None")
        children_strs = []
        for child in self._children:
            children_strs.append(child.prsrc(indent+1))

        _ns = self._namespaces
        # TODO: implement support for printing namespaces!?
        s_ns = ", " + "None"

        s_children = ", [\n" + ",\n".join(children_strs) + "]"

        s_indent = ""
        for i in range(0, indent, 1):
            s_indent += "    "
        return s_indent + "XTree(OP_" + op_str(self._op) + s_tag + s_ns + s_children + ")"

class XLeaf(XNode):
    @property
    _value: ?value

    def __init__(self, op: int, tag: ?Tag, namespaces: ?(?str) -> ?str, value: ?value):
        self._op = op
        self._tag = tag
        self._namespaces = namespaces
        self._value = value

    def value(self) -> ?value:
        return self._value

    # def new_instance(self, op: int, tag: ?Tag, namespaces: ?(?str) -> ?str, keys: list[Node], value: ?value, children: list[Node]) -> Node:
    #     if keys:
    #         raise ValueError("XTree does not allow keys")
    #     if children:
    #         raise ValueError("XTree does not allow children")
    #     return XLeaf(op, tag, namespaces, value)

    def prsrc(self, indent: int) -> str:
        """Print source code"""
        _tag = self._tag
        s_tag = ", " + (_tag.prsrc() if _tag is not None else "None")

        _ns = self._namespaces
        # TODO: implement support for printing namespaces!?
        s_ns = ", " + "None"

        _val = self._value
        s_val = ', "' + str(_val) + '"' if _val is not None else "None"

        s_indent = ""
        for i in range(0, indent, 1):
            s_indent += "    "
        return s_indent + "XLeaf(OP_" + op_str(self._op) + s_tag + s_ns + s_val + ")"

class TNode(Node):
    @property
    _op: int
    @property
    _tag: Tag

    def __init__(self, op: int, tag: Tag):
        self._op = op
        self._tag = tag

    def __bool__(self) -> bool:
        return self.exists()

    #
    # Node
    #

    def op(self) -> int:
        return self._op

    def tag(self) -> ?Tag:
        return self._tag

    #
    # TNode
    #

    def iter(self) -> Iterator[TNode]:
        return [].__iter__()

    def iter_ids(self) -> Iterator[Id]:
        return [].__iter__()

    def iter_items(self) -> Iterator[(Id, TNode)]:
        return [].__iter__()

    def has_children(self) -> bool:
        return False

    def key(self) -> ?Key:
        return None

    def ttag(self) -> Tag:
        return self._tag

    def tree(self, op: ?int, _id: Id) -> TNode:
        #raise Exception("Not implemented")
        return self

    def leaf(self, op: ?int, _id: Id, _val: ?value) -> TNode:
        #raise Exception("Not implemented")
        return self

    def cont(self, op: ?int, tag: Tag) -> TNode:
        return self.tree(op, tag)

    def list(self, op: ?int, tag: Tag) -> TNode:
        return self.tree(op, tag)

    def elem(self, op: ?int, key: Key) -> TNode:
        return self.tree(op, key)

    def leaf_list(self, op: ?int, tag: Tag) -> TNode:
        return self.tree(op, tag)

    def leaf_elem(self, op: ?int, _val: value) -> TNode:
        return self.leaf(op, Key([_val]), _val)

    def remove(self, _id: Id) -> ?TNode:
        return self

    def clear(self) -> TNode:
        return self

    def attach(self, _id: Id, other: TNode) -> TNode:
        return self

    def merge(self, other: TNode) -> TNode:
        return self

    def clone(self):
        return self._copy_deep(None)

    def clone_as(self, new_op: ?int) -> TNode:
        return self._copy_deep(new_op)

    def _copy_deep(self, new_op: ?int) -> TNode:
        return self

    def go(self, _id: Id) -> TNode:
        """Try to get node or return dummy if not found."""
        node = self.get(_id)
        return node if node is not None else (TNode(OP_NONE, _id if isinstance(_id, Tag) else self._tag))

    def follow(self, keypath: Keypath) -> TNode:
        n: TNode = self
        for _id in keypath:
            n = n.go(_id)
        return n

    def tree_path(self, op: ?int, keypath: Keypath) -> TNode:
        n: TNode = self
        for _id in keypath:
            n = n.tree(op, _id)
        return n

    def exists(self) -> bool:
        return False

    def get(self, _id: Id) -> ?TNode:
        return None

    def has_child(self, _id: Id) -> bool:
        return False

    #
    # values
    #

    def try_value(self) -> ?value:
        return None

    def try_int(self) -> ?int:
        return None

    def try_str(self) -> ?str:
        return None

    def try_bool(self) -> ?bool:
        return None

    def try_bytes(self) -> ?bytes:
        return None

    def try_decimal64(self) -> ?Decimal64:
        return None

    def try_itag(self) -> ?ITag:
        return None

    def try_ptag(self) -> ?PTag:
        return None

    def try_mtag(self) -> ?MTag:
        return None

    def try_htag(self) -> ?HTag:
        return None

    def try_ipv4address(self) -> ?IPv4Address:
        return None

    def try_ipv6address(self) -> ?IPv6Address:
        return None

    def try_ipv4network(self) -> ?IPv4Network:
        return None

    def try_ipv6network(self) -> ?IPv6Network:
        return None

    def try_datetime(self) -> ?DateTime:
        return None

    def try_date(self) -> ?Date:
        return None

    def try_time(self) -> ?Time:
        return None

    def try_duration(self) -> ?Duration:
        return None

    def try_oid(self) -> ?Oid:
        return None

    def try_keypath(self) -> ?Keypath:
        return None

    #
    # Require value
    #

    def req_value(self) -> ?value:
        _val = self.try_value()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_int(self) -> int:
        _val = self.try_int()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_str(self) -> str:
        _val = self.try_str()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_bool(self) -> bool:
        _val = self.try_bool()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_bytes(self) -> bytes:
        _val = self.try_bytes()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_decimal64(self) -> Decimal64:
        _val = self.try_decimal64()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_itag(self) -> ITag:
        _val = self.try_itag()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_ptag(self) -> PTag:
        _val = self.try_ptag()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_mtag(self) -> MTag:
        _val = self.try_mtag()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_jtag(self) -> HTag:
        _val = self.try_htag()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_ipv4address(self) -> IPv4Address:
        _val = self.try_ipv4address()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_ipv6address(self) -> IPv6Address:
        _val = self.try_ipv6address()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_ipv4network(self) -> IPv4Network:
        _val = self.try_ipv4network()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_ipv6network(self) -> IPv6Network:
        _val = self.try_ipv6network()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_datetime(self) -> DateTime:
        _val = self.try_datetime()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_date(self) -> Date:
        _val = self.try_date()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_time(self) -> Time:
        _val = self.try_time()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_duration(self) -> Duration:
        _val = self.try_duration()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_oid(self) -> Oid:
        _val = self.try_oid()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    def req_keypath(self) -> Keypath:
        _val = self.try_keypath()
        if _val is not None:
            return _val
        else:
            raise Exception("Invalid leaf value") # TODO: show path?

    #
    # Value or default
    #

    def def_int(self, default: int) -> int:
        _val = self.try_int()
        return _val if _val is not None else default

    def def_str(self, default: str) -> str:
        _val = self.try_str()
        return _val if _val is not None else default

    def def_bool(self, default: bool) -> bool:
        _val = self.try_bool()
        return _val if _val is not None else default

    def def_bytes(self, default: bytes) -> bytes:
        _val = self.try_bytes()
        return _val if _val is not None else default

    def def_decimal64(self, default: Decimal64) -> Decimal64:
        _val = self.try_decimal64()
        return _val if _val is not None else default

    def def_itag(self, default: ITag) -> ITag:
        _val = self.try_itag()
        return _val if _val is not None else default

    def def_ptag(self, default: PTag) -> PTag:
        _val = self.try_ptag()
        return _val if _val is not None else default

    def def_mtag(self, default: MTag) -> MTag:
        _val = self.try_mtag()
        return _val if _val is not None else default

    def def_htag(self, default: HTag) -> HTag:
        _val = self.try_htag()
        return _val if _val is not None else default

    def def_ipv4address(self, default: IPv4Address) -> IPv4Address:
        _val = self.try_ipv4address()
        return _val if _val is not None else default

    def def_ipv6address(self, default: IPv6Address) -> IPv6Address:
        _val = self.try_ipv6address()
        return _val if _val is not None else default

    def def_ipv4network(self, default: IPv4Network) -> IPv4Network:
        _val = self.try_ipv4network()
        return _val if _val is not None else default

    def def_ipv6network(self, default: IPv6Network) -> IPv6Network:
        _val = self.try_ipv6network()
        return _val if _val is not None else default

    def def_datetime(self, default: DateTime) -> DateTime:
        _val = self.try_datetime()
        return _val if _val is not None else default

    def def_date(self, default: Date) -> Date:
        _val = self.try_date()
        return _val if _val is not None else default

    def def_time(self, default: Time) -> Time:
        _val = self.try_time()
        return _val if _val is not None else default

    def def_duration(self, default: Duration) -> Duration:
        _val = self.try_duration()
        return _val if _val is not None else default

    def def_oid(self, default: Oid) -> Oid:
        _val = self.try_oid()
        return _val if _val is not None else default

    def def_keypath(self, default: Keypath) -> Keypath:
        _val = self.try_keypath()
        return _val if _val is not None else default

extension TNode(Indexed[Id, TNode]):
    def __getitem__(self, _id: Id) -> TNode:
        return self.go(_id)

    #def __setitem__(self, _id: Id, _id: TNode) -> None:
    def __setitem__(self, _id: Id, node: TNode) -> None:
        self.attach(_id, node)

    def __delitem__(self, _id: Id) -> None:
        self.remove(_id)

extension TNode(Iterable[TNode]):
    def __iter__(self) -> Iterator[TNode]:
        return self.iter()

class TTree(TNode):
    @property
    _key: ?Key
    @property
    _children: dict[Id, TNode]

    def __init__(self, op: int, tag: Tag, key: ?Key, children: dict[Id, TNode]):
        self._op = op
        self._tag = tag
        self._key = key
        self._children = children

    def __bool__(self):
        return self.exists() and self.has_children()

    def __str__(self) -> str:
        _tag = self.tag()
        s_tag = ", " + str(_tag) if _tag is not None else ""

        _keys = self.keys()
        s_keys = ", " + list_str(_keys) if _keys else ""

        s_children = ", " + mapping_str(self._children)

        return "TTree(" + op_str(self.op()) + s_tag + s_keys + s_children + ")"

    #
    # TNode
    #

    def iter(self) -> Iterator[TNode]:
        return self._children.values()

    def iter_ids(self) -> Iterator[Id]:
        return self._children.keys()

    def iter_items(self) -> Iterator[(Id, TNode)]:
        return self._children.items()

    def has_children(self) -> bool:
        return bool(self._children)

    def key(self) -> ?Key:
        return self._key

    def tree(self, op: ?int, _id: Id) -> TNode:
        old = try_get(self._children, _id)
        if old is not None:
            if op is not None and old._op != op:
                old.merge(TTree(op, _id if isinstance(_id, Tag) else self._tag, _id if isinstance(_id, Key) else None, {}))
            return old
        else:
            new = TTree(op if op is not None else OP_NONE, _id if isinstance(_id, Tag) else self._tag, _id if isinstance(_id, Key) else None, {})
            self._children[_id] = new
            return new

    def leaf(self, op: ?int, _id: Id, _val: ?value) -> TNode:
        new = TLeaf(op if op is not None else OP_NONE, _id if isinstance(_id, Tag) else self._tag, _val)
        self._children[_id] = new
        return new

    def remove(self, _id: Id) -> ?TNode:
        return try_pop(self._children, _id)

    def clear(self) -> TNode:
        #self._children.clear()
        self._children = {}
        return self

    def attach(self, _id: Id, other: TNode) -> TNode:
        self._children[_id] = other
        return other

    def merge(self, other: TNode) -> TNode:
        if isinstance(other, TTree):
            if other._op == OP_NOCREATE and self._op in [OP_DELETE, OP_REPLACE]:
                return self

            if other._op in [OP_DELETE, OP_REPLACE]:
                if self._op == OP_NONE:
                    self.clear()
                else:
                    if self._op != OP_DELETE:
                        self._op = OP_REPLACE
            elif other._op == OP_MERGE:
                if self._op == OP_DELETE:
                    self._op = OP_REPLACE
                elif self._op == OP_NOCREATE:
                    self._op = OP_MERGE

            for child_id, other_child in other._children.items():
                self_child: ?TNode = try_get(self._children, child_id)
                if self_child is not None:
                    if other_child._op == OP_DELETE and self_child._op == OP_NONE:
                        try_pop(self._children, child_id)
                    else:
                        self._children[child_id] = self_child.merge(other_child)
                elif not (other_child._op == OP_NOCREATE and self._op == OP_NONE):
                    self._children[child_id] = other_child._copy_deep(OP_NONE if self._op == OP_NONE else None)

            return self
        else:
            return other

    def _copy_deep(self, new_op: ?int) -> TNode:
        children: dict[Id, TNode] = {}
        for child_id, child in self._children.items():
            children[child_id] = child._copy_deep(new_op)
        return TTree(new_op if new_op is not None else self._op, self._tag, self._key, children)

    def exists(self) -> bool:
        return self._op not in [OP_DELETE, OP_NOCREATE]

    # TODO: For future convenience
    # def get(self, _id: value) -> ?TNode:
    #     if isinstance(_id, Id):
    #         return try_get(self._children, _id)
    #     elif isinstance(_id, str):
    #         ...
    #     elif isinstance(_id, int):
    #         ...
    #     elif isinstance(_id, list):
    #         ...
    #     elif isinstance(_id, tuple):
    #         ...
    #     return None

    def get(self, _id: Id) -> ?TNode:
        return try_get(self._children, _id)

    def has_child(self, _id: Id) -> bool:
        return _id in self._children

    #
    # Node
    #

    def keys(self) -> list[Node]:
        l: list[Node] = []
        _key = self._key
        if _key is not None:
            for key_val in _key:
                unsafe_list_append(l, XLeaf(self._op, None, None, key_val))
        return l

    def children(self) -> list[Node]:
        l: list[Node] = []
        for _child in self._children.values():
            if isinstance(_child, TTree):
                # _grand_children = _child._children
                # _first_grand_child = next(iter(_grand_children.keys()))
                # if _first_grand_child_id is not None and isinstance(_first_grand_child_id, Key):
                #     for _grand_child in _grand_children.values():
                #         unsafe_list_append(l, _grand_child)
                #     continue
                # https://github.com/actonlang/acton/issues/1265
                _grand_children = _child._children
                _first_grand_child_id = _grand_children.keys().__iter__().__next__()
                if _first_grand_child_id is not None and isinstance(_first_grand_child_id, Key):
                    for _grand_child in _grand_children.values():
                        unsafe_list_append(l, _grand_child)
                else:
                    unsafe_list_append(l, _child)
            else:
                unsafe_list_append(l, _child)
        return l

extension TTree(Iterable[TNode]):
    def __iter__(self) -> Iterator[TNode]:
        return self.iter()

# class TContainer(TTree):
#     pass

# class TList(TTree):
#     pass

# class TLeafList(TTree):
#     pass

class TLeaf(TNode):
    @property
    _value: ?value

    def __init__(self, op: int, tag: Tag, val: ?value):
        self._op = op
        self._tag = tag
        self._value = val

    def __str__(self) -> str:
        return self._str_compact("TLeaf")

    #
    # TNode
    #

    def remove(self, _id: Id) -> ?TNode:
        self.clear()
        return self

    def clear(self) -> TNode:
        self._op = OP_DELETE
        self._value = None
        return self

    def merge(self, other: TNode) -> TNode:
        if isinstance(other, TLeaf):
            if other._op == OP_DELETE:
                self.clear()
            elif other._op in [OP_MERGE, OP_REPLACE]:
                if self._op in [OP_DELETE, OP_NOCREATE]:
                    self._op = OP_NONE
                self._value = other._value
            return self
        else:
            return other

    def _copy_deep(self, new_op: ?int) -> TNode:
        return TLeaf(new_op if new_op is not None else self._op, self._tag, self._value)

    def exists(self) -> bool:
        return self._op not in [OP_DELETE, OP_NOCREATE]

    def try_value(self) -> ?value:
        return self._value

    def try_int(self) -> ?int:
        _val = self._value
        return _val if _val is not None and isinstance(_val, int) else None

    def try_str(self) -> ?str:
        _val = self._value
        return _val if _val is not None and isinstance(_val, str) else None

    def try_bool(self) -> ?bool:
        _val = self._value
        return _val if _val is not None and isinstance(_val, bool) else None

    def try_bytes(self) -> ?bytes:
        _val = self._value
        return _val if _val is not None and isinstance(_val, bytes) else None

    def try_decimal64(self) -> ?Decimal64:
        _val = self._value
        return _val if _val is not None and isinstance(_val, Decimal64) else None

    def try_itag(self) -> ?ITag:
        _val = self._value
        return _val if _val is not None and isinstance(_val, ITag) else None

    def try_ptag(self) -> ?PTag:
        _val = self._value
        return _val if _val is not None and isinstance(_val, PTag) else None

    def try_mtag(self) -> ?MTag:
        _val = self._value
        return _val if _val is not None and isinstance(_val, MTag) else None

    def try_htag(self) -> ?HTag:
        _val = self._value
        return _val if _val is not None and isinstance(_val, HTag) else None

    def try_ipv4address(self) -> ?IPv4Address:
        _val = self._value
        return _val if _val is not None and isinstance(_val, IPv4Address) else None

    def try_ipv6address(self) -> ?IPv6Address:
        _val = self._value
        return _val if _val is not None and isinstance(_val, IPv6Address) else None

    def try_ipv4network(self) -> ?IPv4Network:
        _val = self._value
        return _val if _val is not None and isinstance(_val, IPv4Network) else None

    def try_ipv6network(self) -> ?IPv6Network:
        _val = self._value
        return _val if _val is not None and isinstance(_val, IPv6Network) else None

    def try_datetime(self) -> ?DateTime:
        _val = self._value
        return _val if _val is not None and isinstance(_val, DateTime) else None

    def try_date(self) -> ?Date:
        _val = self._value
        return _val if _val is not None and isinstance(_val, Date) else None

    def try_time(self) -> ?Time:
        _val = self._value
        return _val if _val is not None and isinstance(_val, Time) else None

    def try_duration(self) -> ?Duration:
        _val = self._value
        return _val if _val is not None and isinstance(_val, Duration) else None

    def try_oid(self) -> ?Oid:
        _val = self._value
        return _val if _val is not None and isinstance(_val, Oid) else None

    def try_keypath(self) -> ?Keypath:
        _val = self._value
        return _val if _val is not None and isinstance(_val, Keypath) else None

    #
    # Node
    #

    def value(self) -> ?value:
        return self._value

# class TNode[T(Tag, Hashable)](Node):
#     @property
#     _tag: T

#     def ttag(self) -> T:
#         return self._tag

#     # def container(self) -> ?TContainer[T]:
#     #     return None

#     # def list(self) -> ?TList[T]:
#     #     return None

#     # def elem(self):
#     #     return None

#     # def leaf(self) -> ?TLeaf[T]:
#     #     return None

#     # Node
#     def tag(self) -> ?Tag:
#         return self._tag

# class TList[T(Tag, Hashable)](TNode[T]):
#     @property
#     _children: dict[Key, XNode]

#     def __init__(self):
#         self._children = {}

#     def elem(self, key: Key) -> ?TContainer[T]:
#         return None

# class TContainer[T(Tag, Hashable)](TNode[T]):
#     @property
#     _children: dict[T, XNode]

#     def __init__(self):
#         self._children = {}

#     def container(self) -> ?TContainer[T]:
#         return None

#     def list(self) -> ?TList[T]:
#         return None

#     def leaf(self) -> ?TLeaf[T]:
#         return None

# # class TElem[T(Tag, Hashable)](TContainer):
# #     def __init__(self):
# #         self._children = {}

# class TLeaf[T(Tag, Hashable)](TNode[T]):
#     @property
#     _value: ?value

#     def __init__(self):
#         self._value = None

extension Id(Hashable):
    def __eq__(self, other: Id):
        if isinstance(self, Tag):
            return isinstance(other, Tag) and self == other
        elif isinstance(self, Key):
            return isinstance(other, Key) and self == other
        else:
            raise Exception("Id.__eq__: Not Implemented for types " + str(type(self)) + " == " + str(type(other)))

    def __hash__(self):
        if isinstance(self, Tag):
            return hash(self)
        elif isinstance(self, Key):
            return hash(self)
        else:
            raise Exception("Id.__hash__: Not Implemented for type: " + type(self))

extension Tag(Hashable):
    def __eq__(self, other: Id):
        if isinstance(self, ITag) and isinstance(other, ITag):
            return self == other
        elif isinstance(self, PTag) and isinstance(other, PTag):
            return self == other
        elif isinstance(self, MTag) and isinstance(other, MTag):
            return self == other
        elif isinstance(self, HTag) and isinstance(other, HTag):
            return self == other
        else:
            raise Exception("Tag.__eq__: Not Implemented for types " + str(type(self)) + " == " + str(type(other)))

    def __hash__(self):
        if isinstance(self, ITag):
            return hash(self)
        elif isinstance(self, PTag):
            return hash(self)
        elif isinstance(self, MTag):
            return hash(self)
        elif isinstance(self, HTag):
            return hash(self)
        else:
            raise Exception("Tag.__hash__: Not Implemented for type: " + type(self))

extension Keypath(Hashable):
    def __eq__(self, other) -> bool:
        #return self.path == other.path
        return list_eq(self.path, other.path)

    def __hash__(self) -> int:
        #return sum([hash(x) for x in self.path], 0)
        return list_hash(self.path)
